Index: algorythms.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\">\r\n        <link href=\"https://fonts.googleapis.com/css2?family=Poppins:wght@300;400&display=swap\" rel=\"stylesheet\">\r\n        <link media=\"all\" rel=\"stylesheet\" href=\"algorythms.css\">\r\n        <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>\r\n        <script src=\"algorythms.js\"></script>\r\n    </head>\r\n        <body>\r\n            <div class=\"fields\">\r\n                <h2 class=\"h2 fields__heading\">I will generate a word, you have the privilege of guessing it one letter at a time.</h2>\r\n                <h4 class=\"h4 fields__subheading\">best of luck, you can fail thrice</h4>\r\n                <input class=\"fields__letter-input\" type=\"text\" maxlength=\"1\">\r\n                <button class=\"fields__submit\">Make a guess</button>\r\n                <div class=\"fields__lives\">\r\n                    <span class=\"fields__life life--full\"></span>\r\n                    <span class=\"fields__life life--full\"></span>\r\n                    <span class=\"fields__life life--full\"></span>\r\n                </div>\r\n                <div class=\"fields__results\"></div>\r\n                <div class=\"fields__garbage\">\r\n                    <h4 class=\"h4 fields__subheading\">&darr;&nbsp;here's your wasted effort&nbsp;&darr;</h4>\r\n                </div>\r\n            </div>\r\n        </body>\r\n</html>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- algorythms.html	(revision c17b84ca78eb0416f0ca36a7a3891fa8f6210848)
+++ algorythms.html	(date 1607610853630)
@@ -9,19 +9,10 @@
     </head>
         <body>
             <div class="fields">
-                <h2 class="h2 fields__heading">I will generate a word, you have the privilege of guessing it one letter at a time.</h2>
+                <h2 class="h2 fields__heading conversation">Enter a word</h2>
                 <h4 class="h4 fields__subheading">best of luck, you can fail thrice</h4>
                 <input class="fields__letter-input" type="text" maxlength="1">
                 <button class="fields__submit">Make a guess</button>
-                <div class="fields__lives">
-                    <span class="fields__life life--full"></span>
-                    <span class="fields__life life--full"></span>
-                    <span class="fields__life life--full"></span>
-                </div>
-                <div class="fields__results"></div>
-                <div class="fields__garbage">
-                    <h4 class="h4 fields__subheading">&darr;&nbsp;here's your wasted effort&nbsp;&darr;</h4>
-                </div>
             </div>
         </body>
 </html>
Index: algorythms.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// prevent script from starting before the document is ready\r\n\r\n$(document).ready(function(){\r\n    // define starting lives\r\n\r\n    let life = 3;\r\n\r\n    // define the element holding our results (the word we're looking for and the blanks replacing unrevealed words)\r\n\r\n    const results = $('.fields__results');\r\n\r\n    // our array of words\r\n\r\n    const words = ['pineapple', 'inequity', 'breadsticks', 'juxtaposition', 'enervated']\r\n\r\n    // function to generate an integer between 0 and max-1\r\n\r\n    function getRandomInt(max) {\r\n        return Math.floor(Math.random() * Math.floor(max));\r\n    }\r\n\r\n    // get current word from our array of 5 words (which is why max = 5 in this fnc).\r\n\r\n    const currentWord = words[getRandomInt(5)];\r\n\r\n    // for each letter in the word, we create a blank\r\n\r\n    for (i = 0; i < currentWord.length; i++) {\r\n        results.append('<span class=\"fields__results-letter\" id=\"results-letter-' + i + '\">_</span>')\r\n    }\r\n\r\n    // get button element and listen for click event. On click event we will check if letter exists in our current word. If not then lose life.\r\n\r\n    const button = $('.fields__submit');\r\n    const input = $('.fields__letter-input');\r\n\r\n    $(button).click();\r\n\r\n    $(button).click(function() {\r\n        const guessLetter = input.val().toLowerCase();\r\n        const wordLength = currentWord.length;\r\n        const garbageLetters = [];\r\n        let hasLetter = false;\r\n        let fullLife = $('.life--full')\r\n        input.val('');\r\n\r\n        // loop through letters of the word to find all matching letters\r\n        for (i = 0; i < wordLength; i++) {\r\n            if (currentWord[i] === guessLetter) {\r\n                hasLetter = true;\r\n                $('#results-letter-' + i).text(function (index, text) {\r\n                    return text.replace('_', guessLetter)\r\n                });\r\n            }\r\n        }\r\n\r\n        // we didnt find the corresponding letter from our word, so we will lose a life.\r\n\r\n        if (!hasLetter){\r\n            if(life > 1){\r\n                life = life - 1;\r\n                fullLife.first().removeClass('life--full');\r\n                //display wasted letters at the bottom of the page.\r\n                garbageLetters.push(guessLetter);\r\n                $('.fields__garbage').append(garbageLetters);\r\n            } else {\r\n                fullLife.first().removeClass('life--full');\r\n                //display wasted letters at the bottom of the page.\r\n                garbageLetters.push(guessLetter);\r\n                $('.fields__garbage').append(garbageLetters);\r\n                window.setTimeout(function(){\r\n                    //clear the timeout we set\r\n                    window.clearTimeout()\r\n                    //alet the player of loss\r\n                    alert('no win this time');\r\n                    //reload the window after alert has been closed.\r\n                    location.reload();\r\n                }, 500)\r\n            }\r\n        }\r\n\r\n        //display victory alert if player has guessed the word.\r\n\r\n        const guessedLetters = $('.fields__results-letter');\r\n\r\n        if(guessedLetters.text() === currentWord) {\r\n            window.setTimeout(function(){\r\n                window.clearTimeout();\r\n                alert('you did it, lets play again')\r\n                location.reload();\r\n            }, 800)\r\n        }\r\n\r\n    });\r\n})\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- algorythms.js	(revision c17b84ca78eb0416f0ca36a7a3891fa8f6210848)
+++ algorythms.js	(date 1607610565316)
@@ -3,7 +3,7 @@
 $(document).ready(function(){
     // define starting lives
 
-    let life = 3;
+    let life = 1;
 
     // define the element holding our results (the word we're looking for and the blanks replacing unrevealed words)
 
@@ -11,7 +11,7 @@
 
     // our array of words
 
-    const words = ['pineapple', 'inequity', 'breadsticks', 'juxtaposition', 'enervated']
+    const words = []
 
     // function to generate an integer between 0 and max-1
 
Index: node_modules/ometa/readme-rhino.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/readme-rhino.txt	(date 1323192249000)
+++ node_modules/ometa/readme-rhino.txt	(date 1323192249000)
@@ -0,0 +1,10 @@
+To use OMeta under Rhino:
+
+Monad:~/prog/ometa-js awarth$ java org.mozilla.javascript.tools.shell.Main                
+Rhino 1.7 release 1 2008 03 06
+js> load("ometa-rhino.js")
+js> ometa("ometa M { ones = 1* }")
+[object Object]
+js> M.matchAll([1, 1, 1, 1, 1], "ones")
+[1, 1, 1, 1, 1]
+
Index: node_modules/ometa/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/README.md	(date 1323192249000)
+++ node_modules/ometa/README.md	(date 1323192249000)
@@ -0,0 +1,84 @@
+# OMeta/JS
+
+OMeta/JS is a JavaScript implementation of OMeta
+
+## Main Repository
+
+This repository is a forked version of the original intended to
+provide an api to node.js and also a package for npm. Questions
+about the core should be directed to the original author, Alessandro
+Warth.
+
+## Original README
+
+The following files contain some important info:
+
+* Not_Quite_JS.txt explains the difference between "real" JavaScript and
+  the JavaScript that can be used in the OMeta/JS Workspace.
+
+* Things_You_Should_Know.txt explains the differences between the original
+  OMeta syntax (as it appeared in the DLS'07 paper) and the newer OMeta/js
+  syntax.
+
+* OMeta_Tutorial.txt contains a bunch of examples that show how OMeta
+  can be used for pattern matching, parsing, etc.
+
+Another good resource for OMeta programmers is the OMeta mailing list. To
+subscribe, please visit:
+
+    http://vpri.org/mailman/listinfo/ometa
+
+And you can also browse the archives of the mailing list at:
+
+    http://vpri.org/pipermail/ometa/
+
+Cheers,
+Alex 
+
+## MIT and Modified MIT License
+
+Copyright (c) 2010 Brian Mavity 
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+Except as contained in this notice, the name(s) of the above copyright
+holders shall not be used in advertising or otherwise to promote the sale,
+use or other dealings in this Software without prior written authorization.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+
+
+Copyright (c) 2007-2010 Alessandro Warth
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
Index: node_modules/ometa/parser.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/parser.js	(date 1323192249000)
+++ node_modules/ometa/parser.js	(date 1323192249000)
@@ -0,0 +1,46 @@
+/*
+  Copyright (c) 2007, 2008 Alessandro Warth <awarth@cs.ucla.edu>
+
+  Permission is hereby granted, free of charge, to any person
+  obtaining a copy of this software and associated documentation
+  files (the "Software"), to deal in the Software without
+  restriction, including without limitation the rights to use,
+  copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following
+  conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+  OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+Parser = objectThatDelegatesTo(OMeta, {
+  listOf: function() {
+    var rule  = this._apply("anything"),
+        delim = this._apply("anything")
+    return this._or(function() {
+                      var r = this._apply(rule)
+                      return this._many(function() {
+                                          this._applyWithArgs("token", delim)
+                                          return this._apply(rule)
+                                        },
+                                        r)
+                    },
+                    function() { return [] })
+  },
+  token: function() {
+    var cs = this._apply("anything")
+    this._apply("spaces")
+    return this._applyWithArgs("seq", cs)
+  }
+})
+
Index: node_modules/ometa/prototype.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/prototype.js	(date 1323192249000)
+++ node_modules/ometa/prototype.js	(date 1323192249000)
@@ -0,0 +1,4222 @@
+/*  Prototype JavaScript framework, version 1.6.0.2
+ *  (c) 2005-2008 Sam Stephenson
+ *
+ *  Prototype is freely distributable under the terms of an MIT-style license.
+ *  For details, see the Prototype web site: http://www.prototypejs.org/
+ *
+ *--------------------------------------------------------------------------*/
+
+var Prototype = {
+  Version: '1.6.0.2',
+
+  Browser: {
+    IE:     !!(window.attachEvent && !window.opera),
+    Opera:  !!window.opera,
+    WebKit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
+    Gecko:  navigator.userAgent.indexOf('Gecko') > -1 && navigator.userAgent.indexOf('KHTML') == -1,
+    MobileSafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/)
+  },
+
+  BrowserFeatures: {
+    XPath: !!document.evaluate,
+    ElementExtensions: !!window.HTMLElement,
+    SpecificElementExtensions:
+      document.createElement('div').__proto__ &&
+      document.createElement('div').__proto__ !==
+        document.createElement('form').__proto__
+  },
+
+  ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>',
+  JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
+
+  emptyFunction: function() { },
+  K: function(x) { return x }
+};
+
+if (Prototype.Browser.MobileSafari)
+  Prototype.BrowserFeatures.SpecificElementExtensions = false;
+
+
+/* Based on Alex Arnell's inheritance implementation. */
+var Class = {
+  create: function() {
+    var parent = null, properties = $A(arguments);
+    if (Object.isFunction(properties[0]))
+      parent = properties.shift();
+
+    function klass() {
+      this.initialize.apply(this, arguments);
+    }
+
+    Object.extend(klass, Class.Methods);
+    klass.superclass = parent;
+    klass.subclasses = [];
+
+    if (parent) {
+      var subclass = function() { };
+      subclass.prototype = parent.prototype;
+      klass.prototype = new subclass;
+      parent.subclasses.push(klass);
+    }
+
+    for (var i = 0; i < properties.length; i++)
+      klass.addMethods(properties[i]);
+
+    if (!klass.prototype.initialize)
+      klass.prototype.initialize = Prototype.emptyFunction;
+
+    klass.prototype.constructor = klass;
+
+    return klass;
+  }
+};
+
+Class.Methods = {
+  addMethods: function(source) {
+    var ancestor   = this.superclass && this.superclass.prototype;
+    var properties = Object.keys(source);
+
+    if (!Object.keys({ toString: true }).length)
+      properties.push("toString", "valueOf");
+
+    for (var i = 0, length = properties.length; i < length; i++) {
+      var property = properties[i], value = source[property];
+      if (ancestor && Object.isFunction(value) &&
+          value.argumentNames().first() == "$super") {
+        var method = value, value = Object.extend((function(m) {
+          return function() { return ancestor[m].apply(this, arguments) };
+        })(property).wrap(method), {
+          valueOf:  function() { return method },
+          toString: function() { return method.toString() }
+        });
+      }
+      this.prototype[property] = value;
+    }
+
+    return this;
+  }
+};
+
+var Abstract = { };
+
+Object.extend = function(destination, source) {
+  for (var property in source)
+    destination[property] = source[property];
+  return destination;
+};
+
+Object.extend(Object, {
+  inspect: function(object) {
+    try {
+      if (Object.isUndefined(object)) return 'undefined';
+      if (object === null) return 'null';
+      return object.inspect ? object.inspect() : String(object);
+    } catch (e) {
+      if (e instanceof RangeError) return '...';
+      throw e;
+    }
+  },
+
+  toJSON: function(object) {
+    var type = typeof object;
+    switch (type) {
+      case 'undefined':
+      case 'function':
+      case 'unknown': return;
+      case 'boolean': return object.toString();
+    }
+
+    if (object === null) return 'null';
+    if (object.toJSON) return object.toJSON();
+    if (Object.isElement(object)) return;
+
+    var results = [];
+    for (var property in object) {
+      var value = Object.toJSON(object[property]);
+      if (!Object.isUndefined(value))
+        results.push(property.toJSON() + ': ' + value);
+    }
+
+    return '{' + results.join(', ') + '}';
+  },
+
+  toQueryString: function(object) {
+    return $H(object).toQueryString();
+  },
+
+  toHTML: function(object) {
+    return object && object.toHTML ? object.toHTML() : String.interpret(object);
+  },
+
+  keys: function(object) {
+    var keys = [];
+    for (var property in object)
+      keys.push(property);
+    return keys;
+  },
+
+  values: function(object) {
+    var values = [];
+    for (var property in object)
+      values.push(object[property]);
+    return values;
+  },
+
+  clone: function(object) {
+    return Object.extend({ }, object);
+  },
+
+  isElement: function(object) {
+    return object && object.nodeType == 1;
+  },
+
+  isArray: function(object) {
+    return object != null && typeof object == "object" &&
+      'splice' in object && 'join' in object;
+  },
+
+  isHash: function(object) {
+    return object instanceof Hash;
+  },
+
+  isFunction: function(object) {
+    return typeof object == "function";
+  },
+
+  isString: function(object) {
+    return typeof object == "string";
+  },
+
+  isNumber: function(object) {
+    return typeof object == "number";
+  },
+
+  isUndefined: function(object) {
+    return typeof object == "undefined";
+  }
+});
+
+Object.extend(Function.prototype, {
+  argumentNames: function() {
+    var names = this.toString().match(/^[\s\(]*function[^(]*\((.*?)\)/)[1].split(",").invoke("strip");
+    return names.length == 1 && !names[0] ? [] : names;
+  },
+
+  bind: function() {
+    if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
+    var __method = this, args = $A(arguments), object = args.shift();
+    return function() {
+      return __method.apply(object, args.concat($A(arguments)));
+    }
+  },
+
+  bindAsEventListener: function() {
+    var __method = this, args = $A(arguments), object = args.shift();
+    return function(event) {
+      return __method.apply(object, [event || window.event].concat(args));
+    }
+  },
+
+  curry: function() {
+    if (!arguments.length) return this;
+    var __method = this, args = $A(arguments);
+    return function() {
+      return __method.apply(this, args.concat($A(arguments)));
+    }
+  },
+
+  delay: function() {
+    var __method = this, args = $A(arguments), timeout = args.shift() * 1000;
+    return window.setTimeout(function() {
+      return __method.apply(__method, args);
+    }, timeout);
+  },
+
+  wrap: function(wrapper) {
+    var __method = this;
+    return function() {
+      return wrapper.apply(this, [__method.bind(this)].concat($A(arguments)));
+    }
+  },
+
+  methodize: function() {
+    if (this._methodized) return this._methodized;
+    var __method = this;
+    return this._methodized = function() {
+      return __method.apply(null, [this].concat($A(arguments)));
+    };
+  }
+});
+
+Function.prototype.defer = Function.prototype.delay.curry(0.01);
+
+Date.prototype.toJSON = function() {
+  return '"' + this.getUTCFullYear() + '-' +
+    (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
+    this.getUTCDate().toPaddedString(2) + 'T' +
+    this.getUTCHours().toPaddedString(2) + ':' +
+    this.getUTCMinutes().toPaddedString(2) + ':' +
+    this.getUTCSeconds().toPaddedString(2) + 'Z"';
+};
+
+var Try = {
+  these: function() {
+    var returnValue;
+
+    for (var i = 0, length = arguments.length; i < length; i++) {
+      var lambda = arguments[i];
+      try {
+        returnValue = lambda();
+        break;
+      } catch (e) { }
+    }
+
+    return returnValue;
+  }
+};
+
+RegExp.prototype.match = RegExp.prototype.test;
+
+RegExp.escape = function(str) {
+  return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
+};
+
+/*--------------------------------------------------------------------------*/
+
+var PeriodicalExecuter = Class.create({
+  initialize: function(callback, frequency) {
+    this.callback = callback;
+    this.frequency = frequency;
+    this.currentlyExecuting = false;
+
+    this.registerCallback();
+  },
+
+  registerCallback: function() {
+    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
+  },
+
+  execute: function() {
+    this.callback(this);
+  },
+
+  stop: function() {
+    if (!this.timer) return;
+    clearInterval(this.timer);
+    this.timer = null;
+  },
+
+  onTimerEvent: function() {
+    if (!this.currentlyExecuting) {
+      try {
+        this.currentlyExecuting = true;
+        this.execute();
+      } finally {
+        this.currentlyExecuting = false;
+      }
+    }
+  }
+});
+Object.extend(String, {
+  interpret: function(value) {
+    return value == null ? '' : String(value);
+  },
+  specialChar: {
+    '\b': '\\b',
+    '\t': '\\t',
+    '\n': '\\n',
+    '\f': '\\f',
+    '\r': '\\r',
+    '\\': '\\\\'
+  }
+});
+
+Object.extend(String.prototype, {
+  gsub: function(pattern, replacement) {
+    var result = '', source = this, match;
+    replacement = arguments.callee.prepareReplacement(replacement);
+
+    while (source.length > 0) {
+      if (match = source.match(pattern)) {
+        result += source.slice(0, match.index);
+        result += String.interpret(replacement(match));
+        source  = source.slice(match.index + match[0].length);
+      } else {
+        result += source, source = '';
+      }
+    }
+    return result;
+  },
+
+  sub: function(pattern, replacement, count) {
+    replacement = this.gsub.prepareReplacement(replacement);
+    count = Object.isUndefined(count) ? 1 : count;
+
+    return this.gsub(pattern, function(match) {
+      if (--count < 0) return match[0];
+      return replacement(match);
+    });
+  },
+
+  scan: function(pattern, iterator) {
+    this.gsub(pattern, iterator);
+    return String(this);
+  },
+
+  truncate: function(length, truncation) {
+    length = length || 30;
+    truncation = Object.isUndefined(truncation) ? '...' : truncation;
+    return this.length > length ?
+      this.slice(0, length - truncation.length) + truncation : String(this);
+  },
+
+  strip: function() {
+    return this.replace(/^\s+/, '').replace(/\s+$/, '');
+  },
+
+  stripTags: function() {
+    return this.replace(/<\/?[^>]+>/gi, '');
+  },
+
+  stripScripts: function() {
+    return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');
+  },
+
+  extractScripts: function() {
+    var matchAll = new RegExp(Prototype.ScriptFragment, 'img');
+    var matchOne = new RegExp(Prototype.ScriptFragment, 'im');
+    return (this.match(matchAll) || []).map(function(scriptTag) {
+      return (scriptTag.match(matchOne) || ['', ''])[1];
+    });
+  },
+
+  evalScripts: function() {
+    return this.extractScripts().map(function(script) { return eval(script) });
+  },
+
+  escapeHTML: function() {
+    var self = arguments.callee;
+    self.text.data = this;
+    return self.div.innerHTML;
+  },
+
+  unescapeHTML: function() {
+    var div = new Element('div');
+    div.innerHTML = this.stripTags();
+    return div.childNodes[0] ? (div.childNodes.length > 1 ?
+      $A(div.childNodes).inject('', function(memo, node) { return memo+node.nodeValue }) :
+      div.childNodes[0].nodeValue) : '';
+  },
+
+  toQueryParams: function(separator) {
+    var match = this.strip().match(/([^?#]*)(#.*)?$/);
+    if (!match) return { };
+
+    return match[1].split(separator || '&').inject({ }, function(hash, pair) {
+      if ((pair = pair.split('='))[0]) {
+        var key = decodeURIComponent(pair.shift());
+        var value = pair.length > 1 ? pair.join('=') : pair[0];
+        if (value != undefined) value = decodeURIComponent(value);
+
+        if (key in hash) {
+          if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
+          hash[key].push(value);
+        }
+        else hash[key] = value;
+      }
+      return hash;
+    });
+  },
+
+  toArray: function() {
+    return this.split('');
+  },
+
+  succ: function() {
+    return this.slice(0, this.length - 1) +
+      String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
+  },
+
+  times: function(count) {
+    return count < 1 ? '' : new Array(count + 1).join(this);
+  },
+
+  camelize: function() {
+    var parts = this.split('-'), len = parts.length;
+    if (len == 1) return parts[0];
+
+    var camelized = this.charAt(0) == '-'
+      ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1)
+      : parts[0];
+
+    for (var i = 1; i < len; i++)
+      camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
+
+    return camelized;
+  },
+
+  capitalize: function() {
+    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
+  },
+
+  underscore: function() {
+    return this.gsub(/::/, '/').gsub(/([A-Z]+)([A-Z][a-z])/,'#{1}_#{2}').gsub(/([a-z\d])([A-Z])/,'#{1}_#{2}').gsub(/-/,'_').toLowerCase();
+  },
+
+  dasherize: function() {
+    return this.gsub(/_/,'-');
+  },
+
+  inspect: function(useDoubleQuotes) {
+    var escapedString = this.gsub(/[\x00-\x1f\\]/, function(match) {
+      var character = String.specialChar[match[0]];
+      return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16);
+    });
+    if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
+    return "'" + escapedString.replace(/'/g, '\\\'') + "'";
+  },
+
+  toJSON: function() {
+    return this.inspect(true);
+  },
+
+  unfilterJSON: function(filter) {
+    return this.sub(filter || Prototype.JSONFilter, '#{1}');
+  },
+
+  isJSON: function() {
+    var str = this;
+    if (str.blank()) return false;
+    str = this.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, '');
+    return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(str);
+  },
+
+  evalJSON: function(sanitize) {
+    var json = this.unfilterJSON();
+    try {
+      if (!sanitize || json.isJSON()) return eval('(' + json + ')');
+    } catch (e) { }
+    throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
+  },
+
+  include: function(pattern) {
+    return this.indexOf(pattern) > -1;
+  },
+
+  startsWith: function(pattern) {
+    return this.indexOf(pattern) === 0;
+  },
+
+  endsWith: function(pattern) {
+    var d = this.length - pattern.length;
+    return d >= 0 && this.lastIndexOf(pattern) === d;
+  },
+
+  empty: function() {
+    return this == '';
+  },
+
+  blank: function() {
+    return /^\s*$/.test(this);
+  },
+
+  interpolate: function(object, pattern) {
+    return new Template(this, pattern).evaluate(object);
+  }
+});
+
+if (Prototype.Browser.WebKit || Prototype.Browser.IE) Object.extend(String.prototype, {
+  escapeHTML: function() {
+    return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
+  },
+  unescapeHTML: function() {
+    return this.replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>');
+  }
+});
+
+String.prototype.gsub.prepareReplacement = function(replacement) {
+  if (Object.isFunction(replacement)) return replacement;
+  var template = new Template(replacement);
+  return function(match) { return template.evaluate(match) };
+};
+
+String.prototype.parseQuery = String.prototype.toQueryParams;
+
+Object.extend(String.prototype.escapeHTML, {
+  div:  document.createElement('div'),
+  text: document.createTextNode('')
+});
+
+with (String.prototype.escapeHTML) div.appendChild(text);
+
+var Template = Class.create({
+  initialize: function(template, pattern) {
+    this.template = template.toString();
+    this.pattern = pattern || Template.Pattern;
+  },
+
+  evaluate: function(object) {
+    if (Object.isFunction(object.toTemplateReplacements))
+      object = object.toTemplateReplacements();
+
+    return this.template.gsub(this.pattern, function(match) {
+      if (object == null) return '';
+
+      var before = match[1] || '';
+      if (before == '\\') return match[2];
+
+      var ctx = object, expr = match[3];
+      var pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
+      match = pattern.exec(expr);
+      if (match == null) return before;
+
+      while (match != null) {
+        var comp = match[1].startsWith('[') ? match[2].gsub('\\\\]', ']') : match[1];
+        ctx = ctx[comp];
+        if (null == ctx || '' == match[3]) break;
+        expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
+        match = pattern.exec(expr);
+      }
+
+      return before + String.interpret(ctx);
+    });
+  }
+});
+Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
+
+var $break = { };
+
+var Enumerable = {
+  each: function(iterator, context) {
+    var index = 0;
+    iterator = iterator.bind(context);
+    try {
+      this._each(function(value) {
+        iterator(value, index++);
+      });
+    } catch (e) {
+      if (e != $break) throw e;
+    }
+    return this;
+  },
+
+  eachSlice: function(number, iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var index = -number, slices = [], array = this.toArray();
+    while ((index += number) < array.length)
+      slices.push(array.slice(index, index+number));
+    return slices.collect(iterator, context);
+  },
+
+  all: function(iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var result = true;
+    this.each(function(value, index) {
+      result = result && !!iterator(value, index);
+      if (!result) throw $break;
+    });
+    return result;
+  },
+
+  any: function(iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var result = false;
+    this.each(function(value, index) {
+      if (result = !!iterator(value, index))
+        throw $break;
+    });
+    return result;
+  },
+
+  collect: function(iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var results = [];
+    this.each(function(value, index) {
+      results.push(iterator(value, index));
+    });
+    return results;
+  },
+
+  detect: function(iterator, context) {
+    iterator = iterator.bind(context);
+    var result;
+    this.each(function(value, index) {
+      if (iterator(value, index)) {
+        result = value;
+        throw $break;
+      }
+    });
+    return result;
+  },
+
+  findAll: function(iterator, context) {
+    iterator = iterator.bind(context);
+    var results = [];
+    this.each(function(value, index) {
+      if (iterator(value, index))
+        results.push(value);
+    });
+    return results;
+  },
+
+  grep: function(filter, iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var results = [];
+
+    if (Object.isString(filter))
+      filter = new RegExp(filter);
+
+    this.each(function(value, index) {
+      if (filter.match(value))
+        results.push(iterator(value, index));
+    });
+    return results;
+  },
+
+  include: function(object) {
+    if (Object.isFunction(this.indexOf))
+      if (this.indexOf(object) != -1) return true;
+
+    var found = false;
+    this.each(function(value) {
+      if (value == object) {
+        found = true;
+        throw $break;
+      }
+    });
+    return found;
+  },
+
+  inGroupsOf: function(number, fillWith) {
+    fillWith = Object.isUndefined(fillWith) ? null : fillWith;
+    return this.eachSlice(number, function(slice) {
+      while(slice.length < number) slice.push(fillWith);
+      return slice;
+    });
+  },
+
+  inject: function(memo, iterator, context) {
+    iterator = iterator.bind(context);
+    this.each(function(value, index) {
+      memo = iterator(memo, value, index);
+    });
+    return memo;
+  },
+
+  invoke: function(method) {
+    var args = $A(arguments).slice(1);
+    return this.map(function(value) {
+      return value[method].apply(value, args);
+    });
+  },
+
+  max: function(iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var result;
+    this.each(function(value, index) {
+      value = iterator(value, index);
+      if (result == null || value >= result)
+        result = value;
+    });
+    return result;
+  },
+
+  min: function(iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var result;
+    this.each(function(value, index) {
+      value = iterator(value, index);
+      if (result == null || value < result)
+        result = value;
+    });
+    return result;
+  },
+
+  partition: function(iterator, context) {
+    iterator = iterator ? iterator.bind(context) : Prototype.K;
+    var trues = [], falses = [];
+    this.each(function(value, index) {
+      (iterator(value, index) ?
+        trues : falses).push(value);
+    });
+    return [trues, falses];
+  },
+
+  pluck: function(property) {
+    var results = [];
+    this.each(function(value) {
+      results.push(value[property]);
+    });
+    return results;
+  },
+
+  reject: function(iterator, context) {
+    iterator = iterator.bind(context);
+    var results = [];
+    this.each(function(value, index) {
+      if (!iterator(value, index))
+        results.push(value);
+    });
+    return results;
+  },
+
+  sortBy: function(iterator, context) {
+    iterator = iterator.bind(context);
+    return this.map(function(value, index) {
+      return {value: value, criteria: iterator(value, index)};
+    }).sort(function(left, right) {
+      var a = left.criteria, b = right.criteria;
+      return a < b ? -1 : a > b ? 1 : 0;
+    }).pluck('value');
+  },
+
+  toArray: function() {
+    return this.map();
+  },
+
+  zip: function() {
+    var iterator = Prototype.K, args = $A(arguments);
+    if (Object.isFunction(args.last()))
+      iterator = args.pop();
+
+    var collections = [this].concat(args).map($A);
+    return this.map(function(value, index) {
+      return iterator(collections.pluck(index));
+    });
+  },
+
+  size: function() {
+    return this.toArray().length;
+  },
+
+  inspect: function() {
+    return '#<Enumerable:' + this.toArray().inspect() + '>';
+  }
+};
+
+Object.extend(Enumerable, {
+  map:     Enumerable.collect,
+  find:    Enumerable.detect,
+  select:  Enumerable.findAll,
+  filter:  Enumerable.findAll,
+  member:  Enumerable.include,
+  entries: Enumerable.toArray,
+  every:   Enumerable.all,
+  some:    Enumerable.any
+});
+function $A(iterable) {
+  if (!iterable) return [];
+  if (iterable.toArray) return iterable.toArray();
+  var length = iterable.length || 0, results = new Array(length);
+  while (length--) results[length] = iterable[length];
+  return results;
+}
+
+if (Prototype.Browser.WebKit) {
+  $A = function(iterable) {
+    if (!iterable) return [];
+    if (!(Object.isFunction(iterable) && iterable == '[object NodeList]') &&
+        iterable.toArray) return iterable.toArray();
+    var length = iterable.length || 0, results = new Array(length);
+    while (length--) results[length] = iterable[length];
+    return results;
+  };
+}
+
+Array.from = $A;
+
+Object.extend(Array.prototype, Enumerable);
+
+if (!Array.prototype._reverse) Array.prototype._reverse = Array.prototype.reverse;
+
+Object.extend(Array.prototype, {
+  _each: function(iterator) {
+    for (var i = 0, length = this.length; i < length; i++)
+      iterator(this[i]);
+  },
+
+  clear: function() {
+    this.length = 0;
+    return this;
+  },
+
+  first: function() {
+    return this[0];
+  },
+
+  last: function() {
+    return this[this.length - 1];
+  },
+
+  compact: function() {
+    return this.select(function(value) {
+      return value != null;
+    });
+  },
+
+  flatten: function() {
+    return this.inject([], function(array, value) {
+      return array.concat(Object.isArray(value) ?
+        value.flatten() : [value]);
+    });
+  },
+
+  without: function() {
+    var values = $A(arguments);
+    return this.select(function(value) {
+      return !values.include(value);
+    });
+  },
+
+  reverse: function(inline) {
+    return (inline !== false ? this : this.toArray())._reverse();
+  },
+
+  reduce: function() {
+    return this.length > 1 ? this : this[0];
+  },
+
+  uniq: function(sorted) {
+    return this.inject([], function(array, value, index) {
+      if (0 == index || (sorted ? array.last() != value : !array.include(value)))
+        array.push(value);
+      return array;
+    });
+  },
+
+  intersect: function(array) {
+    return this.uniq().findAll(function(item) {
+      return array.detect(function(value) { return item === value });
+    });
+  },
+
+  clone: function() {
+    return [].concat(this);
+  },
+
+  size: function() {
+    return this.length;
+  },
+
+  inspect: function() {
+    return '[' + this.map(Object.inspect).join(', ') + ']';
+  },
+
+  toJSON: function() {
+    var results = [];
+    this.each(function(object) {
+      var value = Object.toJSON(object);
+      if (!Object.isUndefined(value)) results.push(value);
+    });
+    return '[' + results.join(', ') + ']';
+  }
+});
+
+// use native browser JS 1.6 implementation if available
+if (Object.isFunction(Array.prototype.forEach))
+  Array.prototype._each = Array.prototype.forEach;
+
+if (!Array.prototype.indexOf) Array.prototype.indexOf = function(item, i) {
+  i || (i = 0);
+  var length = this.length;
+  if (i < 0) i = length + i;
+  for (; i < length; i++)
+    if (this[i] === item) return i;
+  return -1;
+};
+
+if (!Array.prototype.lastIndexOf) Array.prototype.lastIndexOf = function(item, i) {
+  i = isNaN(i) ? this.length : (i < 0 ? this.length + i : i) + 1;
+  var n = this.slice(0, i).reverse().indexOf(item);
+  return (n < 0) ? n : i - n - 1;
+};
+
+Array.prototype.toArray = Array.prototype.clone;
+
+function $w(string) {
+  if (!Object.isString(string)) return [];
+  string = string.strip();
+  return string ? string.split(/\s+/) : [];
+}
+
+if (Prototype.Browser.Opera){
+  Array.prototype.concat = function() {
+    var array = [];
+    for (var i = 0, length = this.length; i < length; i++) array.push(this[i]);
+    for (var i = 0, length = arguments.length; i < length; i++) {
+      if (Object.isArray(arguments[i])) {
+        for (var j = 0, arrayLength = arguments[i].length; j < arrayLength; j++)
+          array.push(arguments[i][j]);
+      } else {
+        array.push(arguments[i]);
+      }
+    }
+    return array;
+  };
+}
+Object.extend(Number.prototype, {
+  toColorPart: function() {
+    return this.toPaddedString(2, 16);
+  },
+
+  succ: function() {
+    return this + 1;
+  },
+
+  times: function(iterator) {
+    $R(0, this, true).each(iterator);
+    return this;
+  },
+
+  toPaddedString: function(length, radix) {
+    var string = this.toString(radix || 10);
+    return '0'.times(length - string.length) + string;
+  },
+
+  toJSON: function() {
+    return isFinite(this) ? this.toString() : 'null';
+  }
+});
+
+$w('abs round ceil floor').each(function(method){
+  Number.prototype[method] = Math[method].methodize();
+});
+function $H(object) {
+  return new Hash(object);
+};
+
+var Hash = Class.create(Enumerable, (function() {
+
+  function toQueryPair(key, value) {
+    if (Object.isUndefined(value)) return key;
+    return key + '=' + encodeURIComponent(String.interpret(value));
+  }
+
+  return {
+    initialize: function(object) {
+      this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
+    },
+
+    _each: function(iterator) {
+      for (var key in this._object) {
+        var value = this._object[key], pair = [key, value];
+        pair.key = key;
+        pair.value = value;
+        iterator(pair);
+      }
+    },
+
+    set: function(key, value) {
+      return this._object[key] = value;
+    },
+
+    get: function(key) {
+      return this._object[key];
+    },
+
+    unset: function(key) {
+      var value = this._object[key];
+      delete this._object[key];
+      return value;
+    },
+
+    toObject: function() {
+      return Object.clone(this._object);
+    },
+
+    keys: function() {
+      return this.pluck('key');
+    },
+
+    values: function() {
+      return this.pluck('value');
+    },
+
+    index: function(value) {
+      var match = this.detect(function(pair) {
+        return pair.value === value;
+      });
+      return match && match.key;
+    },
+
+    merge: function(object) {
+      return this.clone().update(object);
+    },
+
+    update: function(object) {
+      return new Hash(object).inject(this, function(result, pair) {
+        result.set(pair.key, pair.value);
+        return result;
+      });
+    },
+
+    toQueryString: function() {
+      return this.map(function(pair) {
+        var key = encodeURIComponent(pair.key), values = pair.value;
+
+        if (values && typeof values == 'object') {
+          if (Object.isArray(values))
+            return values.map(toQueryPair.curry(key)).join('&');
+        }
+        return toQueryPair(key, values);
+      }).join('&');
+    },
+
+    inspect: function() {
+      return '#<Hash:{' + this.map(function(pair) {
+        return pair.map(Object.inspect).join(': ');
+      }).join(', ') + '}>';
+    },
+
+    toJSON: function() {
+      return Object.toJSON(this.toObject());
+    },
+
+    clone: function() {
+      return new Hash(this);
+    }
+  }
+})());
+
+Hash.prototype.toTemplateReplacements = Hash.prototype.toObject;
+Hash.from = $H;
+var ObjectRange = Class.create(Enumerable, {
+  initialize: function(start, end, exclusive) {
+    this.start = start;
+    this.end = end;
+    this.exclusive = exclusive;
+  },
+
+  _each: function(iterator) {
+    var value = this.start;
+    while (this.include(value)) {
+      iterator(value);
+      value = value.succ();
+    }
+  },
+
+  include: function(value) {
+    if (value < this.start)
+      return false;
+    if (this.exclusive)
+      return value < this.end;
+    return value <= this.end;
+  }
+});
+
+var $R = function(start, end, exclusive) {
+  return new ObjectRange(start, end, exclusive);
+};
+
+var Ajax = {
+  getTransport: function() {
+    return Try.these(
+      function() {return new XMLHttpRequest()},
+      function() {return new ActiveXObject('Msxml2.XMLHTTP')},
+      function() {return new ActiveXObject('Microsoft.XMLHTTP')}
+    ) || false;
+  },
+
+  activeRequestCount: 0
+};
+
+Ajax.Responders = {
+  responders: [],
+
+  _each: function(iterator) {
+    this.responders._each(iterator);
+  },
+
+  register: function(responder) {
+    if (!this.include(responder))
+      this.responders.push(responder);
+  },
+
+  unregister: function(responder) {
+    this.responders = this.responders.without(responder);
+  },
+
+  dispatch: function(callback, request, transport, json) {
+    this.each(function(responder) {
+      if (Object.isFunction(responder[callback])) {
+        try {
+          responder[callback].apply(responder, [request, transport, json]);
+        } catch (e) { }
+      }
+    });
+  }
+};
+
+Object.extend(Ajax.Responders, Enumerable);
+
+Ajax.Responders.register({
+  onCreate:   function() { Ajax.activeRequestCount++ },
+  onComplete: function() { Ajax.activeRequestCount-- }
+});
+
+Ajax.Base = Class.create({
+  initialize: function(options) {
+    this.options = {
+      method:       'post',
+      asynchronous: true,
+      contentType:  'application/x-www-form-urlencoded',
+      encoding:     'UTF-8',
+      parameters:   '',
+      evalJSON:     true,
+      evalJS:       true
+    };
+    Object.extend(this.options, options || { });
+
+    this.options.method = this.options.method.toLowerCase();
+
+    if (Object.isString(this.options.parameters))
+      this.options.parameters = this.options.parameters.toQueryParams();
+    else if (Object.isHash(this.options.parameters))
+      this.options.parameters = this.options.parameters.toObject();
+  }
+});
+
+Ajax.Request = Class.create(Ajax.Base, {
+  _complete: false,
+
+  initialize: function($super, url, options) {
+    $super(options);
+    this.transport = Ajax.getTransport();
+    this.request(url);
+  },
+
+  request: function(url) {
+    this.url = url;
+    this.method = this.options.method;
+    var params = Object.clone(this.options.parameters);
+
+    if (!['get', 'post'].include(this.method)) {
+      // simulate other verbs over post
+      params['_method'] = this.method;
+      this.method = 'post';
+    }
+
+    this.parameters = params;
+
+    if (params = Object.toQueryString(params)) {
+      // when GET, append parameters to URL
+      if (this.method == 'get')
+        this.url += (this.url.include('?') ? '&' : '?') + params;
+      else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent))
+        params += '&_=';
+    }
+
+    try {
+      var response = new Ajax.Response(this);
+      if (this.options.onCreate) this.options.onCreate(response);
+      Ajax.Responders.dispatch('onCreate', this, response);
+
+      this.transport.open(this.method.toUpperCase(), this.url,
+        this.options.asynchronous);
+
+      if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);
+
+      this.transport.onreadystatechange = this.onStateChange.bind(this);
+      this.setRequestHeaders();
+
+      this.body = this.method == 'post' ? (this.options.postBody || params) : null;
+      this.transport.send(this.body);
+
+      /* Force Firefox to handle ready state 4 for synchronous requests */
+      if (!this.options.asynchronous && this.transport.overrideMimeType)
+        this.onStateChange();
+
+    }
+    catch (e) {
+      this.dispatchException(e);
+    }
+  },
+
+  onStateChange: function() {
+    var readyState = this.transport.readyState;
+    if (readyState > 1 && !((readyState == 4) && this._complete))
+      this.respondToReadyState(this.transport.readyState);
+  },
+
+  setRequestHeaders: function() {
+    var headers = {
+      'X-Requested-With': 'XMLHttpRequest',
+      'X-Prototype-Version': Prototype.Version,
+      'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
+    };
+
+    if (this.method == 'post') {
+      headers['Content-type'] = this.options.contentType +
+        (this.options.encoding ? '; charset=' + this.options.encoding : '');
+
+      /* Force "Connection: close" for older Mozilla browsers to work
+       * around a bug where XMLHttpRequest sends an incorrect
+       * Content-length header. See Mozilla Bugzilla #246651.
+       */
+      if (this.transport.overrideMimeType &&
+          (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
+            headers['Connection'] = 'close';
+    }
+
+    // user-defined headers
+    if (typeof this.options.requestHeaders == 'object') {
+      var extras = this.options.requestHeaders;
+
+      if (Object.isFunction(extras.push))
+        for (var i = 0, length = extras.length; i < length; i += 2)
+          headers[extras[i]] = extras[i+1];
+      else
+        $H(extras).each(function(pair) { headers[pair.key] = pair.value });
+    }
+
+    for (var name in headers)
+      this.transport.setRequestHeader(name, headers[name]);
+  },
+
+  success: function() {
+    var status = this.getStatus();
+    return !status || (status >= 200 && status < 300);
+  },
+
+  getStatus: function() {
+    try {
+      return this.transport.status || 0;
+    } catch (e) { return 0 }
+  },
+
+  respondToReadyState: function(readyState) {
+    var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);
+
+    if (state == 'Complete') {
+      try {
+        this._complete = true;
+        (this.options['on' + response.status]
+         || this.options['on' + (this.success() ? 'Success' : 'Failure')]
+         || Prototype.emptyFunction)(response, response.headerJSON);
+      } catch (e) {
+        this.dispatchException(e);
+      }
+
+      var contentType = response.getHeader('Content-type');
+      if (this.options.evalJS == 'force'
+          || (this.options.evalJS && this.isSameOrigin() && contentType
+          && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
+        this.evalResponse();
+    }
+
+    try {
+      (this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
+      Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
+    } catch (e) {
+      this.dispatchException(e);
+    }
+
+    if (state == 'Complete') {
+      // avoid memory leak in MSIE: clean up
+      this.transport.onreadystatechange = Prototype.emptyFunction;
+    }
+  },
+
+  isSameOrigin: function() {
+    var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
+    return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
+      protocol: location.protocol,
+      domain: document.domain,
+      port: location.port ? ':' + location.port : ''
+    }));
+  },
+
+  getHeader: function(name) {
+    try {
+      return this.transport.getResponseHeader(name) || null;
+    } catch (e) { return null }
+  },
+
+  evalResponse: function() {
+    try {
+      return eval((this.transport.responseText || '').unfilterJSON());
+    } catch (e) {
+      this.dispatchException(e);
+    }
+  },
+
+  dispatchException: function(exception) {
+    (this.options.onException || Prototype.emptyFunction)(this, exception);
+    Ajax.Responders.dispatch('onException', this, exception);
+  }
+});
+
+Ajax.Request.Events =
+  ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];
+
+Ajax.Response = Class.create({
+  initialize: function(request){
+    this.request = request;
+    var transport  = this.transport  = request.transport,
+        readyState = this.readyState = transport.readyState;
+
+    if((readyState > 2 && !Prototype.Browser.IE) || readyState == 4) {
+      this.status       = this.getStatus();
+      this.statusText   = this.getStatusText();
+      this.responseText = String.interpret(transport.responseText);
+      this.headerJSON   = this._getHeaderJSON();
+    }
+
+    if(readyState == 4) {
+      var xml = transport.responseXML;
+      this.responseXML  = Object.isUndefined(xml) ? null : xml;
+      this.responseJSON = this._getResponseJSON();
+    }
+  },
+
+  status:      0,
+  statusText: '',
+
+  getStatus: Ajax.Request.prototype.getStatus,
+
+  getStatusText: function() {
+    try {
+      return this.transport.statusText || '';
+    } catch (e) { return '' }
+  },
+
+  getHeader: Ajax.Request.prototype.getHeader,
+
+  getAllHeaders: function() {
+    try {
+      return this.getAllResponseHeaders();
+    } catch (e) { return null }
+  },
+
+  getResponseHeader: function(name) {
+    return this.transport.getResponseHeader(name);
+  },
+
+  getAllResponseHeaders: function() {
+    return this.transport.getAllResponseHeaders();
+  },
+
+  _getHeaderJSON: function() {
+    var json = this.getHeader('X-JSON');
+    if (!json) return null;
+    json = decodeURIComponent(escape(json));
+    try {
+      return json.evalJSON(this.request.options.sanitizeJSON ||
+        !this.request.isSameOrigin());
+    } catch (e) {
+      this.request.dispatchException(e);
+    }
+  },
+
+  _getResponseJSON: function() {
+    var options = this.request.options;
+    if (!options.evalJSON || (options.evalJSON != 'force' &&
+      !(this.getHeader('Content-type') || '').include('application/json')) ||
+        this.responseText.blank())
+          return null;
+    try {
+      return this.responseText.evalJSON(options.sanitizeJSON ||
+        !this.request.isSameOrigin());
+    } catch (e) {
+      this.request.dispatchException(e);
+    }
+  }
+});
+
+Ajax.Updater = Class.create(Ajax.Request, {
+  initialize: function($super, container, url, options) {
+    this.container = {
+      success: (container.success || container),
+      failure: (container.failure || (container.success ? null : container))
+    };
+
+    options = Object.clone(options);
+    var onComplete = options.onComplete;
+    options.onComplete = (function(response, json) {
+      this.updateContent(response.responseText);
+      if (Object.isFunction(onComplete)) onComplete(response, json);
+    }).bind(this);
+
+    $super(url, options);
+  },
+
+  updateContent: function(responseText) {
+    var receiver = this.container[this.success() ? 'success' : 'failure'],
+        options = this.options;
+
+    if (!options.evalScripts) responseText = responseText.stripScripts();
+
+    if (receiver = $(receiver)) {
+      if (options.insertion) {
+        if (Object.isString(options.insertion)) {
+          var insertion = { }; insertion[options.insertion] = responseText;
+          receiver.insert(insertion);
+        }
+        else options.insertion(receiver, responseText);
+      }
+      else receiver.update(responseText);
+    }
+  }
+});
+
+Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
+  initialize: function($super, container, url, options) {
+    $super(options);
+    this.onComplete = this.options.onComplete;
+
+    this.frequency = (this.options.frequency || 2);
+    this.decay = (this.options.decay || 1);
+
+    this.updater = { };
+    this.container = container;
+    this.url = url;
+
+    this.start();
+  },
+
+  start: function() {
+    this.options.onComplete = this.updateComplete.bind(this);
+    this.onTimerEvent();
+  },
+
+  stop: function() {
+    this.updater.options.onComplete = undefined;
+    clearTimeout(this.timer);
+    (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
+  },
+
+  updateComplete: function(response) {
+    if (this.options.decay) {
+      this.decay = (response.responseText == this.lastText ?
+        this.decay * this.options.decay : 1);
+
+      this.lastText = response.responseText;
+    }
+    this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
+  },
+
+  onTimerEvent: function() {
+    this.updater = new Ajax.Updater(this.container, this.url, this.options);
+  }
+});
+function $(element) {
+  if (arguments.length > 1) {
+    for (var i = 0, elements = [], length = arguments.length; i < length; i++)
+      elements.push($(arguments[i]));
+    return elements;
+  }
+  if (Object.isString(element))
+    element = document.getElementById(element);
+  return Element.extend(element);
+}
+
+if (Prototype.BrowserFeatures.XPath) {
+  document._getElementsByXPath = function(expression, parentElement) {
+    var results = [];
+    var query = document.evaluate(expression, $(parentElement) || document,
+      null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
+    for (var i = 0, length = query.snapshotLength; i < length; i++)
+      results.push(Element.extend(query.snapshotItem(i)));
+    return results;
+  };
+}
+
+/*--------------------------------------------------------------------------*/
+
+if (!window.Node) var Node = { };
+
+if (!Node.ELEMENT_NODE) {
+  // DOM level 2 ECMAScript Language Binding
+  Object.extend(Node, {
+    ELEMENT_NODE: 1,
+    ATTRIBUTE_NODE: 2,
+    TEXT_NODE: 3,
+    CDATA_SECTION_NODE: 4,
+    ENTITY_REFERENCE_NODE: 5,
+    ENTITY_NODE: 6,
+    PROCESSING_INSTRUCTION_NODE: 7,
+    COMMENT_NODE: 8,
+    DOCUMENT_NODE: 9,
+    DOCUMENT_TYPE_NODE: 10,
+    DOCUMENT_FRAGMENT_NODE: 11,
+    NOTATION_NODE: 12
+  });
+}
+
+(function() {
+  var element = this.Element;
+  this.Element = function(tagName, attributes) {
+    attributes = attributes || { };
+    tagName = tagName.toLowerCase();
+    var cache = Element.cache;
+    if (Prototype.Browser.IE && attributes.name) {
+      tagName = '<' + tagName + ' name="' + attributes.name + '">';
+      delete attributes.name;
+      return Element.writeAttribute(document.createElement(tagName), attributes);
+    }
+    if (!cache[tagName]) cache[tagName] = Element.extend(document.createElement(tagName));
+    return Element.writeAttribute(cache[tagName].cloneNode(false), attributes);
+  };
+  Object.extend(this.Element, element || { });
+}).call(window);
+
+Element.cache = { };
+
+Element.Methods = {
+  visible: function(element) {
+    return $(element).style.display != 'none';
+  },
+
+  toggle: function(element) {
+    element = $(element);
+    Element[Element.visible(element) ? 'hide' : 'show'](element);
+    return element;
+  },
+
+  hide: function(element) {
+    $(element).style.display = 'none';
+    return element;
+  },
+
+  show: function(element) {
+    $(element).style.display = '';
+    return element;
+  },
+
+  remove: function(element) {
+    element = $(element);
+    element.parentNode.removeChild(element);
+    return element;
+  },
+
+  update: function(element, content) {
+    element = $(element);
+    if (content && content.toElement) content = content.toElement();
+    if (Object.isElement(content)) return element.update().insert(content);
+    content = Object.toHTML(content);
+    element.innerHTML = content.stripScripts();
+    content.evalScripts.bind(content).defer();
+    return element;
+  },
+
+  replace: function(element, content) {
+    element = $(element);
+    if (content && content.toElement) content = content.toElement();
+    else if (!Object.isElement(content)) {
+      content = Object.toHTML(content);
+      var range = element.ownerDocument.createRange();
+      range.selectNode(element);
+      content.evalScripts.bind(content).defer();
+      content = range.createContextualFragment(content.stripScripts());
+    }
+    element.parentNode.replaceChild(content, element);
+    return element;
+  },
+
+  insert: function(element, insertions) {
+    element = $(element);
+
+    if (Object.isString(insertions) || Object.isNumber(insertions) ||
+        Object.isElement(insertions) || (insertions && (insertions.toElement || insertions.toHTML)))
+          insertions = {bottom:insertions};
+
+    var content, insert, tagName, childNodes;
+
+    for (var position in insertions) {
+      content  = insertions[position];
+      position = position.toLowerCase();
+      insert = Element._insertionTranslations[position];
+
+      if (content && content.toElement) content = content.toElement();
+      if (Object.isElement(content)) {
+        insert(element, content);
+        continue;
+      }
+
+      content = Object.toHTML(content);
+
+      tagName = ((position == 'before' || position == 'after')
+        ? element.parentNode : element).tagName.toUpperCase();
+
+      childNodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
+
+      if (position == 'top' || position == 'after') childNodes.reverse();
+      childNodes.each(insert.curry(element));
+
+      content.evalScripts.bind(content).defer();
+    }
+
+    return element;
+  },
+
+  wrap: function(element, wrapper, attributes) {
+    element = $(element);
+    if (Object.isElement(wrapper))
+      $(wrapper).writeAttribute(attributes || { });
+    else if (Object.isString(wrapper)) wrapper = new Element(wrapper, attributes);
+    else wrapper = new Element('div', wrapper);
+    if (element.parentNode)
+      element.parentNode.replaceChild(wrapper, element);
+    wrapper.appendChild(element);
+    return wrapper;
+  },
+
+  inspect: function(element) {
+    element = $(element);
+    var result = '<' + element.tagName.toLowerCase();
+    $H({'id': 'id', 'className': 'class'}).each(function(pair) {
+      var property = pair.first(), attribute = pair.last();
+      var value = (element[property] || '').toString();
+      if (value) result += ' ' + attribute + '=' + value.inspect(true);
+    });
+    return result + '>';
+  },
+
+  recursivelyCollect: function(element, property) {
+    element = $(element);
+    var elements = [];
+    while (element = element[property])
+      if (element.nodeType == 1)
+        elements.push(Element.extend(element));
+    return elements;
+  },
+
+  ancestors: function(element) {
+    return $(element).recursivelyCollect('parentNode');
+  },
+
+  descendants: function(element) {
+    return $(element).select("*");
+  },
+
+  firstDescendant: function(element) {
+    element = $(element).firstChild;
+    while (element && element.nodeType != 1) element = element.nextSibling;
+    return $(element);
+  },
+
+  immediateDescendants: function(element) {
+    if (!(element = $(element).firstChild)) return [];
+    while (element && element.nodeType != 1) element = element.nextSibling;
+    if (element) return [element].concat($(element).nextSiblings());
+    return [];
+  },
+
+  previousSiblings: function(element) {
+    return $(element).recursivelyCollect('previousSibling');
+  },
+
+  nextSiblings: function(element) {
+    return $(element).recursivelyCollect('nextSibling');
+  },
+
+  siblings: function(element) {
+    element = $(element);
+    return element.previousSiblings().reverse().concat(element.nextSiblings());
+  },
+
+  match: function(element, selector) {
+    if (Object.isString(selector))
+      selector = new Selector(selector);
+    return selector.match($(element));
+  },
+
+  up: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return $(element.parentNode);
+    var ancestors = element.ancestors();
+    return Object.isNumber(expression) ? ancestors[expression] :
+      Selector.findElement(ancestors, expression, index);
+  },
+
+  down: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return element.firstDescendant();
+    return Object.isNumber(expression) ? element.descendants()[expression] :
+      element.select(expression)[index || 0];
+  },
+
+  previous: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return $(Selector.handlers.previousElementSibling(element));
+    var previousSiblings = element.previousSiblings();
+    return Object.isNumber(expression) ? previousSiblings[expression] :
+      Selector.findElement(previousSiblings, expression, index);
+  },
+
+  next: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return $(Selector.handlers.nextElementSibling(element));
+    var nextSiblings = element.nextSiblings();
+    return Object.isNumber(expression) ? nextSiblings[expression] :
+      Selector.findElement(nextSiblings, expression, index);
+  },
+
+  select: function() {
+    var args = $A(arguments), element = $(args.shift());
+    return Selector.findChildElements(element, args);
+  },
+
+  adjacent: function() {
+    var args = $A(arguments), element = $(args.shift());
+    return Selector.findChildElements(element.parentNode, args).without(element);
+  },
+
+  identify: function(element) {
+    element = $(element);
+    var id = element.readAttribute('id'), self = arguments.callee;
+    if (id) return id;
+    do { id = 'anonymous_element_' + self.counter++ } while ($(id));
+    element.writeAttribute('id', id);
+    return id;
+  },
+
+  readAttribute: function(element, name) {
+    element = $(element);
+    if (Prototype.Browser.IE) {
+      var t = Element._attributeTranslations.read;
+      if (t.values[name]) return t.values[name](element, name);
+      if (t.names[name]) name = t.names[name];
+      if (name.include(':')) {
+        return (!element.attributes || !element.attributes[name]) ? null :
+         element.attributes[name].value;
+      }
+    }
+    return element.getAttribute(name);
+  },
+
+  writeAttribute: function(element, name, value) {
+    element = $(element);
+    var attributes = { }, t = Element._attributeTranslations.write;
+
+    if (typeof name == 'object') attributes = name;
+    else attributes[name] = Object.isUndefined(value) ? true : value;
+
+    for (var attr in attributes) {
+      name = t.names[attr] || attr;
+      value = attributes[attr];
+      if (t.values[attr]) name = t.values[attr](element, value);
+      if (value === false || value === null)
+        element.removeAttribute(name);
+      else if (value === true)
+        element.setAttribute(name, name);
+      else element.setAttribute(name, value);
+    }
+    return element;
+  },
+
+  getHeight: function(element) {
+    return $(element).getDimensions().height;
+  },
+
+  getWidth: function(element) {
+    return $(element).getDimensions().width;
+  },
+
+  classNames: function(element) {
+    return new Element.ClassNames(element);
+  },
+
+  hasClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    var elementClassName = element.className;
+    return (elementClassName.length > 0 && (elementClassName == className ||
+      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
+  },
+
+  addClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    if (!element.hasClassName(className))
+      element.className += (element.className ? ' ' : '') + className;
+    return element;
+  },
+
+  removeClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    element.className = element.className.replace(
+      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
+    return element;
+  },
+
+  toggleClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    return element[element.hasClassName(className) ?
+      'removeClassName' : 'addClassName'](className);
+  },
+
+  // removes whitespace-only text node children
+  cleanWhitespace: function(element) {
+    element = $(element);
+    var node = element.firstChild;
+    while (node) {
+      var nextNode = node.nextSibling;
+      if (node.nodeType == 3 && !/\S/.test(node.nodeValue))
+        element.removeChild(node);
+      node = nextNode;
+    }
+    return element;
+  },
+
+  empty: function(element) {
+    return $(element).innerHTML.blank();
+  },
+
+  descendantOf: function(element, ancestor) {
+    element = $(element), ancestor = $(ancestor);
+    var originalAncestor = ancestor;
+
+    if (element.compareDocumentPosition)
+      return (element.compareDocumentPosition(ancestor) & 8) === 8;
+
+    if (element.sourceIndex && !Prototype.Browser.Opera) {
+      var e = element.sourceIndex, a = ancestor.sourceIndex,
+       nextAncestor = ancestor.nextSibling;
+      if (!nextAncestor) {
+        do { ancestor = ancestor.parentNode; }
+        while (!(nextAncestor = ancestor.nextSibling) && ancestor.parentNode);
+      }
+      if (nextAncestor && nextAncestor.sourceIndex)
+       return (e > a && e < nextAncestor.sourceIndex);
+    }
+
+    while (element = element.parentNode)
+      if (element == originalAncestor) return true;
+    return false;
+  },
+
+  scrollTo: function(element) {
+    element = $(element);
+    var pos = element.cumulativeOffset();
+    window.scrollTo(pos[0], pos[1]);
+    return element;
+  },
+
+  getStyle: function(element, style) {
+    element = $(element);
+    style = style == 'float' ? 'cssFloat' : style.camelize();
+    var value = element.style[style];
+    if (!value) {
+      var css = document.defaultView.getComputedStyle(element, null);
+      value = css ? css[style] : null;
+    }
+    if (style == 'opacity') return value ? parseFloat(value) : 1.0;
+    return value == 'auto' ? null : value;
+  },
+
+  getOpacity: function(element) {
+    return $(element).getStyle('opacity');
+  },
+
+  setStyle: function(element, styles) {
+    element = $(element);
+    var elementStyle = element.style, match;
+    if (Object.isString(styles)) {
+      element.style.cssText += ';' + styles;
+      return styles.include('opacity') ?
+        element.setOpacity(styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
+    }
+    for (var property in styles)
+      if (property == 'opacity') element.setOpacity(styles[property]);
+      else
+        elementStyle[(property == 'float' || property == 'cssFloat') ?
+          (Object.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
+            property] = styles[property];
+
+    return element;
+  },
+
+  setOpacity: function(element, value) {
+    element = $(element);
+    element.style.opacity = (value == 1 || value === '') ? '' :
+      (value < 0.00001) ? 0 : value;
+    return element;
+  },
+
+  getDimensions: function(element) {
+    element = $(element);
+    var display = $(element).getStyle('display');
+    if (display != 'none' && display != null) // Safari bug
+      return {width: element.offsetWidth, height: element.offsetHeight};
+
+    // All *Width and *Height properties give 0 on elements with display none,
+    // so enable the element temporarily
+    var els = element.style;
+    var originalVisibility = els.visibility;
+    var originalPosition = els.position;
+    var originalDisplay = els.display;
+    els.visibility = 'hidden';
+    els.position = 'absolute';
+    els.display = 'block';
+    var originalWidth = element.clientWidth;
+    var originalHeight = element.clientHeight;
+    els.display = originalDisplay;
+    els.position = originalPosition;
+    els.visibility = originalVisibility;
+    return {width: originalWidth, height: originalHeight};
+  },
+
+  makePositioned: function(element) {
+    element = $(element);
+    var pos = Element.getStyle(element, 'position');
+    if (pos == 'static' || !pos) {
+      element._madePositioned = true;
+      element.style.position = 'relative';
+      // Opera returns the offset relative to the positioning context, when an
+      // element is position relative but top and left have not been defined
+      if (window.opera) {
+        element.style.top = 0;
+        element.style.left = 0;
+      }
+    }
+    return element;
+  },
+
+  undoPositioned: function(element) {
+    element = $(element);
+    if (element._madePositioned) {
+      element._madePositioned = undefined;
+      element.style.position =
+        element.style.top =
+        element.style.left =
+        element.style.bottom =
+        element.style.right = '';
+    }
+    return element;
+  },
+
+  makeClipping: function(element) {
+    element = $(element);
+    if (element._overflow) return element;
+    element._overflow = Element.getStyle(element, 'overflow') || 'auto';
+    if (element._overflow !== 'hidden')
+      element.style.overflow = 'hidden';
+    return element;
+  },
+
+  undoClipping: function(element) {
+    element = $(element);
+    if (!element._overflow) return element;
+    element.style.overflow = element._overflow == 'auto' ? '' : element._overflow;
+    element._overflow = null;
+    return element;
+  },
+
+  cumulativeOffset: function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+      element = element.offsetParent;
+    } while (element);
+    return Element._returnOffset(valueL, valueT);
+  },
+
+  positionedOffset: function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+      element = element.offsetParent;
+      if (element) {
+        if (element.tagName == 'BODY') break;
+        var p = Element.getStyle(element, 'position');
+        if (p !== 'static') break;
+      }
+    } while (element);
+    return Element._returnOffset(valueL, valueT);
+  },
+
+  absolutize: function(element) {
+    element = $(element);
+    if (element.getStyle('position') == 'absolute') return;
+    // Position.prepare(); // To be done manually by Scripty when it needs it.
+
+    var offsets = element.positionedOffset();
+    var top     = offsets[1];
+    var left    = offsets[0];
+    var width   = element.clientWidth;
+    var height  = element.clientHeight;
+
+    element._originalLeft   = left - parseFloat(element.style.left  || 0);
+    element._originalTop    = top  - parseFloat(element.style.top || 0);
+    element._originalWidth  = element.style.width;
+    element._originalHeight = element.style.height;
+
+    element.style.position = 'absolute';
+    element.style.top    = top + 'px';
+    element.style.left   = left + 'px';
+    element.style.width  = width + 'px';
+    element.style.height = height + 'px';
+    return element;
+  },
+
+  relativize: function(element) {
+    element = $(element);
+    if (element.getStyle('position') == 'relative') return;
+    // Position.prepare(); // To be done manually by Scripty when it needs it.
+
+    element.style.position = 'relative';
+    var top  = parseFloat(element.style.top  || 0) - (element._originalTop || 0);
+    var left = parseFloat(element.style.left || 0) - (element._originalLeft || 0);
+
+    element.style.top    = top + 'px';
+    element.style.left   = left + 'px';
+    element.style.height = element._originalHeight;
+    element.style.width  = element._originalWidth;
+    return element;
+  },
+
+  cumulativeScrollOffset: function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.scrollTop  || 0;
+      valueL += element.scrollLeft || 0;
+      element = element.parentNode;
+    } while (element);
+    return Element._returnOffset(valueL, valueT);
+  },
+
+  getOffsetParent: function(element) {
+    if (element.offsetParent) return $(element.offsetParent);
+    if (element == document.body) return $(element);
+
+    while ((element = element.parentNode) && element != document.body)
+      if (Element.getStyle(element, 'position') != 'static')
+        return $(element);
+
+    return $(document.body);
+  },
+
+  viewportOffset: function(forElement) {
+    var valueT = 0, valueL = 0;
+
+    var element = forElement;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+
+      // Safari fix
+      if (element.offsetParent == document.body &&
+        Element.getStyle(element, 'position') == 'absolute') break;
+
+    } while (element = element.offsetParent);
+
+    element = forElement;
+    do {
+      if (!Prototype.Browser.Opera || element.tagName == 'BODY') {
+        valueT -= element.scrollTop  || 0;
+        valueL -= element.scrollLeft || 0;
+      }
+    } while (element = element.parentNode);
+
+    return Element._returnOffset(valueL, valueT);
+  },
+
+  clonePosition: function(element, source) {
+    var options = Object.extend({
+      setLeft:    true,
+      setTop:     true,
+      setWidth:   true,
+      setHeight:  true,
+      offsetTop:  0,
+      offsetLeft: 0
+    }, arguments[2] || { });
+
+    // find page position of source
+    source = $(source);
+    var p = source.viewportOffset();
+
+    // find coordinate system to use
+    element = $(element);
+    var delta = [0, 0];
+    var parent = null;
+    // delta [0,0] will do fine with position: fixed elements,
+    // position:absolute needs offsetParent deltas
+    if (Element.getStyle(element, 'position') == 'absolute') {
+      parent = element.getOffsetParent();
+      delta = parent.viewportOffset();
+    }
+
+    // correct by body offsets (fixes Safari)
+    if (parent == document.body) {
+      delta[0] -= document.body.offsetLeft;
+      delta[1] -= document.body.offsetTop;
+    }
+
+    // set position
+    if (options.setLeft)   element.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
+    if (options.setTop)    element.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
+    if (options.setWidth)  element.style.width = source.offsetWidth + 'px';
+    if (options.setHeight) element.style.height = source.offsetHeight + 'px';
+    return element;
+  }
+};
+
+Element.Methods.identify.counter = 1;
+
+Object.extend(Element.Methods, {
+  getElementsBySelector: Element.Methods.select,
+  childElements: Element.Methods.immediateDescendants
+});
+
+Element._attributeTranslations = {
+  write: {
+    names: {
+      className: 'class',
+      htmlFor:   'for'
+    },
+    values: { }
+  }
+};
+
+if (Prototype.Browser.Opera) {
+  Element.Methods.getStyle = Element.Methods.getStyle.wrap(
+    function(proceed, element, style) {
+      switch (style) {
+        case 'left': case 'top': case 'right': case 'bottom':
+          if (proceed(element, 'position') === 'static') return null;
+        case 'height': case 'width':
+          // returns '0px' for hidden elements; we want it to return null
+          if (!Element.visible(element)) return null;
+
+          // returns the border-box dimensions rather than the content-box
+          // dimensions, so we subtract padding and borders from the value
+          var dim = parseInt(proceed(element, style), 10);
+
+          if (dim !== element['offset' + style.capitalize()])
+            return dim + 'px';
+
+          var properties;
+          if (style === 'height') {
+            properties = ['border-top-width', 'padding-top',
+             'padding-bottom', 'border-bottom-width'];
+          }
+          else {
+            properties = ['border-left-width', 'padding-left',
+             'padding-right', 'border-right-width'];
+          }
+          return properties.inject(dim, function(memo, property) {
+            var val = proceed(element, property);
+            return val === null ? memo : memo - parseInt(val, 10);
+          }) + 'px';
+        default: return proceed(element, style);
+      }
+    }
+  );
+
+  Element.Methods.readAttribute = Element.Methods.readAttribute.wrap(
+    function(proceed, element, attribute) {
+      if (attribute === 'title') return element.title;
+      return proceed(element, attribute);
+    }
+  );
+}
+
+else if (Prototype.Browser.IE) {
+  // IE doesn't report offsets correctly for static elements, so we change them
+  // to "relative" to get the values, then change them back.
+  Element.Methods.getOffsetParent = Element.Methods.getOffsetParent.wrap(
+    function(proceed, element) {
+      element = $(element);
+      var position = element.getStyle('position');
+      if (position !== 'static') return proceed(element);
+      element.setStyle({ position: 'relative' });
+      var value = proceed(element);
+      element.setStyle({ position: position });
+      return value;
+    }
+  );
+
+  $w('positionedOffset viewportOffset').each(function(method) {
+    Element.Methods[method] = Element.Methods[method].wrap(
+      function(proceed, element) {
+        element = $(element);
+        var position = element.getStyle('position');
+        if (position !== 'static') return proceed(element);
+        // Trigger hasLayout on the offset parent so that IE6 reports
+        // accurate offsetTop and offsetLeft values for position: fixed.
+        var offsetParent = element.getOffsetParent();
+        if (offsetParent && offsetParent.getStyle('position') === 'fixed')
+          offsetParent.setStyle({ zoom: 1 });
+        element.setStyle({ position: 'relative' });
+        var value = proceed(element);
+        element.setStyle({ position: position });
+        return value;
+      }
+    );
+  });
+
+  Element.Methods.getStyle = function(element, style) {
+    element = $(element);
+    style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
+    var value = element.style[style];
+    if (!value && element.currentStyle) value = element.currentStyle[style];
+
+    if (style == 'opacity') {
+      if (value = (element.getStyle('filter') || '').match(/alpha\(opacity=(.*)\)/))
+        if (value[1]) return parseFloat(value[1]) / 100;
+      return 1.0;
+    }
+
+    if (value == 'auto') {
+      if ((style == 'width' || style == 'height') && (element.getStyle('display') != 'none'))
+        return element['offset' + style.capitalize()] + 'px';
+      return null;
+    }
+    return value;
+  };
+
+  Element.Methods.setOpacity = function(element, value) {
+    function stripAlpha(filter){
+      return filter.replace(/alpha\([^\)]*\)/gi,'');
+    }
+    element = $(element);
+    var currentStyle = element.currentStyle;
+    if ((currentStyle && !currentStyle.hasLayout) ||
+      (!currentStyle && element.style.zoom == 'normal'))
+        element.style.zoom = 1;
+
+    var filter = element.getStyle('filter'), style = element.style;
+    if (value == 1 || value === '') {
+      (filter = stripAlpha(filter)) ?
+        style.filter = filter : style.removeAttribute('filter');
+      return element;
+    } else if (value < 0.00001) value = 0;
+    style.filter = stripAlpha(filter) +
+      'alpha(opacity=' + (value * 100) + ')';
+    return element;
+  };
+
+  Element._attributeTranslations = {
+    read: {
+      names: {
+        'class': 'className',
+        'for':   'htmlFor'
+      },
+      values: {
+        _getAttr: function(element, attribute) {
+          return element.getAttribute(attribute, 2);
+        },
+        _getAttrNode: function(element, attribute) {
+          var node = element.getAttributeNode(attribute);
+          return node ? node.value : "";
+        },
+        _getEv: function(element, attribute) {
+          attribute = element.getAttribute(attribute);
+          return attribute ? attribute.toString().slice(23, -2) : null;
+        },
+        _flag: function(element, attribute) {
+          return $(element).hasAttribute(attribute) ? attribute : null;
+        },
+        style: function(element) {
+          return element.style.cssText.toLowerCase();
+        },
+        title: function(element) {
+          return element.title;
+        }
+      }
+    }
+  };
+
+  Element._attributeTranslations.write = {
+    names: Object.extend({
+      cellpadding: 'cellPadding',
+      cellspacing: 'cellSpacing'
+    }, Element._attributeTranslations.read.names),
+    values: {
+      checked: function(element, value) {
+        element.checked = !!value;
+      },
+
+      style: function(element, value) {
+        element.style.cssText = value ? value : '';
+      }
+    }
+  };
+
+  Element._attributeTranslations.has = {};
+
+  $w('colSpan rowSpan vAlign dateTime accessKey tabIndex ' +
+      'encType maxLength readOnly longDesc').each(function(attr) {
+    Element._attributeTranslations.write.names[attr.toLowerCase()] = attr;
+    Element._attributeTranslations.has[attr.toLowerCase()] = attr;
+  });
+
+  (function(v) {
+    Object.extend(v, {
+      href:        v._getAttr,
+      src:         v._getAttr,
+      type:        v._getAttr,
+      action:      v._getAttrNode,
+      disabled:    v._flag,
+      checked:     v._flag,
+      readonly:    v._flag,
+      multiple:    v._flag,
+      onload:      v._getEv,
+      onunload:    v._getEv,
+      onclick:     v._getEv,
+      ondblclick:  v._getEv,
+      onmousedown: v._getEv,
+      onmouseup:   v._getEv,
+      onmouseover: v._getEv,
+      onmousemove: v._getEv,
+      onmouseout:  v._getEv,
+      onfocus:     v._getEv,
+      onblur:      v._getEv,
+      onkeypress:  v._getEv,
+      onkeydown:   v._getEv,
+      onkeyup:     v._getEv,
+      onsubmit:    v._getEv,
+      onreset:     v._getEv,
+      onselect:    v._getEv,
+      onchange:    v._getEv
+    });
+  })(Element._attributeTranslations.read.values);
+}
+
+else if (Prototype.Browser.Gecko && /rv:1\.8\.0/.test(navigator.userAgent)) {
+  Element.Methods.setOpacity = function(element, value) {
+    element = $(element);
+    element.style.opacity = (value == 1) ? 0.999999 :
+      (value === '') ? '' : (value < 0.00001) ? 0 : value;
+    return element;
+  };
+}
+
+else if (Prototype.Browser.WebKit) {
+  Element.Methods.setOpacity = function(element, value) {
+    element = $(element);
+    element.style.opacity = (value == 1 || value === '') ? '' :
+      (value < 0.00001) ? 0 : value;
+
+    if (value == 1)
+      if(element.tagName == 'IMG' && element.width) {
+        element.width++; element.width--;
+      } else try {
+        var n = document.createTextNode(' ');
+        element.appendChild(n);
+        element.removeChild(n);
+      } catch (e) { }
+
+    return element;
+  };
+
+  // Safari returns margins on body which is incorrect if the child is absolutely
+  // positioned.  For performance reasons, redefine Element#cumulativeOffset for
+  // KHTML/WebKit only.
+  Element.Methods.cumulativeOffset = function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+      if (element.offsetParent == document.body)
+        if (Element.getStyle(element, 'position') == 'absolute') break;
+
+      element = element.offsetParent;
+    } while (element);
+
+    return Element._returnOffset(valueL, valueT);
+  };
+}
+
+if (Prototype.Browser.IE || Prototype.Browser.Opera) {
+  // IE and Opera are missing .innerHTML support for TABLE-related and SELECT elements
+  Element.Methods.update = function(element, content) {
+    element = $(element);
+
+    if (content && content.toElement) content = content.toElement();
+    if (Object.isElement(content)) return element.update().insert(content);
+
+    content = Object.toHTML(content);
+    var tagName = element.tagName.toUpperCase();
+
+    if (tagName in Element._insertionTranslations.tags) {
+      $A(element.childNodes).each(function(node) { element.removeChild(node) });
+      Element._getContentFromAnonymousElement(tagName, content.stripScripts())
+        .each(function(node) { element.appendChild(node) });
+    }
+    else element.innerHTML = content.stripScripts();
+
+    content.evalScripts.bind(content).defer();
+    return element;
+  };
+}
+
+if ('outerHTML' in document.createElement('div')) {
+  Element.Methods.replace = function(element, content) {
+    element = $(element);
+
+    if (content && content.toElement) content = content.toElement();
+    if (Object.isElement(content)) {
+      element.parentNode.replaceChild(content, element);
+      return element;
+    }
+
+    content = Object.toHTML(content);
+    var parent = element.parentNode, tagName = parent.tagName.toUpperCase();
+
+    if (Element._insertionTranslations.tags[tagName]) {
+      var nextSibling = element.next();
+      var fragments = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
+      parent.removeChild(element);
+      if (nextSibling)
+        fragments.each(function(node) { parent.insertBefore(node, nextSibling) });
+      else
+        fragments.each(function(node) { parent.appendChild(node) });
+    }
+    else element.outerHTML = content.stripScripts();
+
+    content.evalScripts.bind(content).defer();
+    return element;
+  };
+}
+
+Element._returnOffset = function(l, t) {
+  var result = [l, t];
+  result.left = l;
+  result.top = t;
+  return result;
+};
+
+Element._getContentFromAnonymousElement = function(tagName, html) {
+  var div = new Element('div'), t = Element._insertionTranslations.tags[tagName];
+  if (t) {
+    div.innerHTML = t[0] + html + t[1];
+    t[2].times(function() { div = div.firstChild });
+  } else div.innerHTML = html;
+  return $A(div.childNodes);
+};
+
+Element._insertionTranslations = {
+  before: function(element, node) {
+    element.parentNode.insertBefore(node, element);
+  },
+  top: function(element, node) {
+    element.insertBefore(node, element.firstChild);
+  },
+  bottom: function(element, node) {
+    element.appendChild(node);
+  },
+  after: function(element, node) {
+    element.parentNode.insertBefore(node, element.nextSibling);
+  },
+  tags: {
+    TABLE:  ['<table>',                '</table>',                   1],
+    TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
+    TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
+    TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
+    SELECT: ['<select>',               '</select>',                  1]
+  }
+};
+
+(function() {
+  Object.extend(this.tags, {
+    THEAD: this.tags.TBODY,
+    TFOOT: this.tags.TBODY,
+    TH:    this.tags.TD
+  });
+}).call(Element._insertionTranslations);
+
+Element.Methods.Simulated = {
+  hasAttribute: function(element, attribute) {
+    attribute = Element._attributeTranslations.has[attribute] || attribute;
+    var node = $(element).getAttributeNode(attribute);
+    return node && node.specified;
+  }
+};
+
+Element.Methods.ByTag = { };
+
+Object.extend(Element, Element.Methods);
+
+if (!Prototype.BrowserFeatures.ElementExtensions &&
+    document.createElement('div').__proto__) {
+  window.HTMLElement = { };
+  window.HTMLElement.prototype = document.createElement('div').__proto__;
+  Prototype.BrowserFeatures.ElementExtensions = true;
+}
+
+Element.extend = (function() {
+  if (Prototype.BrowserFeatures.SpecificElementExtensions)
+    return Prototype.K;
+
+  var Methods = { }, ByTag = Element.Methods.ByTag;
+
+  var extend = Object.extend(function(element) {
+    if (!element || element._extendedByPrototype ||
+        element.nodeType != 1 || element == window) return element;
+
+    var methods = Object.clone(Methods),
+      tagName = element.tagName, property, value;
+
+    // extend methods for specific tags
+    if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);
+
+    for (property in methods) {
+      value = methods[property];
+      if (Object.isFunction(value) && !(property in element))
+        element[property] = value.methodize();
+    }
+
+    element._extendedByPrototype = Prototype.emptyFunction;
+    return element;
+
+  }, {
+    refresh: function() {
+      // extend methods for all tags (Safari doesn't need this)
+      if (!Prototype.BrowserFeatures.ElementExtensions) {
+        Object.extend(Methods, Element.Methods);
+        Object.extend(Methods, Element.Methods.Simulated);
+      }
+    }
+  });
+
+  extend.refresh();
+  return extend;
+})();
+
+Element.hasAttribute = function(element, attribute) {
+  if (element.hasAttribute) return element.hasAttribute(attribute);
+  return Element.Methods.Simulated.hasAttribute(element, attribute);
+};
+
+Element.addMethods = function(methods) {
+  var F = Prototype.BrowserFeatures, T = Element.Methods.ByTag;
+
+  if (!methods) {
+    Object.extend(Form, Form.Methods);
+    Object.extend(Form.Element, Form.Element.Methods);
+    Object.extend(Element.Methods.ByTag, {
+      "FORM":     Object.clone(Form.Methods),
+      "INPUT":    Object.clone(Form.Element.Methods),
+      "SELECT":   Object.clone(Form.Element.Methods),
+      "TEXTAREA": Object.clone(Form.Element.Methods)
+    });
+  }
+
+  if (arguments.length == 2) {
+    var tagName = methods;
+    methods = arguments[1];
+  }
+
+  if (!tagName) Object.extend(Element.Methods, methods || { });
+  else {
+    if (Object.isArray(tagName)) tagName.each(extend);
+    else extend(tagName);
+  }
+
+  function extend(tagName) {
+    tagName = tagName.toUpperCase();
+    if (!Element.Methods.ByTag[tagName])
+      Element.Methods.ByTag[tagName] = { };
+    Object.extend(Element.Methods.ByTag[tagName], methods);
+  }
+
+  function copy(methods, destination, onlyIfAbsent) {
+    onlyIfAbsent = onlyIfAbsent || false;
+    for (var property in methods) {
+      var value = methods[property];
+      if (!Object.isFunction(value)) continue;
+      if (!onlyIfAbsent || !(property in destination))
+        destination[property] = value.methodize();
+    }
+  }
+
+  function findDOMClass(tagName) {
+    var klass;
+    var trans = {
+      "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
+      "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
+      "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
+      "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
+      "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
+      "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
+      "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
+      "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
+      "FrameSet", "IFRAME": "IFrame"
+    };
+    if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
+    if (window[klass]) return window[klass];
+    klass = 'HTML' + tagName + 'Element';
+    if (window[klass]) return window[klass];
+    klass = 'HTML' + tagName.capitalize() + 'Element';
+    if (window[klass]) return window[klass];
+
+    window[klass] = { };
+    window[klass].prototype = document.createElement(tagName).__proto__;
+    return window[klass];
+  }
+
+  if (F.ElementExtensions) {
+    copy(Element.Methods, HTMLElement.prototype);
+    copy(Element.Methods.Simulated, HTMLElement.prototype, true);
+  }
+
+  if (F.SpecificElementExtensions) {
+    for (var tag in Element.Methods.ByTag) {
+      var klass = findDOMClass(tag);
+      if (Object.isUndefined(klass)) continue;
+      copy(T[tag], klass.prototype);
+    }
+  }
+
+  Object.extend(Element, Element.Methods);
+  delete Element.ByTag;
+
+  if (Element.extend.refresh) Element.extend.refresh();
+  Element.cache = { };
+};
+
+document.viewport = {
+  getDimensions: function() {
+    var dimensions = { };
+    var B = Prototype.Browser;
+    $w('width height').each(function(d) {
+      var D = d.capitalize();
+      dimensions[d] = (B.WebKit && !document.evaluate) ? self['inner' + D] :
+        (B.Opera) ? document.body['client' + D] : document.documentElement['client' + D];
+    });
+    return dimensions;
+  },
+
+  getWidth: function() {
+    return this.getDimensions().width;
+  },
+
+  getHeight: function() {
+    return this.getDimensions().height;
+  },
+
+  getScrollOffsets: function() {
+    return Element._returnOffset(
+      window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
+      window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
+  }
+};
+/* Portions of the Selector class are derived from Jack Slocums DomQuery,
+ * part of YUI-Ext version 0.40, distributed under the terms of an MIT-style
+ * license.  Please see http://www.yui-ext.com/ for more information. */
+
+var Selector = Class.create({
+  initialize: function(expression) {
+    this.expression = expression.strip();
+    this.compileMatcher();
+  },
+
+  shouldUseXPath: function() {
+    if (!Prototype.BrowserFeatures.XPath) return false;
+
+    var e = this.expression;
+
+    // Safari 3 chokes on :*-of-type and :empty
+    if (Prototype.Browser.WebKit &&
+     (e.include("-of-type") || e.include(":empty")))
+      return false;
+
+    // XPath can't do namespaced attributes, nor can it read
+    // the "checked" property from DOM nodes
+    if ((/(\[[\w-]*?:|:checked)/).test(this.expression))
+      return false;
+
+    return true;
+  },
+
+  compileMatcher: function() {
+    if (this.shouldUseXPath())
+      return this.compileXPathMatcher();
+
+    var e = this.expression, ps = Selector.patterns, h = Selector.handlers,
+        c = Selector.criteria, le, p, m;
+
+    if (Selector._cache[e]) {
+      this.matcher = Selector._cache[e];
+      return;
+    }
+
+    this.matcher = ["this.matcher = function(root) {",
+                    "var r = root, h = Selector.handlers, c = false, n;"];
+
+    while (e && le != e && (/\S/).test(e)) {
+      le = e;
+      for (var i in ps) {
+        p = ps[i];
+        if (m = e.match(p)) {
+          this.matcher.push(Object.isFunction(c[i]) ? c[i](m) :
+    	      new Template(c[i]).evaluate(m));
+          e = e.replace(m[0], '');
+          break;
+        }
+      }
+    }
+
+    this.matcher.push("return h.unique(n);\n}");
+    eval(this.matcher.join('\n'));
+    Selector._cache[this.expression] = this.matcher;
+  },
+
+  compileXPathMatcher: function() {
+    var e = this.expression, ps = Selector.patterns,
+        x = Selector.xpath, le, m;
+
+    if (Selector._cache[e]) {
+      this.xpath = Selector._cache[e]; return;
+    }
+
+    this.matcher = ['.//*'];
+    while (e && le != e && (/\S/).test(e)) {
+      le = e;
+      for (var i in ps) {
+        if (m = e.match(ps[i])) {
+          this.matcher.push(Object.isFunction(x[i]) ? x[i](m) :
+            new Template(x[i]).evaluate(m));
+          e = e.replace(m[0], '');
+          break;
+        }
+      }
+    }
+
+    this.xpath = this.matcher.join('');
+    Selector._cache[this.expression] = this.xpath;
+  },
+
+  findElements: function(root) {
+    root = root || document;
+    if (this.xpath) return document._getElementsByXPath(this.xpath, root);
+    return this.matcher(root);
+  },
+
+  match: function(element) {
+    this.tokens = [];
+
+    var e = this.expression, ps = Selector.patterns, as = Selector.assertions;
+    var le, p, m;
+
+    while (e && le !== e && (/\S/).test(e)) {
+      le = e;
+      for (var i in ps) {
+        p = ps[i];
+        if (m = e.match(p)) {
+          // use the Selector.assertions methods unless the selector
+          // is too complex.
+          if (as[i]) {
+            this.tokens.push([i, Object.clone(m)]);
+            e = e.replace(m[0], '');
+          } else {
+            // reluctantly do a document-wide search
+            // and look for a match in the array
+            return this.findElements(document).include(element);
+          }
+        }
+      }
+    }
+
+    var match = true, name, matches;
+    for (var i = 0, token; token = this.tokens[i]; i++) {
+      name = token[0], matches = token[1];
+      if (!Selector.assertions[name](element, matches)) {
+        match = false; break;
+      }
+    }
+
+    return match;
+  },
+
+  toString: function() {
+    return this.expression;
+  },
+
+  inspect: function() {
+    return "#<Selector:" + this.expression.inspect() + ">";
+  }
+});
+
+Object.extend(Selector, {
+  _cache: { },
+
+  xpath: {
+    descendant:   "//*",
+    child:        "/*",
+    adjacent:     "/following-sibling::*[1]",
+    laterSibling: '/following-sibling::*',
+    tagName:      function(m) {
+      if (m[1] == '*') return '';
+      return "[local-name()='" + m[1].toLowerCase() +
+             "' or local-name()='" + m[1].toUpperCase() + "']";
+    },
+    className:    "[contains(concat(' ', @class, ' '), ' #{1} ')]",
+    id:           "[@id='#{1}']",
+    attrPresence: function(m) {
+      m[1] = m[1].toLowerCase();
+      return new Template("[@#{1}]").evaluate(m);
+    },
+    attr: function(m) {
+      m[1] = m[1].toLowerCase();
+      m[3] = m[5] || m[6];
+      return new Template(Selector.xpath.operators[m[2]]).evaluate(m);
+    },
+    pseudo: function(m) {
+      var h = Selector.xpath.pseudos[m[1]];
+      if (!h) return '';
+      if (Object.isFunction(h)) return h(m);
+      return new Template(Selector.xpath.pseudos[m[1]]).evaluate(m);
+    },
+    operators: {
+      '=':  "[@#{1}='#{3}']",
+      '!=': "[@#{1}!='#{3}']",
+      '^=': "[starts-with(@#{1}, '#{3}')]",
+      '$=': "[substring(@#{1}, (string-length(@#{1}) - string-length('#{3}') + 1))='#{3}']",
+      '*=': "[contains(@#{1}, '#{3}')]",
+      '~=': "[contains(concat(' ', @#{1}, ' '), ' #{3} ')]",
+      '|=': "[contains(concat('-', @#{1}, '-'), '-#{3}-')]"
+    },
+    pseudos: {
+      'first-child': '[not(preceding-sibling::*)]',
+      'last-child':  '[not(following-sibling::*)]',
+      'only-child':  '[not(preceding-sibling::* or following-sibling::*)]',
+      'empty':       "[count(*) = 0 and (count(text()) = 0 or translate(text(), ' \t\r\n', '') = '')]",
+      'checked':     "[@checked]",
+      'disabled':    "[@disabled]",
+      'enabled':     "[not(@disabled)]",
+      'not': function(m) {
+        var e = m[6], p = Selector.patterns,
+            x = Selector.xpath, le, v;
+
+        var exclusion = [];
+        while (e && le != e && (/\S/).test(e)) {
+          le = e;
+          for (var i in p) {
+            if (m = e.match(p[i])) {
+              v = Object.isFunction(x[i]) ? x[i](m) : new Template(x[i]).evaluate(m);
+              exclusion.push("(" + v.substring(1, v.length - 1) + ")");
+              e = e.replace(m[0], '');
+              break;
+            }
+          }
+        }
+        return "[not(" + exclusion.join(" and ") + ")]";
+      },
+      'nth-child':      function(m) {
+        return Selector.xpath.pseudos.nth("(count(./preceding-sibling::*) + 1) ", m);
+      },
+      'nth-last-child': function(m) {
+        return Selector.xpath.pseudos.nth("(count(./following-sibling::*) + 1) ", m);
+      },
+      'nth-of-type':    function(m) {
+        return Selector.xpath.pseudos.nth("position() ", m);
+      },
+      'nth-last-of-type': function(m) {
+        return Selector.xpath.pseudos.nth("(last() + 1 - position()) ", m);
+      },
+      'first-of-type':  function(m) {
+        m[6] = "1"; return Selector.xpath.pseudos['nth-of-type'](m);
+      },
+      'last-of-type':   function(m) {
+        m[6] = "1"; return Selector.xpath.pseudos['nth-last-of-type'](m);
+      },
+      'only-of-type':   function(m) {
+        var p = Selector.xpath.pseudos; return p['first-of-type'](m) + p['last-of-type'](m);
+      },
+      nth: function(fragment, m) {
+        var mm, formula = m[6], predicate;
+        if (formula == 'even') formula = '2n+0';
+        if (formula == 'odd')  formula = '2n+1';
+        if (mm = formula.match(/^(\d+)$/)) // digit only
+          return '[' + fragment + "= " + mm[1] + ']';
+        if (mm = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
+          if (mm[1] == "-") mm[1] = -1;
+          var a = mm[1] ? Number(mm[1]) : 1;
+          var b = mm[2] ? Number(mm[2]) : 0;
+          predicate = "[((#{fragment} - #{b}) mod #{a} = 0) and " +
+          "((#{fragment} - #{b}) div #{a} >= 0)]";
+          return new Template(predicate).evaluate({
+            fragment: fragment, a: a, b: b });
+        }
+      }
+    }
+  },
+
+  criteria: {
+    tagName:      'n = h.tagName(n, r, "#{1}", c);      c = false;',
+    className:    'n = h.className(n, r, "#{1}", c);    c = false;',
+    id:           'n = h.id(n, r, "#{1}", c);           c = false;',
+    attrPresence: 'n = h.attrPresence(n, r, "#{1}", c); c = false;',
+    attr: function(m) {
+      m[3] = (m[5] || m[6]);
+      return new Template('n = h.attr(n, r, "#{1}", "#{3}", "#{2}", c); c = false;').evaluate(m);
+    },
+    pseudo: function(m) {
+      if (m[6]) m[6] = m[6].replace(/"/g, '\\"');
+      return new Template('n = h.pseudo(n, "#{1}", "#{6}", r, c); c = false;').evaluate(m);
+    },
+    descendant:   'c = "descendant";',
+    child:        'c = "child";',
+    adjacent:     'c = "adjacent";',
+    laterSibling: 'c = "laterSibling";'
+  },
+
+  patterns: {
+    // combinators must be listed first
+    // (and descendant needs to be last combinator)
+    laterSibling: /^\s*~\s*/,
+    child:        /^\s*>\s*/,
+    adjacent:     /^\s*\+\s*/,
+    descendant:   /^\s/,
+
+    // selectors follow
+    tagName:      /^\s*(\*|[\w\-]+)(\b|$)?/,
+    id:           /^#([\w\-\*]+)(\b|$)/,
+    className:    /^\.([\w\-\*]+)(\b|$)/,
+    pseudo:
+/^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|(?=\s|[:+~>]))/,
+    attrPresence: /^\[([\w]+)\]/,
+    attr:         /\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['"])([^\4]*?)\4|([^'"][^\]]*?)))?\]/
+  },
+
+  // for Selector.match and Element#match
+  assertions: {
+    tagName: function(element, matches) {
+      return matches[1].toUpperCase() == element.tagName.toUpperCase();
+    },
+
+    className: function(element, matches) {
+      return Element.hasClassName(element, matches[1]);
+    },
+
+    id: function(element, matches) {
+      return element.id === matches[1];
+    },
+
+    attrPresence: function(element, matches) {
+      return Element.hasAttribute(element, matches[1]);
+    },
+
+    attr: function(element, matches) {
+      var nodeValue = Element.readAttribute(element, matches[1]);
+      return nodeValue && Selector.operators[matches[2]](nodeValue, matches[5] || matches[6]);
+    }
+  },
+
+  handlers: {
+    // UTILITY FUNCTIONS
+    // joins two collections
+    concat: function(a, b) {
+      for (var i = 0, node; node = b[i]; i++)
+        a.push(node);
+      return a;
+    },
+
+    // marks an array of nodes for counting
+    mark: function(nodes) {
+      var _true = Prototype.emptyFunction;
+      for (var i = 0, node; node = nodes[i]; i++)
+        node._countedByPrototype = _true;
+      return nodes;
+    },
+
+    unmark: function(nodes) {
+      for (var i = 0, node; node = nodes[i]; i++)
+        node._countedByPrototype = undefined;
+      return nodes;
+    },
+
+    // mark each child node with its position (for nth calls)
+    // "ofType" flag indicates whether we're indexing for nth-of-type
+    // rather than nth-child
+    index: function(parentNode, reverse, ofType) {
+      parentNode._countedByPrototype = Prototype.emptyFunction;
+      if (reverse) {
+        for (var nodes = parentNode.childNodes, i = nodes.length - 1, j = 1; i >= 0; i--) {
+          var node = nodes[i];
+          if (node.nodeType == 1 && (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
+        }
+      } else {
+        for (var i = 0, j = 1, nodes = parentNode.childNodes; node = nodes[i]; i++)
+          if (node.nodeType == 1 && (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
+      }
+    },
+
+    // filters out duplicates and extends all nodes
+    unique: function(nodes) {
+      if (nodes.length == 0) return nodes;
+      var results = [], n;
+      for (var i = 0, l = nodes.length; i < l; i++)
+        if (!(n = nodes[i])._countedByPrototype) {
+          n._countedByPrototype = Prototype.emptyFunction;
+          results.push(Element.extend(n));
+        }
+      return Selector.handlers.unmark(results);
+    },
+
+    // COMBINATOR FUNCTIONS
+    descendant: function(nodes) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        h.concat(results, node.getElementsByTagName('*'));
+      return results;
+    },
+
+    child: function(nodes) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        for (var j = 0, child; child = node.childNodes[j]; j++)
+          if (child.nodeType == 1 && child.tagName != '!') results.push(child);
+      }
+      return results;
+    },
+
+    adjacent: function(nodes) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        var next = this.nextElementSibling(node);
+        if (next) results.push(next);
+      }
+      return results;
+    },
+
+    laterSibling: function(nodes) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        h.concat(results, Element.nextSiblings(node));
+      return results;
+    },
+
+    nextElementSibling: function(node) {
+      while (node = node.nextSibling)
+	      if (node.nodeType == 1) return node;
+      return null;
+    },
+
+    previousElementSibling: function(node) {
+      while (node = node.previousSibling)
+        if (node.nodeType == 1) return node;
+      return null;
+    },
+
+    // TOKEN FUNCTIONS
+    tagName: function(nodes, root, tagName, combinator) {
+      var uTagName = tagName.toUpperCase();
+      var results = [], h = Selector.handlers;
+      if (nodes) {
+        if (combinator) {
+          // fastlane for ordinary descendant combinators
+          if (combinator == "descendant") {
+            for (var i = 0, node; node = nodes[i]; i++)
+              h.concat(results, node.getElementsByTagName(tagName));
+            return results;
+          } else nodes = this[combinator](nodes);
+          if (tagName == "*") return nodes;
+        }
+        for (var i = 0, node; node = nodes[i]; i++)
+          if (node.tagName.toUpperCase() === uTagName) results.push(node);
+        return results;
+      } else return root.getElementsByTagName(tagName);
+    },
+
+    id: function(nodes, root, id, combinator) {
+      var targetNode = $(id), h = Selector.handlers;
+      if (!targetNode) return [];
+      if (!nodes && root == document) return [targetNode];
+      if (nodes) {
+        if (combinator) {
+          if (combinator == 'child') {
+            for (var i = 0, node; node = nodes[i]; i++)
+              if (targetNode.parentNode == node) return [targetNode];
+          } else if (combinator == 'descendant') {
+            for (var i = 0, node; node = nodes[i]; i++)
+              if (Element.descendantOf(targetNode, node)) return [targetNode];
+          } else if (combinator == 'adjacent') {
+            for (var i = 0, node; node = nodes[i]; i++)
+              if (Selector.handlers.previousElementSibling(targetNode) == node)
+                return [targetNode];
+          } else nodes = h[combinator](nodes);
+        }
+        for (var i = 0, node; node = nodes[i]; i++)
+          if (node == targetNode) return [targetNode];
+        return [];
+      }
+      return (targetNode && Element.descendantOf(targetNode, root)) ? [targetNode] : [];
+    },
+
+    className: function(nodes, root, className, combinator) {
+      if (nodes && combinator) nodes = this[combinator](nodes);
+      return Selector.handlers.byClassName(nodes, root, className);
+    },
+
+    byClassName: function(nodes, root, className) {
+      if (!nodes) nodes = Selector.handlers.descendant([root]);
+      var needle = ' ' + className + ' ';
+      for (var i = 0, results = [], node, nodeClassName; node = nodes[i]; i++) {
+        nodeClassName = node.className;
+        if (nodeClassName.length == 0) continue;
+        if (nodeClassName == className || (' ' + nodeClassName + ' ').include(needle))
+          results.push(node);
+      }
+      return results;
+    },
+
+    attrPresence: function(nodes, root, attr, combinator) {
+      if (!nodes) nodes = root.getElementsByTagName("*");
+      if (nodes && combinator) nodes = this[combinator](nodes);
+      var results = [];
+      for (var i = 0, node; node = nodes[i]; i++)
+        if (Element.hasAttribute(node, attr)) results.push(node);
+      return results;
+    },
+
+    attr: function(nodes, root, attr, value, operator, combinator) {
+      if (!nodes) nodes = root.getElementsByTagName("*");
+      if (nodes && combinator) nodes = this[combinator](nodes);
+      var handler = Selector.operators[operator], results = [];
+      for (var i = 0, node; node = nodes[i]; i++) {
+        var nodeValue = Element.readAttribute(node, attr);
+        if (nodeValue === null) continue;
+        if (handler(nodeValue, value)) results.push(node);
+      }
+      return results;
+    },
+
+    pseudo: function(nodes, name, value, root, combinator) {
+      if (nodes && combinator) nodes = this[combinator](nodes);
+      if (!nodes) nodes = root.getElementsByTagName("*");
+      return Selector.pseudos[name](nodes, value, root);
+    }
+  },
+
+  pseudos: {
+    'first-child': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        if (Selector.handlers.previousElementSibling(node)) continue;
+          results.push(node);
+      }
+      return results;
+    },
+    'last-child': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        if (Selector.handlers.nextElementSibling(node)) continue;
+          results.push(node);
+      }
+      return results;
+    },
+    'only-child': function(nodes, value, root) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (!h.previousElementSibling(node) && !h.nextElementSibling(node))
+          results.push(node);
+      return results;
+    },
+    'nth-child':        function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root);
+    },
+    'nth-last-child':   function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root, true);
+    },
+    'nth-of-type':      function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root, false, true);
+    },
+    'nth-last-of-type': function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root, true, true);
+    },
+    'first-of-type':    function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, "1", root, false, true);
+    },
+    'last-of-type':     function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, "1", root, true, true);
+    },
+    'only-of-type':     function(nodes, formula, root) {
+      var p = Selector.pseudos;
+      return p['last-of-type'](p['first-of-type'](nodes, formula, root), formula, root);
+    },
+
+    // handles the an+b logic
+    getIndices: function(a, b, total) {
+      if (a == 0) return b > 0 ? [b] : [];
+      return $R(1, total).inject([], function(memo, i) {
+        if (0 == (i - b) % a && (i - b) / a >= 0) memo.push(i);
+        return memo;
+      });
+    },
+
+    // handles nth(-last)-child, nth(-last)-of-type, and (first|last)-of-type
+    nth: function(nodes, formula, root, reverse, ofType) {
+      if (nodes.length == 0) return [];
+      if (formula == 'even') formula = '2n+0';
+      if (formula == 'odd')  formula = '2n+1';
+      var h = Selector.handlers, results = [], indexed = [], m;
+      h.mark(nodes);
+      for (var i = 0, node; node = nodes[i]; i++) {
+        if (!node.parentNode._countedByPrototype) {
+          h.index(node.parentNode, reverse, ofType);
+          indexed.push(node.parentNode);
+        }
+      }
+      if (formula.match(/^\d+$/)) { // just a number
+        formula = Number(formula);
+        for (var i = 0, node; node = nodes[i]; i++)
+          if (node.nodeIndex == formula) results.push(node);
+      } else if (m = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
+        if (m[1] == "-") m[1] = -1;
+        var a = m[1] ? Number(m[1]) : 1;
+        var b = m[2] ? Number(m[2]) : 0;
+        var indices = Selector.pseudos.getIndices(a, b, nodes.length);
+        for (var i = 0, node, l = indices.length; node = nodes[i]; i++) {
+          for (var j = 0; j < l; j++)
+            if (node.nodeIndex == indices[j]) results.push(node);
+        }
+      }
+      h.unmark(nodes);
+      h.unmark(indexed);
+      return results;
+    },
+
+    'empty': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        // IE treats comments as element nodes
+        if (node.tagName == '!' || (node.firstChild && !node.innerHTML.match(/^\s*$/))) continue;
+        results.push(node);
+      }
+      return results;
+    },
+
+    'not': function(nodes, selector, root) {
+      var h = Selector.handlers, selectorType, m;
+      var exclusions = new Selector(selector).findElements(root);
+      h.mark(exclusions);
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (!node._countedByPrototype) results.push(node);
+      h.unmark(exclusions);
+      return results;
+    },
+
+    'enabled': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (!node.disabled) results.push(node);
+      return results;
+    },
+
+    'disabled': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (node.disabled) results.push(node);
+      return results;
+    },
+
+    'checked': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (node.checked) results.push(node);
+      return results;
+    }
+  },
+
+  operators: {
+    '=':  function(nv, v) { return nv == v; },
+    '!=': function(nv, v) { return nv != v; },
+    '^=': function(nv, v) { return nv.startsWith(v); },
+    '$=': function(nv, v) { return nv.endsWith(v); },
+    '*=': function(nv, v) { return nv.include(v); },
+    '~=': function(nv, v) { return (' ' + nv + ' ').include(' ' + v + ' '); },
+    '|=': function(nv, v) { return ('-' + nv.toUpperCase() + '-').include('-' + v.toUpperCase() + '-'); }
+  },
+
+  split: function(expression) {
+    var expressions = [];
+    expression.scan(/(([\w#:.~>+()\s-]+|\*|\[.*?\])+)\s*(,|$)/, function(m) {
+      expressions.push(m[1].strip());
+    });
+    return expressions;
+  },
+
+  matchElements: function(elements, expression) {
+    var matches = $$(expression), h = Selector.handlers;
+    h.mark(matches);
+    for (var i = 0, results = [], element; element = elements[i]; i++)
+      if (element._countedByPrototype) results.push(element);
+    h.unmark(matches);
+    return results;
+  },
+
+  findElement: function(elements, expression, index) {
+    if (Object.isNumber(expression)) {
+      index = expression; expression = false;
+    }
+    return Selector.matchElements(elements, expression || '*')[index || 0];
+  },
+
+  findChildElements: function(element, expressions) {
+    expressions = Selector.split(expressions.join(','));
+    var results = [], h = Selector.handlers;
+    for (var i = 0, l = expressions.length, selector; i < l; i++) {
+      selector = new Selector(expressions[i].strip());
+      h.concat(results, selector.findElements(element));
+    }
+    return (l > 1) ? h.unique(results) : results;
+  }
+});
+
+if (Prototype.Browser.IE) {
+  Object.extend(Selector.handlers, {
+    // IE returns comment nodes on getElementsByTagName("*").
+    // Filter them out.
+    concat: function(a, b) {
+      for (var i = 0, node; node = b[i]; i++)
+        if (node.tagName !== "!") a.push(node);
+      return a;
+    },
+
+    // IE improperly serializes _countedByPrototype in (inner|outer)HTML.
+    unmark: function(nodes) {
+      for (var i = 0, node; node = nodes[i]; i++)
+        node.removeAttribute('_countedByPrototype');
+      return nodes;
+    }
+  });
+}
+
+function $$() {
+  return Selector.findChildElements(document, $A(arguments));
+}
+var Form = {
+  reset: function(form) {
+    $(form).reset();
+    return form;
+  },
+
+  serializeElements: function(elements, options) {
+    if (typeof options != 'object') options = { hash: !!options };
+    else if (Object.isUndefined(options.hash)) options.hash = true;
+    var key, value, submitted = false, submit = options.submit;
+
+    var data = elements.inject({ }, function(result, element) {
+      if (!element.disabled && element.name) {
+        key = element.name; value = $(element).getValue();
+        if (value != null && (element.type != 'submit' || (!submitted &&
+            submit !== false && (!submit || key == submit) && (submitted = true)))) {
+          if (key in result) {
+            // a key is already present; construct an array of values
+            if (!Object.isArray(result[key])) result[key] = [result[key]];
+            result[key].push(value);
+          }
+          else result[key] = value;
+        }
+      }
+      return result;
+    });
+
+    return options.hash ? data : Object.toQueryString(data);
+  }
+};
+
+Form.Methods = {
+  serialize: function(form, options) {
+    return Form.serializeElements(Form.getElements(form), options);
+  },
+
+  getElements: function(form) {
+    return $A($(form).getElementsByTagName('*')).inject([],
+      function(elements, child) {
+        if (Form.Element.Serializers[child.tagName.toLowerCase()])
+          elements.push(Element.extend(child));
+        return elements;
+      }
+    );
+  },
+
+  getInputs: function(form, typeName, name) {
+    form = $(form);
+    var inputs = form.getElementsByTagName('input');
+
+    if (!typeName && !name) return $A(inputs).map(Element.extend);
+
+    for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
+      var input = inputs[i];
+      if ((typeName && input.type != typeName) || (name && input.name != name))
+        continue;
+      matchingInputs.push(Element.extend(input));
+    }
+
+    return matchingInputs;
+  },
+
+  disable: function(form) {
+    form = $(form);
+    Form.getElements(form).invoke('disable');
+    return form;
+  },
+
+  enable: function(form) {
+    form = $(form);
+    Form.getElements(form).invoke('enable');
+    return form;
+  },
+
+  findFirstElement: function(form) {
+    var elements = $(form).getElements().findAll(function(element) {
+      return 'hidden' != element.type && !element.disabled;
+    });
+    var firstByIndex = elements.findAll(function(element) {
+      return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
+    }).sortBy(function(element) { return element.tabIndex }).first();
+
+    return firstByIndex ? firstByIndex : elements.find(function(element) {
+      return ['input', 'select', 'textarea'].include(element.tagName.toLowerCase());
+    });
+  },
+
+  focusFirstElement: function(form) {
+    form = $(form);
+    form.findFirstElement().activate();
+    return form;
+  },
+
+  request: function(form, options) {
+    form = $(form), options = Object.clone(options || { });
+
+    var params = options.parameters, action = form.readAttribute('action') || '';
+    if (action.blank()) action = window.location.href;
+    options.parameters = form.serialize(true);
+
+    if (params) {
+      if (Object.isString(params)) params = params.toQueryParams();
+      Object.extend(options.parameters, params);
+    }
+
+    if (form.hasAttribute('method') && !options.method)
+      options.method = form.method;
+
+    return new Ajax.Request(action, options);
+  }
+};
+
+/*--------------------------------------------------------------------------*/
+
+Form.Element = {
+  focus: function(element) {
+    $(element).focus();
+    return element;
+  },
+
+  select: function(element) {
+    $(element).select();
+    return element;
+  }
+};
+
+Form.Element.Methods = {
+  serialize: function(element) {
+    element = $(element);
+    if (!element.disabled && element.name) {
+      var value = element.getValue();
+      if (value != undefined) {
+        var pair = { };
+        pair[element.name] = value;
+        return Object.toQueryString(pair);
+      }
+    }
+    return '';
+  },
+
+  getValue: function(element) {
+    element = $(element);
+    var method = element.tagName.toLowerCase();
+    return Form.Element.Serializers[method](element);
+  },
+
+  setValue: function(element, value) {
+    element = $(element);
+    var method = element.tagName.toLowerCase();
+    Form.Element.Serializers[method](element, value);
+    return element;
+  },
+
+  clear: function(element) {
+    $(element).value = '';
+    return element;
+  },
+
+  present: function(element) {
+    return $(element).value != '';
+  },
+
+  activate: function(element) {
+    element = $(element);
+    try {
+      element.focus();
+      if (element.select && (element.tagName.toLowerCase() != 'input' ||
+          !['button', 'reset', 'submit'].include(element.type)))
+        element.select();
+    } catch (e) { }
+    return element;
+  },
+
+  disable: function(element) {
+    element = $(element);
+    element.blur();
+    element.disabled = true;
+    return element;
+  },
+
+  enable: function(element) {
+    element = $(element);
+    element.disabled = false;
+    return element;
+  }
+};
+
+/*--------------------------------------------------------------------------*/
+
+var Field = Form.Element;
+var $F = Form.Element.Methods.getValue;
+
+/*--------------------------------------------------------------------------*/
+
+Form.Element.Serializers = {
+  input: function(element, value) {
+    switch (element.type.toLowerCase()) {
+      case 'checkbox':
+      case 'radio':
+        return Form.Element.Serializers.inputSelector(element, value);
+      default:
+        return Form.Element.Serializers.textarea(element, value);
+    }
+  },
+
+  inputSelector: function(element, value) {
+    if (Object.isUndefined(value)) return element.checked ? element.value : null;
+    else element.checked = !!value;
+  },
+
+  textarea: function(element, value) {
+    if (Object.isUndefined(value)) return element.value;
+    else element.value = value;
+  },
+
+  select: function(element, index) {
+    if (Object.isUndefined(index))
+      return this[element.type == 'select-one' ?
+        'selectOne' : 'selectMany'](element);
+    else {
+      var opt, value, single = !Object.isArray(index);
+      for (var i = 0, length = element.length; i < length; i++) {
+        opt = element.options[i];
+        value = this.optionValue(opt);
+        if (single) {
+          if (value == index) {
+            opt.selected = true;
+            return;
+          }
+        }
+        else opt.selected = index.include(value);
+      }
+    }
+  },
+
+  selectOne: function(element) {
+    var index = element.selectedIndex;
+    return index >= 0 ? this.optionValue(element.options[index]) : null;
+  },
+
+  selectMany: function(element) {
+    var values, length = element.length;
+    if (!length) return null;
+
+    for (var i = 0, values = []; i < length; i++) {
+      var opt = element.options[i];
+      if (opt.selected) values.push(this.optionValue(opt));
+    }
+    return values;
+  },
+
+  optionValue: function(opt) {
+    // extend element because hasAttribute may not be native
+    return Element.extend(opt).hasAttribute('value') ? opt.value : opt.text;
+  }
+};
+
+/*--------------------------------------------------------------------------*/
+
+Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
+  initialize: function($super, element, frequency, callback) {
+    $super(callback, frequency);
+    this.element   = $(element);
+    this.lastValue = this.getValue();
+  },
+
+  execute: function() {
+    var value = this.getValue();
+    if (Object.isString(this.lastValue) && Object.isString(value) ?
+        this.lastValue != value : String(this.lastValue) != String(value)) {
+      this.callback(this.element, value);
+      this.lastValue = value;
+    }
+  }
+});
+
+Form.Element.Observer = Class.create(Abstract.TimedObserver, {
+  getValue: function() {
+    return Form.Element.getValue(this.element);
+  }
+});
+
+Form.Observer = Class.create(Abstract.TimedObserver, {
+  getValue: function() {
+    return Form.serialize(this.element);
+  }
+});
+
+/*--------------------------------------------------------------------------*/
+
+Abstract.EventObserver = Class.create({
+  initialize: function(element, callback) {
+    this.element  = $(element);
+    this.callback = callback;
+
+    this.lastValue = this.getValue();
+    if (this.element.tagName.toLowerCase() == 'form')
+      this.registerFormCallbacks();
+    else
+      this.registerCallback(this.element);
+  },
+
+  onElementEvent: function() {
+    var value = this.getValue();
+    if (this.lastValue != value) {
+      this.callback(this.element, value);
+      this.lastValue = value;
+    }
+  },
+
+  registerFormCallbacks: function() {
+    Form.getElements(this.element).each(this.registerCallback, this);
+  },
+
+  registerCallback: function(element) {
+    if (element.type) {
+      switch (element.type.toLowerCase()) {
+        case 'checkbox':
+        case 'radio':
+          Event.observe(element, 'click', this.onElementEvent.bind(this));
+          break;
+        default:
+          Event.observe(element, 'change', this.onElementEvent.bind(this));
+          break;
+      }
+    }
+  }
+});
+
+Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
+  getValue: function() {
+    return Form.Element.getValue(this.element);
+  }
+});
+
+Form.EventObserver = Class.create(Abstract.EventObserver, {
+  getValue: function() {
+    return Form.serialize(this.element);
+  }
+});
+if (!window.Event) var Event = { };
+
+Object.extend(Event, {
+  KEY_BACKSPACE: 8,
+  KEY_TAB:       9,
+  KEY_RETURN:   13,
+  KEY_ESC:      27,
+  KEY_LEFT:     37,
+  KEY_UP:       38,
+  KEY_RIGHT:    39,
+  KEY_DOWN:     40,
+  KEY_DELETE:   46,
+  KEY_HOME:     36,
+  KEY_END:      35,
+  KEY_PAGEUP:   33,
+  KEY_PAGEDOWN: 34,
+  KEY_INSERT:   45,
+
+  cache: { },
+
+  relatedTarget: function(event) {
+    var element;
+    switch(event.type) {
+      case 'mouseover': element = event.fromElement; break;
+      case 'mouseout':  element = event.toElement;   break;
+      default: return null;
+    }
+    return Element.extend(element);
+  }
+});
+
+Event.Methods = (function() {
+  var isButton;
+
+  if (Prototype.Browser.IE) {
+    var buttonMap = { 0: 1, 1: 4, 2: 2 };
+    isButton = function(event, code) {
+      return event.button == buttonMap[code];
+    };
+
+  } else if (Prototype.Browser.WebKit) {
+    isButton = function(event, code) {
+      switch (code) {
+        case 0: return event.which == 1 && !event.metaKey;
+        case 1: return event.which == 1 && event.metaKey;
+        default: return false;
+      }
+    };
+
+  } else {
+    isButton = function(event, code) {
+      return event.which ? (event.which === code + 1) : (event.button === code);
+    };
+  }
+
+  return {
+    isLeftClick:   function(event) { return isButton(event, 0) },
+    isMiddleClick: function(event) { return isButton(event, 1) },
+    isRightClick:  function(event) { return isButton(event, 2) },
+
+    element: function(event) {
+      var node = Event.extend(event).target;
+      return Element.extend(node.nodeType == Node.TEXT_NODE ? node.parentNode : node);
+    },
+
+    findElement: function(event, expression) {
+      var element = Event.element(event);
+      if (!expression) return element;
+      var elements = [element].concat(element.ancestors());
+      return Selector.findElement(elements, expression, 0);
+    },
+
+    pointer: function(event) {
+      return {
+        x: event.pageX || (event.clientX +
+          (document.documentElement.scrollLeft || document.body.scrollLeft)),
+        y: event.pageY || (event.clientY +
+          (document.documentElement.scrollTop || document.body.scrollTop))
+      };
+    },
+
+    pointerX: function(event) { return Event.pointer(event).x },
+    pointerY: function(event) { return Event.pointer(event).y },
+
+    stop: function(event) {
+      Event.extend(event);
+      event.preventDefault();
+      event.stopPropagation();
+      event.stopped = true;
+    }
+  };
+})();
+
+Event.extend = (function() {
+  var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
+    m[name] = Event.Methods[name].methodize();
+    return m;
+  });
+
+  if (Prototype.Browser.IE) {
+    Object.extend(methods, {
+      stopPropagation: function() { this.cancelBubble = true },
+      preventDefault:  function() { this.returnValue = false },
+      inspect: function() { return "[object Event]" }
+    });
+
+    return function(event) {
+      if (!event) return false;
+      if (event._extendedByPrototype) return event;
+
+      event._extendedByPrototype = Prototype.emptyFunction;
+      var pointer = Event.pointer(event);
+      Object.extend(event, {
+        target: event.srcElement,
+        relatedTarget: Event.relatedTarget(event),
+        pageX:  pointer.x,
+        pageY:  pointer.y
+      });
+      return Object.extend(event, methods);
+    };
+
+  } else {
+    Event.prototype = Event.prototype || document.createEvent("HTMLEvents").__proto__;
+    Object.extend(Event.prototype, methods);
+    return Prototype.K;
+  }
+})();
+
+Object.extend(Event, (function() {
+  var cache = Event.cache;
+
+  function getEventID(element) {
+    if (element._prototypeEventID) return element._prototypeEventID[0];
+    arguments.callee.id = arguments.callee.id || 1;
+    return element._prototypeEventID = [++arguments.callee.id];
+  }
+
+  function getDOMEventName(eventName) {
+    if (eventName && eventName.include(':')) return "dataavailable";
+    return eventName;
+  }
+
+  function getCacheForID(id) {
+    return cache[id] = cache[id] || { };
+  }
+
+  function getWrappersForEventName(id, eventName) {
+    var c = getCacheForID(id);
+    return c[eventName] = c[eventName] || [];
+  }
+
+  function createWrapper(element, eventName, handler) {
+    var id = getEventID(element);
+    var c = getWrappersForEventName(id, eventName);
+    if (c.pluck("handler").include(handler)) return false;
+
+    var wrapper = function(event) {
+      if (!Event || !Event.extend ||
+        (event.eventName && event.eventName != eventName))
+          return false;
+
+      Event.extend(event);
+      handler.call(element, event);
+    };
+
+    wrapper.handler = handler;
+    c.push(wrapper);
+    return wrapper;
+  }
+
+  function findWrapper(id, eventName, handler) {
+    var c = getWrappersForEventName(id, eventName);
+    return c.find(function(wrapper) { return wrapper.handler == handler });
+  }
+
+  function destroyWrapper(id, eventName, handler) {
+    var c = getCacheForID(id);
+    if (!c[eventName]) return false;
+    c[eventName] = c[eventName].without(findWrapper(id, eventName, handler));
+  }
+
+  function destroyCache() {
+    for (var id in cache)
+      for (var eventName in cache[id])
+        cache[id][eventName] = null;
+  }
+
+  if (window.attachEvent) {
+    window.attachEvent("onunload", destroyCache);
+  }
+
+  return {
+    observe: function(element, eventName, handler) {
+      element = $(element);
+      var name = getDOMEventName(eventName);
+
+      var wrapper = createWrapper(element, eventName, handler);
+      if (!wrapper) return element;
+
+      if (element.addEventListener) {
+        element.addEventListener(name, wrapper, false);
+      } else {
+        element.attachEvent("on" + name, wrapper);
+      }
+
+      return element;
+    },
+
+    stopObserving: function(element, eventName, handler) {
+      element = $(element);
+      var id = getEventID(element), name = getDOMEventName(eventName);
+
+      if (!handler && eventName) {
+        getWrappersForEventName(id, eventName).each(function(wrapper) {
+          element.stopObserving(eventName, wrapper.handler);
+        });
+        return element;
+
+      } else if (!eventName) {
+        Object.keys(getCacheForID(id)).each(function(eventName) {
+          element.stopObserving(eventName);
+        });
+        return element;
+      }
+
+      var wrapper = findWrapper(id, eventName, handler);
+      if (!wrapper) return element;
+
+      if (element.removeEventListener) {
+        element.removeEventListener(name, wrapper, false);
+      } else {
+        element.detachEvent("on" + name, wrapper);
+      }
+
+      destroyWrapper(id, eventName, handler);
+
+      return element;
+    },
+
+    fire: function(element, eventName, memo) {
+      element = $(element);
+      if (element == document && document.createEvent && !element.dispatchEvent)
+        element = document.documentElement;
+
+      var event;
+      if (document.createEvent) {
+        event = document.createEvent("HTMLEvents");
+        event.initEvent("dataavailable", true, true);
+      } else {
+        event = document.createEventObject();
+        event.eventType = "ondataavailable";
+      }
+
+      event.eventName = eventName;
+      event.memo = memo || { };
+
+      if (document.createEvent) {
+        element.dispatchEvent(event);
+      } else {
+        element.fireEvent(event.eventType, event);
+      }
+
+      return Event.extend(event);
+    }
+  };
+})());
+
+Object.extend(Event, Event.Methods);
+
+Element.addMethods({
+  fire:          Event.fire,
+  observe:       Event.observe,
+  stopObserving: Event.stopObserving
+});
+
+Object.extend(document, {
+  fire:          Element.Methods.fire.methodize(),
+  observe:       Element.Methods.observe.methodize(),
+  stopObserving: Element.Methods.stopObserving.methodize(),
+  loaded:        false
+});
+
+(function() {
+  /* Support for the DOMContentLoaded event is based on work by Dan Webb,
+     Matthias Miller, Dean Edwards and John Resig. */
+
+  var timer;
+
+  function fireContentLoadedEvent() {
+    if (document.loaded) return;
+    if (timer) window.clearInterval(timer);
+    document.fire("dom:loaded");
+    document.loaded = true;
+  }
+
+  if (document.addEventListener) {
+    if (Prototype.Browser.WebKit) {
+      timer = window.setInterval(function() {
+        if (/loaded|complete/.test(document.readyState))
+          fireContentLoadedEvent();
+      }, 0);
+
+      Event.observe(window, "load", fireContentLoadedEvent);
+
+    } else {
+      document.addEventListener("DOMContentLoaded",
+        fireContentLoadedEvent, false);
+    }
+
+  } else {
+    document.write("<script id=__onDOMContentLoaded defer src=//:><\/script>");
+    $("__onDOMContentLoaded").onreadystatechange = function() {
+      if (this.readyState == "complete") {
+        this.onreadystatechange = null;
+        fireContentLoadedEvent();
+      }
+    };
+  }
+})();
+/*------------------------------- DEPRECATED -------------------------------*/
+
+Hash.toQueryString = Object.toQueryString;
+
+var Toggle = { display: Element.toggle };
+
+Element.Methods.childOf = Element.Methods.descendantOf;
+
+var Insertion = {
+  Before: function(element, content) {
+    return Element.insert(element, {before:content});
+  },
+
+  Top: function(element, content) {
+    return Element.insert(element, {top:content});
+  },
+
+  Bottom: function(element, content) {
+    return Element.insert(element, {bottom:content});
+  },
+
+  After: function(element, content) {
+    return Element.insert(element, {after:content});
+  }
+};
+
+var $continue = new Error('"throw $continue" is deprecated, use "return" instead');
+
+// This should be moved to script.aculo.us; notice the deprecated methods
+// further below, that map to the newer Element methods.
+var Position = {
+  // set to true if needed, warning: firefox performance problems
+  // NOT neeeded for page scrolling, only if draggable contained in
+  // scrollable elements
+  includeScrollOffsets: false,
+
+  // must be called before calling withinIncludingScrolloffset, every time the
+  // page is scrolled
+  prepare: function() {
+    this.deltaX =  window.pageXOffset
+                || document.documentElement.scrollLeft
+                || document.body.scrollLeft
+                || 0;
+    this.deltaY =  window.pageYOffset
+                || document.documentElement.scrollTop
+                || document.body.scrollTop
+                || 0;
+  },
+
+  // caches x/y coordinate pair to use with overlap
+  within: function(element, x, y) {
+    if (this.includeScrollOffsets)
+      return this.withinIncludingScrolloffsets(element, x, y);
+    this.xcomp = x;
+    this.ycomp = y;
+    this.offset = Element.cumulativeOffset(element);
+
+    return (y >= this.offset[1] &&
+            y <  this.offset[1] + element.offsetHeight &&
+            x >= this.offset[0] &&
+            x <  this.offset[0] + element.offsetWidth);
+  },
+
+  withinIncludingScrolloffsets: function(element, x, y) {
+    var offsetcache = Element.cumulativeScrollOffset(element);
+
+    this.xcomp = x + offsetcache[0] - this.deltaX;
+    this.ycomp = y + offsetcache[1] - this.deltaY;
+    this.offset = Element.cumulativeOffset(element);
+
+    return (this.ycomp >= this.offset[1] &&
+            this.ycomp <  this.offset[1] + element.offsetHeight &&
+            this.xcomp >= this.offset[0] &&
+            this.xcomp <  this.offset[0] + element.offsetWidth);
+  },
+
+  // within must be called directly before
+  overlap: function(mode, element) {
+    if (!mode) return 0;
+    if (mode == 'vertical')
+      return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
+        element.offsetHeight;
+    if (mode == 'horizontal')
+      return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
+        element.offsetWidth;
+  },
+
+  // Deprecation layer -- use newer Element methods now (1.5.2).
+
+  cumulativeOffset: Element.Methods.cumulativeOffset,
+
+  positionedOffset: Element.Methods.positionedOffset,
+
+  absolutize: function(element) {
+    Position.prepare();
+    return Element.absolutize(element);
+  },
+
+  relativize: function(element) {
+    Position.prepare();
+    return Element.relativize(element);
+  },
+
+  realOffset: Element.Methods.cumulativeScrollOffset,
+
+  offsetParent: Element.Methods.getOffsetParent,
+
+  page: Element.Methods.viewportOffset,
+
+  clone: function(source, target, options) {
+    options = options || { };
+    return Element.clonePosition(target, source, options);
+  }
+};
+
+/*--------------------------------------------------------------------------*/
+
+if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
+  function iter(name) {
+    return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";
+  }
+
+  instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
+  function(element, className) {
+    className = className.toString().strip();
+    var cond = /\s/.test(className) ? $w(className).map(iter).join('') : iter(className);
+    return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
+  } : function(element, className) {
+    className = className.toString().strip();
+    var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
+    if (!classNames && !className) return elements;
+
+    var nodes = $(element).getElementsByTagName('*');
+    className = ' ' + className + ' ';
+
+    for (var i = 0, child, cn; child = nodes[i]; i++) {
+      if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
+          (classNames && classNames.all(function(name) {
+            return !name.toString().blank() && cn.include(' ' + name + ' ');
+          }))))
+        elements.push(Element.extend(child));
+    }
+    return elements;
+  };
+
+  return function(className, parentElement) {
+    return $(parentElement || document.body).getElementsByClassName(className);
+  };
+}(Element.Methods);
+
+/*--------------------------------------------------------------------------*/
+
+Element.ClassNames = Class.create();
+Element.ClassNames.prototype = {
+  initialize: function(element) {
+    this.element = $(element);
+  },
+
+  _each: function(iterator) {
+    this.element.className.split(/\s+/).select(function(name) {
+      return name.length > 0;
+    })._each(iterator);
+  },
+
+  set: function(className) {
+    this.element.className = className;
+  },
+
+  add: function(classNameToAdd) {
+    if (this.include(classNameToAdd)) return;
+    this.set($A(this).concat(classNameToAdd).join(' '));
+  },
+
+  remove: function(classNameToRemove) {
+    if (!this.include(classNameToRemove)) return;
+    this.set($A(this).without(classNameToRemove).join(' '));
+  },
+
+  toString: function() {
+    return $A(this).join(' ');
+  }
+};
+
+Object.extend(Element.ClassNames.prototype, Enumerable);
+
+/*--------------------------------------------------------------------------*/
+
+Element.addMethods();
+
Index: node_modules/ometa/prototype-fix.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/prototype-fix.js	(date 1323192249000)
+++ node_modules/ometa/prototype-fix.js	(date 1323192249000)
@@ -0,0 +1,91 @@
+// Override prototype.js' Ajax
+
+// To allow PUT and PROPFIND method
+
+Ajax.Request.prototype.request = function(url) {
+    this.url = url;
+    this.method = this.options.method;
+    var params = Object.clone(this.options.parameters);
+
+    if (!['get', 'post', 'put', 'propfind'].include(this.method)) {
+//    if (!['get', 'post'].include(this.method)) {
+      // simulate other verbs over post
+      params['_method'] = this.method;
+      this.method = 'post';
+    }
+
+    this.parameters = params;
+
+    if (params = Hash.toQueryString(params)) {
+      // when GET, append parameters to URL
+      if (this.method == 'get')
+        this.url += (this.url.include('?') ? '&' : '?') + params;
+      else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent))
+        params += '&_=';
+    }
+
+    try {
+      if (this.options.onCreate) this.options.onCreate(this.transport);
+      Ajax.Responders.dispatch('onCreate', this, this.transport);
+
+      this.transport.open(this.method.toUpperCase(), this.url,
+        this.options.asynchronous);
+
+      if (this.options.asynchronous)
+        setTimeout(function() { this.respondToReadyState(1) }.bind(this), 10);
+
+      this.transport.onreadystatechange = this.onStateChange.bind(this);
+      this.setRequestHeaders();
+
+      this.body = (['post', 'put'].include(this.method)) ? (this.options.postBody || params) : null;
+      this.transport.send(this.body);
+
+      /* Force Firefox to handle ready state 4 for synchronous requests */
+      if (!this.options.asynchronous && this.transport.overrideMimeType)
+        this.onStateChange();
+
+    }
+    catch (e) {
+      this.dispatchException(e);
+    }
+}
+
+// To avoid properties added to Object by ometa.
+
+Ajax.Request.prototype.setRequestHeaders = function(url) {
+    var headers = {
+      'X-Requested-With': 'XMLHttpRequest',
+      'X-Prototype-Version': Prototype.Version,
+      'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
+    };
+
+    if (this.method == 'post') {
+      headers['Content-type'] = this.options.contentType +
+        (this.options.encoding ? '; charset=' + this.options.encoding : '');
+
+      /* Force "Connection: close" for older Mozilla browsers to work
+       * around a bug where XMLHttpRequest sends an incorrect
+       * Content-length header. See Mozilla Bugzilla #246651.
+       */
+      if (this.transport.overrideMimeType &&
+          (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
+            headers['Connection'] = 'close';
+    }
+
+    // user-defined headers
+    if (typeof this.options.requestHeaders == 'object') {
+      var extras = this.options.requestHeaders;
+
+      if (typeof extras.push == 'function')
+        for (var i = 0, length = extras.length; i < length; i += 2)
+          headers[extras[i]] = extras[i+1];
+      else
+        $H(extras).each(function(pair) { headers[pair.key] = pair.value });
+    }
+
+    for (var name in headers) {
+      if (typeof headers[name] == "string") {
+        this.transport.setRequestHeader(name, headers[name]);
+      }
+    }
+}
Index: node_modules/scss/.npmignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/.npmignore	(date 1323271705000)
+++ node_modules/scss/.npmignore	(date 1323271705000)
@@ -0,0 +1,3 @@
+*.swp
+.DS_Store
+node_modules
Index: .idea/codeStyles/codeStyleConfig.xml
===================================================================
--- .idea/codeStyles/codeStyleConfig.xml	(date 1607504960091)
+++ .idea/codeStyles/codeStyleConfig.xml	(date 1607504960091)
@@ -0,0 +1,5 @@
+<component name="ProjectCodeStyleConfiguration">
+  <state>
+    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Default" />
+  </state>
+</component>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/workspace.xml	(date 1607610565457)
+++ .idea/workspace.xml	(date 1607610565457)
@@ -0,0 +1,189 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ChangeListManager">
+    <list default="true" id="a7224da8-c1fb-4030-ba64-417b0f4c139e" name="Default Changelist" comment="Number guessing game / removed a console log, edited comments">
+      <change afterPath="$PROJECT_DIR$/.gitignore" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/alhorythm.iml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/codeStyles/codeStyleConfig.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/modules.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/watcherTasks.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/.npmignore" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/Not_Quite_JS.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/OMeta_Tutorial.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/OMeta_WJS.wjs" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/OMeta_WJS_Mods.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/README.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/Things_You_Should_Know.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/Worlds2.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/Worlds2_Library.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/arrays.wjs" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-js-compiler.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-js-compiler.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-ometa-compiler.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-ometa-compiler.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-ometa-js-compiler.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-ometa-js-compiler.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-ometa-optimizer.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-ometa-optimizer.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-project-list-parser.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/bs-project-list-parser.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/index.html" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/index.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/lib.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/license.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/newLineGrammar.ometa" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/newLineTest.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/ometa-base.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/ometa-node.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/ometa-rhino.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/ometa-script-tag.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/oshell" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/package.json" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/parser.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/prototype-fix.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/prototype.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/readme-rhino.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/standalone.html" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/v8-shell.cc" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/w2shell" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/wiki.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/ometa/workspace.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/.npmignore" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/README.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/.sass-cache/fde1591a2407d9320ef40d99ec712c5349978ec8/blog.scssc" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/.sass-cache/fde1591a2407d9320ef40d99ec712c5349978ec8/input.scssc" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/blog.css" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/blog.css.map" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/blog.scss" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/compiler_tester.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/grammarInvoker.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/input.css" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/input.css.map" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/input.scss" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/examples/tester.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/package.json" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/specs/cssSelectorSpecs.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/specs/grammarInvoker.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/src/compiler.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/src/cssSelector.ometa" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/src/index.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/src/prettyPrint.js" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/node_modules/scss/src/scss.ometa" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/algorythms.html" beforeDir="false" afterPath="$PROJECT_DIR$/algorythms.html" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/algorythms.js" beforeDir="false" afterPath="$PROJECT_DIR$/algorythms.js" afterDir="false" />
+    </list>
+    <option name="SHOW_DIALOG" value="false" />
+    <option name="HIGHLIGHT_CONFLICTS" value="true" />
+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
+    <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="ComposerSettings">
+    <execution />
+  </component>
+  <component name="Git.Settings">
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$" value="master" />
+      </map>
+    </option>
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="ProjectId" id="1lPi5hh6z5WzMEBP2nHvw5QfSsk" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showLibraryContents" value="true" />
+  </component>
+  <component name="PropertiesComponent">
+    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
+    <property name="WebServerToolWindowFactoryState" value="false" />
+    <property name="last_opened_file_path" value="$PROJECT_DIR$/../../Praktika2020/Fusebox/fusebox" />
+    <property name="node.js.detected.package.eslint" value="true" />
+    <property name="node.js.detected.package.tslint" value="true" />
+    <property name="node.js.path.for.package.eslint" value="project" />
+    <property name="node.js.path.for.package.tslint" value="project" />
+    <property name="node.js.selected.package.eslint" value="(autodetect)" />
+    <property name="node.js.selected.package.tslint" value="(autodetect)" />
+    <property name="nodejs_package_manager_path" value="npm" />
+    <property name="vue.rearranger.settings.migration" value="true" />
+  </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+  <component name="TaskManager">
+    <task active="true" id="Default" summary="Default task">
+      <changelist id="a7224da8-c1fb-4030-ba64-417b0f4c139e" name="Default Changelist" comment="" />
+      <created>1607504946002</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1607504946002</updated>
+      <workItem from="1607504947045" duration="15661000" />
+      <workItem from="1607594418451" duration="6197000" />
+    </task>
+    <task id="LOCAL-00001" summary="Algorythm init.&#10;&#10;Word game algorythm">
+      <created>1607594579939</created>
+      <option name="number" value="00001" />
+      <option name="presentableId" value="LOCAL-00001" />
+      <option name="project" value="LOCAL" />
+      <updated>1607594579939</updated>
+    </task>
+    <task id="LOCAL-00002" summary="Number guessing game algorythm">
+      <created>1607599169928</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1607599169928</updated>
+    </task>
+    <task id="LOCAL-00003" summary="Number guessing game / removed a console log, edited comments">
+      <created>1607599601015</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1607599601015</updated>
+    </task>
+    <option name="localTasksCounter" value="4" />
+    <servers />
+  </component>
+  <component name="TypeScriptGeneratedFilesManager">
+    <option name="version" value="3" />
+  </component>
+  <component name="VcsManagerConfiguration">
+    <MESSAGE value="Algorythm init.&#10;&#10;Word game algorythm" />
+    <MESSAGE value="Number guessing game algorythm" />
+    <MESSAGE value="Number guessing game / removed a console log, edited comments" />
+    <option name="LAST_COMMIT_MESSAGE" value="Number guessing game / removed a console log, edited comments" />
+  </component>
+  <component name="WindowStateProjectService">
+    <state x="349" y="0" key="CommitChangelistDialog2" timestamp="1607599600269">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="349" y="0" key="CommitChangelistDialog2/0.0.1536.824@0.0.1536.824" timestamp="1607599600269" />
+    <state x="438" y="190" key="EditFileWatcherDialog" timestamp="1607534305144">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="438" y="190" key="EditFileWatcherDialog/0.0.1536.824@0.0.1536.824" timestamp="1607534305144" />
+    <state x="549" y="167" key="FileChooserDialogImpl" timestamp="1607543574480">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="549" y="167" key="FileChooserDialogImpl/0.0.1536.824@0.0.1536.824" timestamp="1607543574480" />
+    <state x="599" y="114" key="RollbackChangesDialog" timestamp="1607538515306">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="599" y="114" key="RollbackChangesDialog/0.0.1536.824@0.0.1536.824" timestamp="1607538515306" />
+    <state x="361" y="145" key="Vcs.Push.Dialog.v2" timestamp="1607599602786">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="361" y="145" key="Vcs.Push.Dialog.v2/0.0.1536.824@0.0.1536.824" timestamp="1607599602786" />
+    <state x="586" y="326" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2" timestamp="1607594457788">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="586" y="326" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.0.1536.824@0.0.1536.824" timestamp="1607594457788" />
+    <state x="570" y="318" key="git4idea.remote.GitConfigureRemotesDialog" timestamp="1607594449821">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="570" y="318" key="git4idea.remote.GitConfigureRemotesDialog/0.0.1536.824@0.0.1536.824" timestamp="1607594449821" />
+    <state x="425" y="187" key="run.anything.popup" timestamp="1607543218720">
+      <screen x="0" y="0" width="1536" height="824" />
+    </state>
+    <state x="425" y="187" key="run.anything.popup/0.0.1536.824@0.0.1536.824" timestamp="1607543218720" />
+  </component>
+</project>
\ No newline at end of file
Index: .gitignore
===================================================================
--- .gitignore	(date 1607599313761)
+++ .gitignore	(date 1607599313761)
@@ -0,0 +1,2 @@
+/.sass-cache/
+/node_modules/
Index: node_modules/scss/examples/blog.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/blog.css	(date 1607534375019)
+++ node_modules/scss/examples/blog.css	(date 1607534375019)
@@ -0,0 +1,21 @@
+#main {
+  margin: 0 5.625em; }
+  #main h5, #main h6 {
+    font-size: 1em;
+    line-height: 1.25em; }
+  #main .post {
+    text-align: left; }
+    #main .post ul {
+      list-style-position: inside;
+      list-style-type: circle;
+      margin: 0.625em; }
+  #main .post-dash {
+    color: green;
+    background-color: green;
+    color: red; }
+    #main .post-dash div {
+      float: left; }
+    #main .post-dash a {
+      text-decoration: none; }
+
+/*# sourceMappingURL=blog.css.map */
Index: node_modules/scss/examples/input.css.map
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/input.css.map	(date 1607534375020)
+++ node_modules/scss/examples/input.css.map	(date 1607534375020)
@@ -0,0 +1,7 @@
+{
+"version": 3,
+"mappings": "AAAc,GAAI;EAAE,MAAM,EAAC,OAAO;EAAE,UAAO;IAAE,UAAU,EAAlD,OAAO;IAAiD,KAAK,EAAC,KAAK;;AAAK,OAAO;EAAC,KAAK,EAArF,OAAO",
+"sources": ["input.scss"],
+"names": [],
+"file": "input.css"
+}
Index: .idea/watcherTasks.xml
===================================================================
--- .idea/watcherTasks.xml	(date 1607534424906)
+++ .idea/watcherTasks.xml	(date 1607534424906)
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectTasksOptions">
+    <TaskOptions isEnabled="true">
+      <option name="arguments" value="$FileName$:$FileNameWithoutExtension$.css" />
+      <option name="checkSyntaxErrors" value="true" />
+      <option name="description" />
+      <option name="exitCodeBehavior" value="ERROR" />
+      <option name="fileExtension" value="scss" />
+      <option name="immediateSync" value="true" />
+      <option name="name" value="SCSS" />
+      <option name="output" value="$FileNameWithoutExtension$.css:$FileNameWithoutExtension$.css.map" />
+      <option name="outputFilters">
+        <array />
+      </option>
+      <option name="outputFromStdout" value="false" />
+      <option name="program" value="sass" />
+      <option name="runOnExternalChanges" value="true" />
+      <option name="scopeName" value="Project Files" />
+      <option name="trackOnlyRoot" value="true" />
+      <option name="workingDir" value="$FileDir$" />
+      <envs />
+    </TaskOptions>
+  </component>
+</project>
\ No newline at end of file
Index: node_modules/scss/examples/blog.css.map
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/blog.css.map	(date 1607534375023)
+++ node_modules/scss/examples/blog.css.map	(date 1607534375023)
@@ -0,0 +1,7 @@
+{
+"version": 3,
+"mappings": "AAiBA,KAAM;EACJ,MAAM,EAAE,SAAS;EACjB,kBAAO;IACL,SAAS,EAAE,GAAG;IACd,WAAW,EAAE,MAAM;EAErB,WAAM;IACJ,UAAU,EAAE,IAAI;IAChB,cAAG;MACD,mBAAmB,EAAE,MAAM;MAC3B,eAAe,EAAE,MAAM;MACvB,MAAM,EAAE,OAAO;EAGnB,gBAAW;IA5BX,KAAK,EAHK,KAAK;IAWf,gBAAgB,EAXN,KAAK;IAiCb,KAAK,EAAE,GAAG;IA7BZ,oBAAI;MACF,KAAK,EAAE,IAAI;IAOb,kBAAE;MACA,eAAe,EAAE,IAAI",
+"sources": ["blog.scss"],
+"names": [],
+"file": "blog.css"
+}
Index: node_modules/ometa/OMeta_Tutorial.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/OMeta_Tutorial.txt	(date 1323192249000)
+++ node_modules/ometa/OMeta_Tutorial.txt	(date 1323192249000)
@@ -0,0 +1,150 @@
+// a simple recognizer, produces no useful value
+
+ometa L {
+  number   = digit+,
+  addExpr  = addExpr '+' mulExpr
+           | addExpr '-' mulExpr
+           | mulExpr,
+  mulExpr  = mulExpr '*' primExpr
+           | mulExpr '/' primExpr
+           | primExpr,
+  primExpr = '(' expr ')'
+           | number,
+  expr     = addExpr
+}
+
+L.matchAll('6*(4+3)', 'expr')
+
+
+
+
+
+
+// a recognizer that also interprets
+
+ometa Calc {
+  digit    = ^digit:d                 -> d.digitValue(),
+  number   = number:n digit:d         -> (n * 10 + d)
+           | digit,
+  addExpr  = addExpr:x '+' mulExpr:y  -> (x + y)
+           | addExpr:x '-' mulExpr:y  -> (x - y)
+           | mulExpr,
+  mulExpr  = mulExpr:x '*' primExpr:y -> (x * y)
+           | mulExpr:x '/' primExpr:y -> (x / y)
+           | primExpr,
+  primExpr = '(' expr:x ')'           -> x
+           | number,
+  expr     = addExpr
+}
+
+Calc.matchAll('6**(4+3)', 'expr')
+
+
+
+
+
+
+// parser and simple interpreter combo
+
+ometa CalcParser {
+  digit    = ^digit:d                 -> d.digitValue(),
+  number   = number:n digit:d         -> (n * 10 + d)
+           | digit,
+  addExpr  = addExpr:x '+' mulExpr:y  -> ['add', x, y]
+           | addExpr:x '-' mulExpr:y  -> ['sub', x, y]
+           | mulExpr,
+  mulExpr  = mulExpr:x '*' primExpr:y -> ['mul', x, y]
+           | mulExpr:x '/' primExpr:y -> ['div', x, y]
+           | primExpr,
+  primExpr = '(' expr:x ')'           -> x
+           | number:n                 -> ['num', n],
+  expr     = addExpr
+}
+
+tree = CalcParser.matchAll('6*(4+3)', 'expr') 
+
+ometa CalcInterpreter {
+  interp = ['num' anything:x]        -> x
+         | ['add' interp:x interp:y] -> (x + y)
+         | ['sub' interp:x interp:y] -> (x - y)
+         | ['mul' interp:x interp:y] -> (x * y)
+         | ['div' interp:x interp:y] -> (x / y)
+}
+
+CalcInterpreter.match(tree, 'interp')
+
+
+
+
+
+
+
+// we can write a "compiler" instead
+
+ometa CalcCompiler {
+  comp    = ['num' anything:x]    -> x.toString()
+          | ['add' comp:x comp:y] -> ('(' + x + '+' + y + ')')
+          | ['sub' comp:x comp:y] -> ('(' + x + '-' + y + ')')
+          | ['mul' comp:x comp:y] -> ('(' + x + '*' + y + ')')
+          | ['div' comp:x comp:y] -> ('(' + x + '/' + y + ')')
+}
+
+code = CalcCompiler.match(tree, 'comp')
+eval(code)
+ 
+
+
+
+
+
+
+
+
+
+
+
+// spice things up with ML-like syntax
+
+ometa CalcCompiler {
+  comp ['num' anything:x]    -> x.toString(),
+  comp ['add' comp:x comp:y] -> ('(' + x + '+' + y + ')'),
+  comp ['sub' comp:x comp:y] -> ('(' + x + '-' + y + ')'),
+  comp ['mul' comp:x comp:y] -> ('(' + x + '*' + y + ')'),
+  comp ['div' comp:x comp:y] -> ('(' + x + '/' + y + ')')
+}
+
+code = CalcCompiler.match(tree, 'comp')
+eval(code)
+ 
+
+
+
+
+
+
+
+
+
+
+
+// a neat trick: dispatch on node tags using higher-order rule "apply"
+
+ometa CalcCompiler {
+  comp [anything:t apply(t):ans] -> ans,
+  num  anything:x                -> x.toString(),
+  add  comp:x comp:y             -> ('(' + x + '+' + y + ')'),
+  sub  comp:x comp:y             -> ('(' + x + '-' + y + ')'),
+  mul  comp:x comp:y             -> ('(' + x + '*' + y + ')'),
+  div  comp:x comp:y             -> ('(' + x + '/' + y + ')')
+}
+
+code = CalcCompiler.match(tree, 'comp')
+eval(code)
+
+
+
+
+
+
+
+
Index: node_modules/ometa/OMeta_WJS_Mods.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/OMeta_WJS_Mods.js	(date 1323192249000)
+++ node_modules/ometa/OMeta_WJS_Mods.js	(date 1323192249000)
@@ -0,0 +1,110 @@
+OMeta._or = function() {
+  for (var idx = 0; idx < arguments.length; idx++) {
+    var ok = true
+    in thisWorld.sprout() {
+      try { return arguments[idx]() }
+      catch (f) {
+        ok = false
+        if (f != fail)
+          throw f
+      }
+      finally { if (ok) thisWorld.commit() }
+    }
+  }
+  throw fail
+}
+
+OMeta._many = function(x) {
+  var ans = arguments[1] != undefined ? [arguments[1]] : []
+  while (true) {
+    in thisWorld.sprout() {
+      try {
+        ans.push(x())
+        //print("committing " + ans.toString())
+        thisWorld.commit()
+      }
+      catch (f) {
+        if (f != fail)
+          throw f
+        break
+      }
+    }
+  }
+  return ans
+}
+
+OMeta._not = function(x) {
+  in thisWorld.sprout() {
+    try { x() }
+    catch (f) {
+      if (f != fail)
+        throw f
+      return true
+    }
+  }
+  throw fail
+}
+
+/*
+OMeta._lookahead = function(x) {
+  in thisWorld.sprout() {
+    var r = x()
+    //print("la = " + r.toString())
+    return x
+  }
+}
+*/
+
+/*
+OMeta._apply = function(rule) {
+  var memoRec = this.input.memo[rule]
+  if (memoRec == undefined) {
+    var origInput = this.input,
+        failer    = new Failer()
+    this.input.memo[rule] = failer
+    this.input.memo[rule] = memoRec = {ans: this[rule].apply(this), nextInput: this.input}
+    if (failer.used) {
+      var sentinel = this.input
+      while (true) {
+        try {
+          this.input = origInput
+          var ans = this[rule].apply(this)
+          if (this.input == sentinel)
+            throw fail
+          memoRec.ans       = ans
+          memoRec.nextInput = this.input
+        }
+        catch (f) {
+          if (f != fail)
+            throw f
+          break
+        }
+      }
+    }
+  }
+  else if (memoRec instanceof Failer) {
+    memoRec.used = true
+    throw fail
+  }
+  this.input = memoRec.nextInput
+  return memoRec.ans
+}
+*/
+
+
+print("defining example 1")
+eval(BSOMetaJSTranslator.match(BSOMetaJSParser.matchAll("ometa M { ones = (1 -> 2)* }", "srcElem"), "trans"))
+print("running example 1")
+print(M.matchAll([1, 1, 1, 1], "ones"))
+
+print("defining example 2")
+eval(BSOMetaJSTranslator.match(BSOMetaJSParser.matchAll("ometa M { foo = &(:x) anything*:ys -> [x, ys] }", "srcElem"), "trans"))
+print("running example 2")
+print(M.matchAll([1, 2, 3, 4], "foo"))
+
+print("defining example 3")
+eval(BSOMetaJSTranslator.match(BSOMetaJSParser.matchAll("ometa M { ones = {count=0} ({count++} 1 -> 2)* }", "srcElem"), "trans"))
+print("running example 3")
+print(M.matchAll([1, 1, 1, 1], "ones"))
+print("count = " + count)
+
Index: node_modules/ometa/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/package.json	(date 1607534369788)
+++ node_modules/ometa/package.json	(date 1607534369788)
@@ -0,0 +1,40 @@
+{
+  "_from": "ometa@0.2.2",
+  "_id": "ometa@0.2.2",
+  "_inBundle": false,
+  "_integrity": "sha1-9TxHNbptVq9aRrBN+3xDNMWW1E4=",
+  "_location": "/ometa",
+  "_phantomChildren": {},
+  "_requested": {
+    "type": "version",
+    "registry": true,
+    "raw": "ometa@0.2.2",
+    "name": "ometa",
+    "escapedName": "ometa",
+    "rawSpec": "0.2.2",
+    "saveSpec": null,
+    "fetchSpec": "0.2.2"
+  },
+  "_requiredBy": [
+    "/scss"
+  ],
+  "_resolved": "https://registry.npmjs.org/ometa/-/ometa-0.2.2.tgz",
+  "_shasum": "f53c4735ba6d56af5a46b04dfb7c4334c596d44e",
+  "_spec": "ometa@0.2.2",
+  "_where": "S:\\Kool 2020-2021\\alhorythm\\node_modules\\scss",
+  "bundleDependencies": false,
+  "contributors": [
+    {
+      "name": "Brian Mavity",
+      "email": "brian@brianmavity.com"
+    }
+  ],
+  "deprecated": false,
+  "description": "JavaScript Implementation of OMeta Parsing Language",
+  "engines": {
+    "node": ">= 0.2.0"
+  },
+  "main": "./index.js",
+  "name": "ometa",
+  "version": "0.2.2"
+}
Index: node_modules/ometa/ometa-rhino.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/ometa-rhino.js	(date 1323192249000)
+++ node_modules/ometa/ometa-rhino.js	(date 1323192249000)
@@ -0,0 +1,19 @@
+load("lib.js")
+load("ometa-base.js")
+load("parser.js")
+load("bs-js-compiler.js")
+load("bs-ometa-compiler.js")
+load("bs-ometa-optimizer.js")
+load("bs-ometa-js-compiler.js")
+
+alert = print
+
+translateCode = function(s) {
+  var translationError = function(m, i) { alert("Translation error - please tell Alex about this!"); throw fail },
+      tree             = BSOMetaJSParser.matchAll(s, "topLevel", undefined, function(m, i) {
+                                                                              throw objectThatDelegatesTo(fail, {errorPos: i}) })
+  return BSOMetaJSTranslator.match(tree, "trans", undefined, translationError)
+}
+
+ometa = function(s) { return eval(translateCode(s)) }
+
Index: node_modules/ometa/ometa-script-tag.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/ometa-script-tag.js	(date 1323192249000)
+++ node_modules/ometa/ometa-script-tag.js	(date 1323192249000)
@@ -0,0 +1,21 @@
+function translateCode(s) {
+  var translationError = function(m, i) { alert("Translation error - please tell Alex about this!"); throw fail },
+      tree             = BSOMetaJSParser.matchAll(s, "topLevel", undefined, function(m, i) {
+                                                                              throw objectThatDelegatesTo(fail, {errorPos: i}) })
+  return BSOMetaJSTranslator.match(tree, "trans", undefined, translationError)
+}
+   
+origOnload = window.onload
+window.onload = function() {
+  var scripts = document.getElementsByTagName("script")
+  for (var idx = 0; idx < scripts.length; idx++) {
+    var script = scripts[idx]
+    if (script.type === "text/x-ometa-js")
+      eval(translateCode(script.innerHTML))
+  }
+  if (typeof origOnload === "string")
+    eval(origOnload)
+  else if (typeof origOnload === "function")
+    origOnload()
+}
+
Index: node_modules/ometa/newLineTest.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/newLineTest.js	(date 1323192249000)
+++ node_modules/ometa/newLineTest.js	(date 1323192249000)
@@ -0,0 +1,35 @@
+var sys = require('sys'),
+    fs = require('fs'),
+    ometa = require(__dirname + '/index.js');
+    rawGrammar = "ometa T <: Parser { t = '\n' -> 'wtf', a = (t | anything)* }";
+
+var parse = function(grammar, stringToParse, rule) {
+  ometa.createParser(grammar, function(err, parser) {
+    if(err) {
+      sys.puts(err.inner.toString());
+    } else {
+      parser.parse('ican\'t\ndothis\n', 'a', function(err, result) {
+        if(err) {
+          console.log(err);
+        } else {
+          console.log(result);
+        }
+      });
+    }
+  });
+};
+
+var compare = function() {
+  var rawFile = fs.readFileSync(__dirname + '/newLineGrammar.ometa', 'utf8'),
+      file = rawFile.slice(1).replace(/\\n/g, '\n'),
+      maxChars = file.length >= rawGrammar.length ? file.length : rawGrammar.length,
+      i;
+  parse(file);
+  for(i = 0; i < maxChars; i += 1) {
+    console.log(file[i] + ' :: ' + rawGrammar[i]);
+  }
+};
+
+module.exports.parse = parse;
+parse(rawGrammar);
+compare();
Index: node_modules/ometa/Not_Quite_JS.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/Not_Quite_JS.txt	(date 1323192249000)
+++ node_modules/ometa/Not_Quite_JS.txt	(date 1323192249000)
@@ -0,0 +1,48 @@
+The language supported in this workspace is not quite JavaScript; it is rather a (large) subset of JavaScript, extended with some
+new syntax.
+
+
+One such extension allows string literals to be written as
+
+  '`' <identifier>   or   '#' <identifier>
+
+For example, instead of writing
+  "foo"
+you can write
+  `foo
+And of course,
+  "foo" == `foo && `foo == #foo
+
+I did this because I think parse trees, like
+  ["plus", ["lit", 2], ["lit", 5]]
+look better when you write them like this
+  [`plus, [`lit, 2], [`lit, 5]]
+
+
+Another extension is that string literals, as in Smalltalk, can span multiple lines, e.g.,
+
+" this whole thing
+is a string
+yay!
+"
+
+This is useful because it lets you put an entire program into a string (I do this in the Prolog, Logo, and MetaToo projects). Keep in mind that, as in Python, you can put escape sequences inside multi-line strings. So if you want a '\' character inside one of these guys, you need to type '\\'.
+
+And because it's usually annoying to have to escape double quotes inside these big strings, you can also write multi-line string literals in Python-like syntax, e.g.,
+
+"""
+1+2
+alert("hello world")
+"""
+
+ 
+-Alex
+
+------------------------------------------------------------------------------------------------------------------------------------
+
+Hey, Alex -- How about using a symbol that is less in one's face than "#"? What about tilde  ~  or  `  or underline, etc.?  -- Alan
+
+Hi Alan - this is funny, because the # was inspired by ST-80, heh heh... anyway, I like the idea of using ` instead. Try it now, it works. --- Alex
+
+Hi Alex -- I have always hated that convention in ST-80 (I was not around to protest when that went in). ST-80 had the interesting problem of moving from an environment at PARC in which any glyphs desired could be authored, displayed and printed, to the "outside world" in the early 80s in which none of those things could be done. So they had to go back to ASCII conventions and this was painful. Thanks for the change. --- Alan
+
Index: node_modules/ometa/ometa-base.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/ometa-base.js	(date 1323192249000)
+++ node_modules/ometa/ometa-base.js	(date 1323192249000)
@@ -0,0 +1,508 @@
+/*
+  Copyright (c) 2007-2010 Alessandro Warth <awarth@cs.ucla.edu>
+
+  Permission is hereby granted, free of charge, to any person
+  obtaining a copy of this software and associated documentation
+  files (the "Software"), to deal in the Software without
+  restriction, including without limitation the rights to use,
+  copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following
+  conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+  OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+/*
+  new syntax:
+    #foo and `foo	match the string object 'foo' (it's also accepted in my JS)
+    'abc'		match the string object 'abc'
+    'c'			match the string object 'c'
+    ``abc''		match the sequence of string objects 'a', 'b', 'c'
+    "abc"		token('abc')
+    [1 2 3]		match the array object [1, 2, 3]
+    foo(bar)		apply rule foo with argument bar
+    -> ...		semantic actions written in JS (see OMetaParser's atomicHostExpr rule)
+*/
+
+/*
+ometa M {
+  number = number:n digit:d -> { n * 10 + d.digitValue() }
+         | digit:d          -> { d.digitValue() }
+}
+
+translates to...
+
+M = objectThatDelegatesTo(OMeta, {
+  number: function() {
+            return this._or(function() {
+                              var n = this._apply("number"),
+                                  d = this._apply("digit")
+                              return n * 10 + d.digitValue()
+                            },
+                            function() {
+                              var d = this._apply("digit")
+                              return d.digitValue()
+                            }
+                           )
+          }
+})
+M.matchAll("123456789", "number")
+*/
+
+// the failure exception
+
+fail = { toString: function() { return "match failed" } }
+
+// streams and memoization
+
+function OMInputStream(hd, tl) {
+  this.memo = { }
+  this.lst  = tl.lst
+  this.idx  = tl.idx
+  this.hd   = hd
+  this.tl   = tl
+}
+OMInputStream.prototype.head = function() { return this.hd }
+OMInputStream.prototype.tail = function() { return this.tl }
+OMInputStream.prototype.type = function() { return this.lst.constructor }
+OMInputStream.prototype.upTo = function(that) {
+  var r = [], curr = this
+  while (curr != that) {
+    r.push(curr.head())
+    curr = curr.tail()
+  }
+  return this.type() == String ? r.join('') : r
+}
+
+function OMInputStreamEnd(lst, idx) {
+  this.memo = { }
+  this.lst = lst
+  this.idx = idx
+}
+OMInputStreamEnd.prototype = objectThatDelegatesTo(OMInputStream.prototype)
+OMInputStreamEnd.prototype.head = function() { throw fail }
+OMInputStreamEnd.prototype.tail = function() { throw fail }
+
+// This is necessary b/c in IE, you can't say "foo"[idx]
+Array.prototype.at  = function(idx) { return this[idx] }
+String.prototype.at = String.prototype.charAt
+
+function ListOMInputStream(lst, idx) {
+  this.memo = { }
+  this.lst  = lst
+  this.idx  = idx
+  this.hd   = lst.at(idx)
+}
+ListOMInputStream.prototype = objectThatDelegatesTo(OMInputStream.prototype)
+ListOMInputStream.prototype.head = function() { return this.hd }
+ListOMInputStream.prototype.tail = function() { return this.tl || (this.tl = makeListOMInputStream(this.lst, this.idx + 1)) }
+
+function makeListOMInputStream(lst, idx) { return new (idx < lst.length ? ListOMInputStream : OMInputStreamEnd)(lst, idx) }
+
+Array.prototype.toOMInputStream  = function() { return makeListOMInputStream(this, 0) }
+String.prototype.toOMInputStream = function() { return makeListOMInputStream(this, 0) }
+
+function makeOMInputStreamProxy(target) {
+  return objectThatDelegatesTo(target, {
+    memo:   { },
+    target: target,
+    tail:   function() { return makeOMInputStreamProxy(target.tail()) }
+  })
+}
+
+// Failer (i.e., that which makes things fail) is used to detect (direct) left recursion and memoize failures
+
+function Failer() { }
+Failer.prototype.used = false
+
+// the OMeta "class" and basic functionality
+
+OMeta = {
+  _apply: function(rule) {
+    var memoRec = this.input.memo[rule]
+    if (memoRec == undefined) {
+      var origInput = this.input,
+          failer    = new Failer()
+      if (this[rule] === undefined)
+        throw 'tried to apply undefined rule "' + rule + '"'
+      this.input.memo[rule] = failer
+      this.input.memo[rule] = memoRec = {ans: this[rule].call(this), nextInput: this.input}
+      if (failer.used) {
+        var sentinel = this.input
+        while (true) {
+          try {
+            this.input = origInput
+            var ans = this[rule].call(this)
+            if (this.input == sentinel)
+              throw fail
+            memoRec.ans       = ans
+            memoRec.nextInput = this.input
+          }
+          catch (f) {
+            if (f != fail)
+              throw f
+            break
+          }
+        }
+      }
+    }
+    else if (memoRec instanceof Failer) {
+      memoRec.used = true
+      throw fail
+    }
+    this.input = memoRec.nextInput
+    return memoRec.ans
+  },
+
+  // note: _applyWithArgs and _superApplyWithArgs are not memoized, so they can't be left-recursive
+  _applyWithArgs: function(rule) {
+    for (var idx = arguments.length - 1; idx > 0; idx--)
+      this._prependInput(arguments[idx])
+    return this[rule].call(this)
+  },
+  _superApplyWithArgs: function(recv, rule) {
+    for (var idx = arguments.length - 1; idx > 1; idx--)
+      recv._prependInput(arguments[idx])
+    return this[rule].call(recv)
+  },
+  _prependInput: function(v) {
+    this.input = new OMInputStream(v, this.input)
+  },
+
+  // if you want your grammar (and its subgrammars) to memoize parameterized rules, invoke this method on it:
+  memoizeParameterizedRules: function() {
+    this._prependInput = function(v) {
+      var newInput
+      if (isImmutable(v)) {
+        newInput = this.input[getTag(v)]
+        if (!newInput) {
+          newInput = new OMInputStream(v, this.input)
+          this.input[getTag(v)] = newInput
+        }
+      }
+      else newInput = new OMInputStream(v, this.input)
+      this.input = newInput
+    }
+    this._applyWithArgs = function(rule) {
+      for (var idx = arguments.length - 1; idx > 0; idx--)
+        this._prependInput(arguments[idx])
+      return this._apply(rule)
+    }
+  },
+
+  _pred: function(b) {
+    if (b)
+      return true
+    throw fail
+  },
+  _not: function(x) {
+    var origInput = this.input
+    try { x.call(this) }
+    catch (f) {
+      if (f != fail)
+        throw f
+      this.input = origInput
+      return true
+    }
+    throw fail
+  },
+  _lookahead: function(x) {
+    var origInput = this.input,
+        r         = x.call(this)
+    this.input = origInput
+    return r
+  },
+  _or: function() {
+    var origInput = this.input
+    for (var idx = 0; idx < arguments.length; idx++)
+      try { this.input = origInput; return arguments[idx].call(this) }
+      catch (f) {
+        if (f != fail)
+          throw f
+      }
+    throw fail
+  },
+  _xor: function(ruleName) {
+    var origInput = this.input, idx = 1, newInput, ans
+    while (idx < arguments.length) {
+      try {
+        this.input = origInput
+        ans = arguments[idx].call(this)
+        if (newInput)
+          throw 'more than one choice matched by "exclusive-OR" in ' + ruleName
+        newInput = this.input
+      }
+      catch (f) {
+        if (f != fail)
+          throw f
+      }
+      idx++
+    }
+    if (newInput) {
+      this.input = newInput
+      return ans
+    }
+    else
+      throw fail
+  },
+  disableXORs: function() {
+    this._xor = function(ruleName) {
+      var origInput = this.input
+      for (var idx = 1; idx < arguments.length; idx++)
+        try { this.input = origInput; return arguments[idx].call(this) }
+        catch (f) {
+          if (f != fail)
+            throw f
+        }
+      throw fail
+    }
+  },
+  _opt: function(x) {
+    var origInput = this.input, ans
+    try { ans = x.call(this) }
+    catch (f) {
+      if (f != fail)
+        throw f
+      this.input = origInput
+    }
+    return ans
+  },
+  _many: function(x) {
+    var ans = arguments[1] != undefined ? [arguments[1]] : []
+    while (true) {
+      var origInput = this.input
+      try { ans.push(x.call(this)) }
+      catch (f) {
+        if (f != fail)
+          throw f
+        this.input = origInput
+        break
+      }
+    }
+    return ans
+  },
+  _many1: function(x) { return this._many(x, x.call(this)) },
+  _form: function(x) {
+    var v = this._apply("anything")
+    if (!isSequenceable(v))
+      throw fail
+    var origInput = this.input
+    this.input = v.toOMInputStream()
+    var r = x.call(this)
+    this._apply("end")
+    this.input = origInput
+    return v
+  },
+  _consumedBy: function(x) {
+    var origInput = this.input
+    x.call(this)
+    return origInput.upTo(this.input)
+  },
+  _idxConsumedBy: function(x) {
+    var origInput = this.input
+    x.call(this)
+    return {fromIdx: origInput.idx, toIdx: this.input.idx}
+  },
+  _interleave: function(mode1, part1, mode2, part2 /* ..., moden, partn */) {
+    var currInput = this.input, ans = []
+    for (var idx = 0; idx < arguments.length; idx += 2)
+      ans[idx / 2] = (arguments[idx] == "*" || arguments[idx] == "+") ? [] : undefined
+    while (true) {
+      var idx = 0, allDone = true
+      while (idx < arguments.length) {
+        if (arguments[idx] != "0")
+          try {
+            this.input = currInput
+            switch (arguments[idx]) {
+              case "*": ans[idx / 2].push(arguments[idx + 1].call(this));                       break
+              case "+": ans[idx / 2].push(arguments[idx + 1].call(this)); arguments[idx] = "*"; break
+              case "?": ans[idx / 2] =    arguments[idx + 1].call(this);  arguments[idx] = "0"; break
+              case "1": ans[idx / 2] =    arguments[idx + 1].call(this);  arguments[idx] = "0"; break
+              default:  throw "invalid mode '" + arguments[idx] + "' in OMeta._interleave"
+            }
+            currInput = this.input
+            break
+          }
+          catch (f) {
+            if (f != fail)
+              throw f
+            // if this (failed) part's mode is "1" or "+", we're not done yet
+            allDone = allDone && (arguments[idx] == "*" || arguments[idx] == "?")
+          }
+        idx += 2
+      }
+      if (idx == arguments.length) {
+        if (allDone)
+          return ans
+        else
+          throw fail
+      }
+    }
+  },
+  _currIdx: function() { return this.input.idx },
+
+  // some basic rules
+  anything: function() {
+    var r = this.input.head()
+    this.input = this.input.tail()
+    return r
+  },
+  end: function() {
+    return this._not(function() { return this._apply("anything") })
+  },
+  pos: function() {
+    return this.input.idx
+  },
+  empty: function() { return true },
+  apply: function() {
+    var r = this._apply("anything")
+    return this._apply(r)
+  },
+  foreign: function() {
+    var g   = this._apply("anything"),
+        r   = this._apply("anything"),
+        gi  = objectThatDelegatesTo(g, {input: makeOMInputStreamProxy(this.input)})
+        gi.initialize();
+    var ans = gi._apply(r)
+    this.input = gi.input.target
+    return ans
+  },
+
+  //  some useful "derived" rules
+  exactly: function() {
+    var wanted = this._apply("anything")
+    if (wanted === this._apply("anything"))
+      return wanted
+    throw fail
+  },
+  "true": function() {
+    var r = this._apply("anything")
+    this._pred(r === true)
+    return r
+  },
+  "false": function() {
+    var r = this._apply("anything")
+    this._pred(r === false)
+    return r
+  },
+  "undefined": function() {
+    var r = this._apply("anything")
+    this._pred(r === undefined)
+    return r
+  },
+  number: function() {
+    var r = this._apply("anything")
+    this._pred(typeof r === "number")
+    return r
+  },
+  string: function() {
+    var r = this._apply("anything")
+    this._pred(typeof r === "string")
+    return r
+  },
+  "char": function() {
+    var r = this._apply("anything")
+    this._pred(typeof r === "string" && r.length == 1)
+    return r
+  },
+  space: function() {
+    var r = this._apply("char")
+    this._pred(r.charCodeAt(0) <= 32)
+    return r
+  },
+  spaces: function() {
+    return this._many(function() { return this._apply("space") })
+  },
+  digit: function() {
+    var r = this._apply("char")
+    this._pred(r >= "0" && r <= "9")
+    return r
+  },
+  lower: function() {
+    var r = this._apply("char")
+    this._pred(r >= "a" && r <= "z")
+    return r
+  },
+  upper: function() {
+    var r = this._apply("char")
+    this._pred(r >= "A" && r <= "Z")
+    return r
+  },
+  letter: function() {
+    return this._or(function() { return this._apply("lower") },
+                    function() { return this._apply("upper") })
+  },
+  letterOrDigit: function() {
+    return this._or(function() { return this._apply("letter") },
+                    function() { return this._apply("digit")  })
+  },
+  firstAndRest: function()  {
+    var first = this._apply("anything"),
+        rest  = this._apply("anything")
+     return this._many(function() { return this._apply(rest) }, this._apply(first))
+  },
+  seq: function() {
+    var xs = this._apply("anything")
+    for (var idx = 0; idx < xs.length; idx++)
+      this._applyWithArgs("exactly", xs.at(idx))
+    return xs
+  },
+  notLast: function() {
+    var rule = this._apply("anything"),
+        r    = this._apply(rule)
+    this._lookahead(function() { return this._apply(rule) })
+    return r
+  },
+
+  initialize: function() { },
+  // match and matchAll are a grammar's "public interface"
+  _genericMatch: function(input, rule, args, matchFailed) {
+    if (args == undefined)
+      args = []
+    var realArgs = [rule]
+    for (var idx = 0; idx < args.length; idx++)
+      realArgs.push(args[idx])
+    var m = objectThatDelegatesTo(this, {input: input})
+    m.initialize()
+    try { return realArgs.length == 1 ? m._apply.call(m, realArgs[0]) : m._applyWithArgs.apply(m, realArgs) }
+    catch (f) {
+      if (f == fail && matchFailed != undefined) {
+        var input = m.input
+        if (input.idx != undefined) {
+          while (input.tl != undefined && input.tl.idx != undefined)
+            input = input.tl
+          input.idx--
+        }
+        return matchFailed(m, input.idx)
+      }
+      throw f
+    }
+  },
+  match: function(obj, rule, args, matchFailed) {
+    return this._genericMatch([obj].toOMInputStream(),    rule, args, matchFailed)
+  },
+  matchAll: function(listyObj, rule, args, matchFailed) {
+    return this._genericMatch(listyObj.toOMInputStream(), rule, args, matchFailed)
+  },
+  createInstance: function() {
+    var m = objectThatDelegatesTo(this)
+    m.initialize()
+    m.matchAll = function(listyObj, aRule) {
+      m.input = listyObj.toOMInputStream()
+      return m._apply(aRule)
+    }
+    return m
+  }
+}
+
Index: node_modules/ometa/ometa-node.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/ometa-node.js	(date 1323192249000)
+++ node_modules/ometa/ometa-node.js	(date 1323192249000)
@@ -0,0 +1,23 @@
+var lib = require("./lib");
+require("./ometa-base")
+require("./parser")
+require("./bs-js-compiler")
+require("./bs-ometa-compiler")
+require("./bs-ometa-optimizer")
+require("./bs-ometa-js-compiler")
+
+var translateCode = function(s) {
+  var translationError = function(m, i) { alert("Translation error - please tell Alex about this!"); throw fail },
+      tree             = BSOMetaJSParser.matchAll(s, "topLevel", undefined, function(m, i) { throw objectThatDelegatesTo(fail, {errorPos: i}) })
+  return BSOMetaJSTranslator.match(tree, "trans", undefined, translationError)
+}
+
+var parse = function(grammarString) {
+  var parser = eval(translateCode(grammarString));
+  return function(stringToParse, rule) {
+    return eval(parser.matchAll(stringToParse, rule));
+  };
+};
+
+
+module.exports = parse;
Index: node_modules/ometa/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/index.js	(date 1323192249000)
+++ node_modules/ometa/index.js	(date 1323192249000)
@@ -0,0 +1,20 @@
+var ometa = require('./ometa-node'); 
+
+var createParser = function(grammar, parserCallback) {
+  var parser;
+  try {
+    parser = ometa(grammar);
+    parserCallback(null, {
+      parse: function(code, rule, callback) {
+        callback(null, parser(code, rule));
+      }
+    });
+  }
+  catch(err) {
+    parserCallback({
+      inner: err
+    });
+  }
+};
+
+module.exports.createParser = createParser;
Index: node_modules/ometa/lib.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/lib.js	(date 1323192249000)
+++ node_modules/ometa/lib.js	(date 1323192249000)
@@ -0,0 +1,183 @@
+/*
+  Copyright (c) 2007-2010 Alessandro Warth <awarth@cs.ucla.edu>
+
+  Permission is hereby granted, free of charge, to any person
+  obtaining a copy of this software and associated documentation
+  files (the "Software"), to deal in the Software without
+  restriction, including without limitation the rights to use,
+  copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following
+  conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+  OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+// try to use StringBuffer instead of string concatenation to improve performance
+
+function StringBuffer() {
+  this.strings = []
+  for (var idx = 0; idx < arguments.length; idx++)
+    this.nextPutAll(arguments[idx])
+}
+StringBuffer.prototype.nextPutAll = function(s) { this.strings.push(s) }
+StringBuffer.prototype.contents   = function()  { return this.strings.join("") }
+String.prototype.writeStream      = function() { return new StringBuffer(this) }
+
+// make Arrays print themselves sensibly
+
+printOn = function(x, ws) {
+  if (x === undefined || x === null)
+    ws.nextPutAll("" + x)
+  else if (x.constructor === Array) {
+    ws.nextPutAll("[")
+    for (var idx = 0; idx < x.length; idx++) {
+      if (idx > 0)
+        ws.nextPutAll(", ")
+      printOn(x[idx], ws)
+    }
+    ws.nextPutAll("]")
+  }
+  else
+    ws.nextPutAll(x.toString())
+}
+
+Array.prototype.toString = function() { var ws = "".writeStream(); printOn(this, ws); return ws.contents() }
+
+// delegation
+
+objectThatDelegatesTo = function(x, props) {
+  var f = function() { }
+  f.prototype = x
+  var r = new f()
+  for (var p in props)
+    if (props.hasOwnProperty(p))
+      r[p] = props[p]
+  return r
+}
+
+// some reflective stuff
+
+ownPropertyNames = function(x) {
+  var r = []
+  for (name in x)
+    if (x.hasOwnProperty(name))
+      r.push(name)
+  return r
+}
+
+isImmutable = function(x) {
+   return x === null || x === undefined || typeof x === "boolean" || typeof x === "number" || typeof x === "string"
+}
+
+String.prototype.digitValue  = function() { return this.charCodeAt(0) - "0".charCodeAt(0) }
+
+isSequenceable = function(x) { return typeof x == "string" || x.constructor === Array }
+
+// some functional programming stuff
+
+if(!Array.prototype.map) {
+  Array.prototype.map = function(f) {
+    var r = []
+    for (var idx = 0; idx < this.length; idx++)
+      r[idx] = f(this[idx])
+    return r
+  }
+}
+
+Array.prototype.reduce = function(f, z) {
+  var r = z
+  for (var idx = 0; idx < this.length; idx++)
+    r = f(r, this[idx])
+  return r
+}
+
+Array.prototype.delimWith = function(d) {
+  return this.reduce(
+    function(xs, x) {
+      if (xs.length > 0)
+        xs.push(d)
+      xs.push(x)
+      return xs
+    },
+   [])
+}
+
+// Squeak's ReadStream, kind of
+
+function ReadStream(anArrayOrString) {
+  this.src = anArrayOrString
+  this.pos = 0
+}
+ReadStream.prototype.atEnd = function() { return this.pos >= this.src.length }
+ReadStream.prototype.next  = function() { return this.src.at(this.pos++) }
+
+// escape characters
+
+escapeStringFor = new Object()
+for (var c = 0; c < 256; c++)
+  escapeStringFor[c] = String.fromCharCode(c)
+escapeStringFor["\\".charCodeAt(0)] = "\\\\"
+escapeStringFor['"'.charCodeAt(0)]  = '\\"'
+escapeStringFor["'".charCodeAt(0)]  = "\\'"
+escapeStringFor["\r".charCodeAt(0)] = "\\r"
+escapeStringFor["\n".charCodeAt(0)] = "\\n"
+escapeStringFor["\t".charCodeAt(0)] = "\\t"
+escapeChar = function(c) {
+  var charCode = c.charCodeAt(0)
+  return charCode > 255 ? String.fromCharCode(charCode) : escapeStringFor[charCode]
+}
+
+function unescape(s) {
+  if (s.charAt(0) == '\\')
+    switch (s.charAt(1)) {
+      case '\\': return '\\'
+      case 'r':  return '\r'
+      case 'n':  return '\n'
+      case 't':  return '\t'
+      default:   return s.charAt(1)
+    }
+  else
+    return s
+}
+
+String.prototype.toProgramString = function() {
+  var ws = "\"".writeStream()
+  for (var idx = 0; idx < this.length; idx++)
+    ws.nextPutAll(escapeChar(this.charAt(idx)))
+  ws.nextPutAll("\"")
+  return ws.contents()
+}
+
+// C-style tempnam function
+
+function tempnam(s) { return (s ? s : "_tmpnam_") + tempnam.n++ }
+tempnam.n = 0
+
+// unique tags for objects (useful for making "hash tables")
+
+getTag = (function() {
+  var numIdx = 0
+  return function(x) {
+    if (x === null || x === undefined)
+      return x
+    switch (typeof x) {
+      case "boolean": return x == true ? "Btrue" : "Bfalse"
+      case "string":  return "S" + x
+      case "number":  return "N" + x
+      default:        return x.hasOwnProperty("_id_") ? x._id_ : x._id_ = "R" + numIdx++
+    }
+  }
+})()
+
+module.exports.StringBuffer = StringBuffer;
Index: node_modules/ometa/license.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/license.md	(date 1323192249000)
+++ node_modules/ometa/license.md	(date 1323192249000)
@@ -0,0 +1,45 @@
+Copyright (c) 2010 Brian Mavity <brian@brianmavity.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+Except as contained in this notice, the name(s) of the above copyright
+holders shall not be used in advertising or otherwise to promote the sale,
+use or other dealings in this Software without prior written authorization.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+
+
+Copyright (c) 2007-2010 Alessandro Warth <awarth@cs.ucla.edu>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
Index: node_modules/ometa/bs-project-list-parser.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-project-list-parser.js	(date 1323192249000)
+++ node_modules/ometa/bs-project-list-parser.js	(date 1323192249000)
@@ -0,0 +1,3 @@
+ProjectListParser=objectThatDelegatesTo(BSJSParser,{
+"proj":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("spaces");return this._apply("iName")}).call(this)},
+"projs":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return (function(){x=this._apply("proj");xs=this._many((function(){return (function(){this._apply("spaces");this._applyWithArgs("exactly",",");return this._apply("proj")}).call(this)}));return [x].concat(xs)}).call(this)}})
Index: node_modules/scss/examples/input.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/input.css	(date 1607534375018)
+++ node_modules/scss/examples/input.css	(date 1607534375018)
@@ -0,0 +1,10 @@
+div {
+  height: #d3e115; }
+  div .error {
+    background: #234567;
+    color: green; }
+
+a:hover {
+  color: #234567; }
+
+/*# sourceMappingURL=input.css.map */
Index: node_modules/ometa/bs-ometa-optimizer.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-ometa-optimizer.txt	(date 1323192249000)
+++ node_modules/ometa/bs-ometa-optimizer.txt	(date 1323192249000)
@@ -0,0 +1,93 @@
+// TODO: turn off the "seq" inliner when G.seq !== OMeta.seq (will require some refactoring)
+// TODO: add a factorizing optimization (will make jumptables more useful)
+
+ometa BSNullOptimization {
+  setHelped = !(this._didSomething = true),
+  helped    = ?this._didSomething,
+  trans     = [:t ?(this[t] != undefined) apply(t):ans] -> ans,
+  optimize  = trans:x helped                         -> x,
+
+  App        :rule anything*:args          -> ['App', rule].concat(args),
+  Act        :expr                         -> ['Act', expr],
+  Pred       :expr                         -> ['Pred', expr],
+  Or         trans*:xs                     -> ['Or'].concat(xs),
+  XOr        trans*:xs                     -> ['XOr'].concat(xs),
+  And        trans*:xs                     -> ['And'].concat(xs),
+  Opt        trans:x                       -> ['Opt',  x],
+  Many       trans:x                       -> ['Many',  x],
+  Many1      trans:x                       -> ['Many1', x],
+  Set        :n trans:v                    -> ['Set', n, v],
+  Not        trans:x                       -> ['Not',       x],
+  Lookahead  trans:x                       -> ['Lookahead', x],
+  Form       trans:x                       -> ['Form',      x],
+  ConsBy     trans:x                       -> ['ConsBy',    x],
+  IdxConsBy  trans:x                       -> ['IdxConsBy', x],
+  JumpTable  ([:c trans:e] -> [c, e])*:ces -> ['JumpTable'].concat(ces),
+  Interleave ([:m trans:p] -> [m, p])*:xs  -> ['Interleave'].concat(xs),
+  Rule       :name :ls trans:body          -> ['Rule', name, ls, body]
+}
+BSNullOptimization.initialize = function() { this._didSomething = false }
+
+ometa BSAssociativeOptimization <: BSNullOptimization {
+  And trans:x end           setHelped -> x,
+  And transInside('And'):xs           -> ['And'].concat(xs),
+  Or  trans:x end           setHelped -> x,
+  Or  transInside('Or'):xs            -> ['Or'].concat(xs),
+  XOr trans:x end           setHelped -> x,
+  XOr transInside('XOr'):xs           -> ['XOr'].concat(xs),
+
+  transInside :t = [exactly(t) transInside(t):xs] transInside(t):ys setHelped -> xs.concat(ys)
+                 | trans:x                        transInside(t):xs           -> [x].concat(xs)
+                 |                                                            -> []
+}
+
+ometa BSSeqInliner <: BSNullOptimization {
+  App        = 'seq' :s end seqString(s):cs setHelped -> ['And'].concat(cs).concat([['Act', s]])
+             | :rule anything*:args                   -> ['App', rule].concat(args),
+  inlineChar = BSOMetaParser.eChar:c ~end             -> ['App', 'exactly', c.toProgramString()],
+  seqString  = &(:s ?(typeof s === 'string'))
+                 ( ['"'  inlineChar*:cs '"' ]         -> cs
+                 | ['\'' inlineChar*:cs '\'']         -> cs
+                 )
+}
+
+JumpTable = function(choiceOp, choice) {
+  this.choiceOp = choiceOp
+  this.choices = {}
+  this.add(choice)
+}
+JumpTable.prototype.add = function(choice) {
+  var c = choice[0], t = choice[1]
+  if (this.choices[c]) {
+    if (this.choices[c][0] == this.choiceOp)
+      this.choices[c].push(t)
+    else
+      this.choices[c] = [this.choiceOp, this.choices[c], t]
+  }
+  else
+    this.choices[c] = t
+}
+JumpTable.prototype.toTree = function() {
+  var r = ['JumpTable'], choiceKeys = ownPropertyNames(this.choices)
+  for (var i = 0; i < choiceKeys.length; i += 1)
+    r.push([choiceKeys[i], this.choices[choiceKeys[i]]])
+  return r
+}
+ometa BSJumpTableOptimization <: BSNullOptimization {
+  Or  (jtChoices('Or')  | trans)*:cs -> ['Or'].concat(cs),
+  XOr (jtChoices('XOr') | trans)*:cs -> ['XOr'].concat(cs),
+  quotedString  = &string [ '"'  (BSOMetaParser.eChar:c ~end -> c)*:cs '"'
+                          | '\'' (BSOMetaParser.eChar:c ~end -> c)*:cs '\'']               -> cs.join(''),
+  jtChoice      = ['And' ['App' 'exactly' quotedString:x] anything*:rest]                  -> [x, ['And'].concat(rest)]
+                |        ['App' 'exactly' quotedString:x]                                  -> [x, ['Act', x.toProgramString()]],
+  jtChoices :op = jtChoice:c {new JumpTable(op, c)}:jt (jtChoice:c {jt.add(c)})* setHelped -> jt.toTree()
+}
+
+ometa BSOMetaOptimizer {
+  optimizeGrammar = ['Grammar' :n :sn optimizeRule*:rs]          -> ['Grammar', n, sn].concat(rs),
+  optimizeRule    = :r (BSSeqInliner.optimize(r):r | empty)
+                       ( BSAssociativeOptimization.optimize(r):r
+                       | BSJumpTableOptimization.optimize(r):r
+                       )*                                        -> r
+}
+
Index: node_modules/ometa/index.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/index.html	(date 1323192249000)
+++ node_modules/ometa/index.html	(date 1323192249000)
@@ -0,0 +1,166 @@
+<!--
+  Copyright (c) 2007-2010 Alessandro Warth <awarth@cs.ucla.edu>
+
+  Permission is hereby granted, free of charge, to any person
+  obtaining a copy of this software and associated documentation
+  files (the "Software"), to deal in the Software without
+  restriction, including without limitation the rights to use,
+  copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following
+  conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+  OTHER DEALINGS IN THE SOFTWARE.
+!-->
+
+<html>
+  <head>
+    <title>OMeta/JS 2.0 Workspace</title>
+    <script src="prototype.js"></script>
+    <script src="prototype-fix.js"></script>
+    <script src="lib.js"></script>
+    <script src="ometa-base.js"></script>
+    <script src="parser.js"></script>
+    <script src="bs-js-compiler.js"></script>
+    <script src="bs-ometa-compiler.js"></script>
+    <script src="bs-ometa-optimizer.js"></script>
+    <script src="bs-ometa-js-compiler.js"></script>
+    <script src="bs-project-list-parser.js"></script>
+    <script src="workspace.js"></script>
+    <script src="wiki.js"></script>
+    <script>
+
+function toggleVisible(id) {
+  var style = document.getElementById(id).style
+  style.visibility = style.visibility == "hidden" ? "visible" : "hidden"
+  style.display    = style.display    == "block"  ? "none"    : "block"
+}
+
+function initializeThisPage() {
+  $('workspaceForm').source.onkeydown = onShortCutKey
+  var makeProjectSelector = function(id) {
+    $(id + "Home").innerHTML =
+      "<select id=" + id +
+      " onChange='loadProject(this.options[this.selectedIndex].value)'><option value=''>(nevermind)</option></select>"
+  }
+  var addOption = function(toId, x) {
+    var option = document.createElement("option")
+    option.innerHTML = x.replace(/_/g, " ")
+    option.value     = x
+    $(toId).appendChild(option)
+  }
+  makeProjectSelector('infoSelector')
+  addOption('infoSelector', 'Sample_Project')
+  addOption('infoSelector', 'Not_Quite_JS')
+  addOption('infoSelector', 'Things_You_Should_Know')
+  addOption('infoSelector', 'OMeta_Tutorial')
+  addOption('infoSelector', 'Memoizing_Parameterized_Rules')
+  addOption('infoSelector', 'Project_Listing')
+  makeProjectSelector('projectSelector')
+  var ps = $('projectSelector')
+  try {
+    var projects = ProjectListParser.matchAll(readFile("Project_Listing"), "projs")
+    for (var idx = 0; idx < projects.length; idx++)
+      addOption('projectSelector', projects[idx])
+  }
+  catch (e) { }
+  $('workspaceForm').source.value      = $('workspaceForm').source.origValue = ''
+  $('workspaceForm').translation.value = ''
+  $('workspaceForm').transcript.value  = ''
+  loadProject()
+}
+
+saveIt = saveProject
+
+if (!document.location.hash)
+  document.location.hash = "#Sample_Project"
+titleRest = " - <nobr><span title='In case you are wondering, this is\n" +
+                                  "(OMeta/JS) 2.0, not OMeta/(JS 2.0).\n" +
+                                  "In other words, it has nothing to do\n" +
+                                  "with JS 2 / EcmaScript 2.'>OMeta/JS 2.0</span> Workspace</nobr>"
+
+function translateCode(s) {
+  var translationError = function(m, i) { alert("Translation error - please tell Alex about this!"); throw fail },
+      tree             = BSOMetaJSParser.matchAll(s, "topLevel", undefined, function(m, i) { throw objectThatDelegatesTo(fail, {errorPos: i}) })
+  return BSOMetaJSTranslator.match(tree, "trans", undefined, translationError)
+}
+
+function include(fileName) {
+  return eval(readFile(fileName))
+}
+
+    </script>
+  </head>
+  <body onLoad="initializeThisPage()">
+    <table border=0 align=right>
+      <tr><td align=right><b>important info: </b></td><td><span id=infoSelectorHome></span></td></tr>
+      <tr><td align=right><b>go to project: </b></td><td><span id=projectSelectorHome></span></td></tr>
+      <tr><td colspan=2 align=right><input type=button value="previous versions of this project" onClick="document.location = 'http://www.tinlizzie.org/ometa-js/websvn/log.php?repname=ometa-js-projects&path=%2F' + document.location.hash.substring(1) + '.txt&rev=0&sc=0&isdir=0'"><br>
+      </td></tr>
+   </table>
+    <table border=0><tr><td><h2 id=title>OMeta/JS 2.0 Workspace<!-- <small><font color=lightgray>(not to be confused with JS 2 / EcmaScript 4)</font></small>--></h2></td></tr></table>
+
+
+    <b>Instructions</b>
+    <input type=button value="+/-" onClick="toggleVisible('instructions')">
+    <br>
+    <div id=instructions style="visibility: visible; display: block">
+      <table bgcolor=#f9f9f9 cellpadding=4
+             style="border: 1px solid #333333; padding: .2em .2em .2em .2em; margin-bottom: .4em; margin-top: .1em">
+        <tr><td>
+        The text area below (<b>source</b>) works like a Smalltalk workspace:
+        <bl><li>
+        To evaluate some code, just select it and press the <input type=button value="do it" onClick="doIt()"> button.
+        </li><li>
+        Pressing <input type=button value="do it" onClick="doIt()"> without a selection evaluates the line that the cursor is on.
+        </li><li>
+        <input type=button value="print it" onClick="printIt()"> is like <input type=button value="do it" onClick="doIt()">,
+        but it also prints the result.
+        </li></bl>
+        Also, you can press <input type=button value="save it" onClick="saveIt()"> to save the current project.
+      </td></tr></table>
+    </div>
+    <b><span title="A useful place to add new HTMLElements - see Canvas project for an example">Play Area</span></b>
+    <input type=button value="+/-" onClick="toggleVisible('playArea')">
+    <br>
+    <div id=playArea style="visibility: visible; display: block"></div>
+    <form id=workspaceForm>
+      <b>Source</b>
+      <input type=button value="+/-" onClick="toggleVisible('source')">
+      <br>
+      <div id=source style="visibility: visible; display: block">
+        <textarea cols=132 rows=24 name=source style="font-family:monaco, monospace; font-size: 10pt"></textarea><br>
+        <input type=button value="print it (ctrl+p)"  onClick="printIt()"     style="margin-bottom: .4em">
+        <input type=button value="do it (ctrl+d)"     onClick="doIt()"        style="margin-bottom: .4em">
+        <input type=button value="save it (ctrl + s)" onClick="saveProject()" style="margin-bottom: .4em"><br>
+      </div>
+      <b><span title="Shows the JavaScript translation of the last thing that was evaluated above">Translation</span></b>
+      <input type=button value="+/-" onClick="toggleVisible('translation')">
+      <br>
+      <div id=translation style="visibility: hidden; display: none">
+        <textarea cols=132 rows=4 name=translation style="font-family:monaco, monospace; font-size: 10pt; margin-bottom: .4em">
+        </textArea>
+      </div>
+
+      <b>Transcript</b>
+      <input type=button value="+/-" onClick="toggleVisible('transcript')">
+      <br>
+      <div id=transcript style="visibility: hidden; display: none">
+        <textarea cols=132 rows=4 name=transcript
+                  style="font-family:monaco, monospace; font-size: 10pt; margin-bottom: .4em"></textArea>
+      </div>
+    </form>
+    To learn more about OMeta, click <a href=http://www.tinlizzie.org/ometa/>here</a>.<br>
+  </body>
+</html>
+
Index: node_modules/ometa/bs-project-list-parser.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-project-list-parser.txt	(date 1323192249000)
+++ node_modules/ometa/bs-project-list-parser.txt	(date 1323192249000)
@@ -0,0 +1,5 @@
+ometa ProjectListParser <: BSJSParser {
+  proj  = spaces iName,
+  projs = proj:x (spaces ',' proj)*:xs -> [x].concat(xs)
+}
+
Index: .idea/modules.xml
===================================================================
--- .idea/modules.xml	(date 1607504959948)
+++ .idea/modules.xml	(date 1607504959948)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/alhorythm.iml" filepath="$PROJECT_DIR$/.idea/alhorythm.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: node_modules/ometa/bs-js-compiler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-js-compiler.js	(date 1323192249000)
+++ node_modules/ometa/bs-js-compiler.js	(date 1323192249000)
@@ -0,0 +1,81 @@
+{BSJSParser=objectThatDelegatesTo(Parser,{
+"fromTo":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return (function(){x=this._apply("anything");y=this._apply("anything");this._applyWithArgs("seq",x);this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("seq",y)}));return this._apply("char")}).call(this)}));return this._applyWithArgs("seq",y)}).call(this)},
+"space":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return Parser._superApplyWithArgs(this,'space')}),(function(){return this._applyWithArgs("fromTo","//","\n")}),(function(){return this._applyWithArgs("fromTo","/*","*/")}))},
+"nameFirst":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("letter")}),(function(){return (function(){switch(this._apply('anything')){case "$":return "$";case "_":return "_";default: throw fail}}).call(this)}))},
+"nameRest":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("nameFirst")}),(function(){return this._apply("digit")}))},
+"iName":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._applyWithArgs("firstAndRest","nameFirst","nameRest");return r.join("")}).call(this)},
+"isKeyword":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("anything");return this._pred(BSJSParser._isKeyword(x))}).call(this)},
+"name":function(){var $elf=this,_fromIdx=this.input.idx,n;return (function(){n=this._apply("iName");this._not((function(){return this._applyWithArgs("isKeyword",n)}));return ["name",((n == "self")?"$elf":n)]}).call(this)},
+"keyword":function(){var $elf=this,_fromIdx=this.input.idx,k;return (function(){k=this._apply("iName");this._applyWithArgs("isKeyword",k);return [k,k]}).call(this)},
+"hexDigit":function(){var $elf=this,_fromIdx=this.input.idx,x,v;return (function(){x=this._apply("char");v=this["hexDigits"].indexOf(x.toLowerCase());this._pred((v >= (0)));return v}).call(this)},
+"hexLit":function(){var $elf=this,_fromIdx=this.input.idx,n,d;return this._or((function(){return (function(){n=this._apply("hexLit");d=this._apply("hexDigit");return ((n * (16)) + d)}).call(this)}),(function(){return this._apply("hexDigit")}))},
+"number":function(){var $elf=this,_fromIdx=this.input.idx,n,ws,fs;return this._or((function(){return (function(){switch(this._apply('anything')){case "0":return (function(){this._applyWithArgs("exactly","x");"0x";n=this._apply("hexLit");return ["number",n]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){ws=this._many1((function(){return this._apply("digit")}));fs=this._or((function(){return (function(){switch(this._apply('anything')){case ".":return this._many1((function(){return this._apply("digit")}));default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return []}).call(this)}));return ["number",parseFloat(((ws.join("") + ".") + fs.join("")))]}).call(this)}))},
+"escapeChar":function(){var $elf=this,_fromIdx=this.input.idx,c;return (function(){this._applyWithArgs("exactly","\\");c=this._apply("char");return unescape(("\\" + c))}).call(this)},
+"str":function(){var $elf=this,_fromIdx=this.input.idx,cs,cs,cs,n;return this._or((function(){return (function(){switch(this._apply('anything')){case "\"":return this._or((function(){return (function(){switch(this._apply('anything')){case "\"":return (function(){this._applyWithArgs("exactly","\"");"\"\"\"";cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return (function(){this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");return "\"\"\""}).call(this)}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");"\"\"\"";return ["string",cs.join("")]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\"")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\"");return ["string",cs.join("")]}).call(this)}));case "\'":return (function(){cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\'")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\'");return ["string",cs.join("")]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){(function(){switch(this._apply('anything')){case "#":return "#";case "`":return "`";default: throw fail}}).call(this);n=this._apply("iName");return ["string",n]}).call(this)}))},
+"special":function(){var $elf=this,_fromIdx=this.input.idx,s;return (function(){s=(function(){switch(this._apply('anything')){case "(":return "(";case ")":return ")";case "{":return "{";case "}":return "}";case "[":return "[";case "]":return "]";case ",":return ",";case ";":return ";";case "?":return "?";case ":":return ":";case "!":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "!==";default: throw fail}}).call(this)}),(function(){return "!="}));default: throw fail}}).call(this)}),(function(){return "!"}));case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "===";default: throw fail}}).call(this)}),(function(){return "=="}));default: throw fail}}).call(this)}),(function(){return "="}));case ">":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return ">=";default: throw fail}}).call(this)}),(function(){return ">"}));case "<":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "<=";default: throw fail}}).call(this)}),(function(){return "<"}));case "+":return this._or((function(){return (function(){switch(this._apply('anything')){case "+":return "++";case "=":return "+=";default: throw fail}}).call(this)}),(function(){return "+"}));case "-":return this._or((function(){return (function(){switch(this._apply('anything')){case "-":return "--";case "=":return "-=";default: throw fail}}).call(this)}),(function(){return "-"}));case "*":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "*=";default: throw fail}}).call(this)}),(function(){return "*"}));case "/":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "/=";default: throw fail}}).call(this)}),(function(){return "/"}));case "%":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "%=";default: throw fail}}).call(this)}),(function(){return "%"}));case "&":return (function(){switch(this._apply('anything')){case "&":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "&&=";default: throw fail}}).call(this)}),(function(){return "&&"}));default: throw fail}}).call(this);case "|":return (function(){switch(this._apply('anything')){case "|":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "||=";default: throw fail}}).call(this)}),(function(){return "||"}));default: throw fail}}).call(this);case ".":return ".";default: throw fail}}).call(this);return [s,s]}).call(this)},
+"tok":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("spaces");return this._or((function(){return this._apply("name")}),(function(){return this._apply("keyword")}),(function(){return this._apply("number")}),(function(){return this._apply("str")}),(function(){return this._apply("special")}))}).call(this)},
+"toks":function(){var $elf=this,_fromIdx=this.input.idx,ts;return (function(){ts=this._many((function(){return this._apply("token")}));this._apply("spaces");this._apply("end");return ts}).call(this)},
+"token":function(){var $elf=this,_fromIdx=this.input.idx,tt,t;return (function(){tt=this._apply("anything");t=this._apply("tok");this._pred((t[(0)] == tt));return t[(1)]}).call(this)},
+"spacesNoNl":function(){var $elf=this,_fromIdx=this.input.idx;return this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\n")}));return this._apply("space")}).call(this)}))},
+"expr":function(){var $elf=this,_fromIdx=this.input.idx,e,t,f,rhs,rhs,rhs,rhs,rhs,rhs,rhs,rhs;return (function(){e=this._apply("orExpr");return this._or((function(){return (function(){this._applyWithArgs("token","?");t=this._apply("expr");this._applyWithArgs("token",":");f=this._apply("expr");return ["condExpr",e,t,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","=");rhs=this._apply("expr");return ["set",e,rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","+=");rhs=this._apply("expr");return ["mset",e,"+",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","-=");rhs=this._apply("expr");return ["mset",e,"-",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","*=");rhs=this._apply("expr");return ["mset",e,"*",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","/=");rhs=this._apply("expr");return ["mset",e,"/",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","%=");rhs=this._apply("expr");return ["mset",e,"%",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","&&=");rhs=this._apply("expr");return ["mset",e,"&&",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","||=");rhs=this._apply("expr");return ["mset",e,"||",rhs]}).call(this)}),(function(){return (function(){this._apply("empty");return e}).call(this)}))}).call(this)},
+"orExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("orExpr");this._applyWithArgs("token","||");y=this._apply("andExpr");return ["binop","||",x,y]}).call(this)}),(function(){return this._apply("andExpr")}))},
+"andExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("andExpr");this._applyWithArgs("token","&&");y=this._apply("eqExpr");return ["binop","&&",x,y]}).call(this)}),(function(){return this._apply("eqExpr")}))},
+"eqExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y,y,y,y;return this._or((function(){return (function(){x=this._apply("eqExpr");return this._or((function(){return (function(){this._applyWithArgs("token","==");y=this._apply("relExpr");return ["binop","==",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!=");y=this._apply("relExpr");return ["binop","!=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","===");y=this._apply("relExpr");return ["binop","===",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!==");y=this._apply("relExpr");return ["binop","!==",x,y]}).call(this)}))}).call(this)}),(function(){return this._apply("relExpr")}))},
+"relExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y,y,y,y,y;return this._or((function(){return (function(){x=this._apply("relExpr");return this._or((function(){return (function(){this._applyWithArgs("token",">");y=this._apply("addExpr");return ["binop",">",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",">=");y=this._apply("addExpr");return ["binop",">=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<");y=this._apply("addExpr");return ["binop","<",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<=");y=this._apply("addExpr");return ["binop","<=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","instanceof");y=this._apply("addExpr");return ["binop","instanceof",x,y]}).call(this)}))}).call(this)}),(function(){return this._apply("addExpr")}))},
+"addExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y,x,y;return this._or((function(){return (function(){x=this._apply("addExpr");this._applyWithArgs("token","+");y=this._apply("mulExpr");return ["binop","+",x,y]}).call(this)}),(function(){return (function(){x=this._apply("addExpr");this._applyWithArgs("token","-");y=this._apply("mulExpr");return ["binop","-",x,y]}).call(this)}),(function(){return this._apply("mulExpr")}))},
+"mulExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y,x,y,x,y;return this._or((function(){return (function(){x=this._apply("mulExpr");this._applyWithArgs("token","*");y=this._apply("unary");return ["binop","*",x,y]}).call(this)}),(function(){return (function(){x=this._apply("mulExpr");this._applyWithArgs("token","/");y=this._apply("unary");return ["binop","/",x,y]}).call(this)}),(function(){return (function(){x=this._apply("mulExpr");this._applyWithArgs("token","%");y=this._apply("unary");return ["binop","%",x,y]}).call(this)}),(function(){return this._apply("unary")}))},
+"unary":function(){var $elf=this,_fromIdx=this.input.idx,p,p,p,p,p,p,p,p;return this._or((function(){return (function(){this._applyWithArgs("token","-");p=this._apply("postfix");return ["unop","-",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","+");p=this._apply("postfix");return ["unop","+",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","++");p=this._apply("postfix");return ["preop","++",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","--");p=this._apply("postfix");return ["preop","--",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!");p=this._apply("unary");return ["unop","!",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","void");p=this._apply("unary");return ["unop","void",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","delete");p=this._apply("unary");return ["unop","delete",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","typeof");p=this._apply("unary");return ["unop","typeof",p]}).call(this)}),(function(){return this._apply("postfix")}))},
+"postfix":function(){var $elf=this,_fromIdx=this.input.idx,p;return (function(){p=this._apply("primExpr");return this._or((function(){return (function(){this._apply("spacesNoNl");this._applyWithArgs("token","++");return ["postop","++",p]}).call(this)}),(function(){return (function(){this._apply("spacesNoNl");this._applyWithArgs("token","--");return ["postop","--",p]}).call(this)}),(function(){return (function(){this._apply("empty");return p}).call(this)}))}).call(this)},
+"primExpr":function(){var $elf=this,_fromIdx=this.input.idx,p,i,m,as,f,as;return this._or((function(){return (function(){p=this._apply("primExpr");return this._or((function(){return (function(){this._applyWithArgs("token","[");i=this._apply("expr");this._applyWithArgs("token","]");return ["getp",i,p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",".");m=this._applyWithArgs("token","name");this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["send",m,p].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token",".");f=this._applyWithArgs("token","name");return ["getp",["string",f],p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["call",p].concat(as)}).call(this)}))}).call(this)}),(function(){return this._apply("primExprHd")}))},
+"primExprHd":function(){var $elf=this,_fromIdx=this.input.idx,e,n,n,s,n,as,es;return this._or((function(){return (function(){this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");return e}).call(this)}),(function(){return (function(){this._applyWithArgs("token","this");return ["this"]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","name");return ["get",n]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","number");return ["number",n]}).call(this)}),(function(){return (function(){s=this._applyWithArgs("token","string");return ["string",s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","function");return this._apply("funcRest")}).call(this)}),(function(){return (function(){this._applyWithArgs("token","new");n=this._applyWithArgs("token","name");this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["new",n].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");es=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token","]");return ["arr"].concat(es)}).call(this)}),(function(){return this._apply("json")}))},
+"json":function(){var $elf=this,_fromIdx=this.input.idx,bs;return (function(){this._applyWithArgs("token","{");bs=this._applyWithArgs("listOf","jsonBinding",",");this._applyWithArgs("token","}");return ["json"].concat(bs)}).call(this)},
+"jsonBinding":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._apply("jsonPropName");this._applyWithArgs("token",":");v=this._apply("expr");return ["binding",n,v]}).call(this)},
+"jsonPropName":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._applyWithArgs("token","name")}),(function(){return this._applyWithArgs("token","number")}),(function(){return this._applyWithArgs("token","string")}))},
+"formal":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("spaces");return this._applyWithArgs("token","name")}).call(this)},
+"funcRest":function(){var $elf=this,_fromIdx=this.input.idx,fs,body;return (function(){this._applyWithArgs("token","(");fs=this._applyWithArgs("listOf","formal",",");this._applyWithArgs("token",")");this._applyWithArgs("token","{");body=this._apply("srcElems");this._applyWithArgs("token","}");return ["func",fs,body]}).call(this)},
+"sc":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return (function(){this._apply("spacesNoNl");return this._or((function(){return (function(){switch(this._apply('anything')){case "\n":return "\n";default: throw fail}}).call(this)}),(function(){return this._lookahead((function(){return this._applyWithArgs("exactly","}")}))}),(function(){return this._apply("end")}))}).call(this)}),(function(){return this._applyWithArgs("token",";")}))},
+"binding":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._applyWithArgs("token","name");v=this._or((function(){return (function(){this._applyWithArgs("token","=");return this._apply("expr")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["var",n,v]}).call(this)},
+"block":function(){var $elf=this,_fromIdx=this.input.idx,ss;return (function(){this._applyWithArgs("token","{");ss=this._apply("srcElems");this._applyWithArgs("token","}");return ss}).call(this)},
+"stmt":function(){var $elf=this,_fromIdx=this.input.idx,bs,c,t,f,c,s,s,c,i,c,u,s,n,v,e,s,e,c,cs,cs,cs,e,t,e,c,f,e,x,s,e;return this._or((function(){return this._apply("block")}),(function(){return (function(){this._applyWithArgs("token","var");bs=this._applyWithArgs("listOf","binding",",");this._apply("sc");return ["begin"].concat(bs)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","if");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");t=this._apply("stmt");f=this._or((function(){return (function(){this._applyWithArgs("token","else");return this._apply("stmt")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["if",c,t,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["while",c,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","do");s=this._apply("stmt");this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");this._apply("sc");return ["doWhile",s,c]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");i=this._or((function(){return (function(){this._applyWithArgs("token","var");return this._apply("binding")}).call(this)}),(function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._applyWithArgs("token",";");c=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","true"]}).call(this)}));this._applyWithArgs("token",";");u=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._applyWithArgs("token",")");s=this._apply("stmt");return ["for",i,c,u,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");v=this._or((function(){return (function(){this._applyWithArgs("token","var");n=this._applyWithArgs("token","name");return ["var",n,["get","undefined"]]}).call(this)}),(function(){return this._apply("expr")}));this._applyWithArgs("token","in");e=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["forIn",v,e,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","switch");this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");this._applyWithArgs("token","{");cs=this._many((function(){return this._or((function(){return (function(){this._applyWithArgs("token","case");c=this._apply("expr");this._applyWithArgs("token",":");cs=this._apply("srcElems");return ["case",c,cs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","default");this._applyWithArgs("token",":");cs=this._apply("srcElems");return ["default",cs]}).call(this)}))}));this._applyWithArgs("token","}");return ["switch",e].concat(cs)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","break");this._apply("sc");return ["break"]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","continue");this._apply("sc");return ["continue"]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","throw");this._apply("spacesNoNl");e=this._apply("expr");this._apply("sc");return ["throw",e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","try");t=this._apply("block");this._applyWithArgs("token","catch");this._applyWithArgs("token","(");e=this._applyWithArgs("token","name");this._applyWithArgs("token",")");c=this._apply("block");f=this._or((function(){return (function(){this._applyWithArgs("token","finally");return this._apply("block")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["try",t,e,c,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","return");e=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._apply("sc");return ["return",e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","with");this._applyWithArgs("token","(");x=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["with",x,s]}).call(this)}),(function(){return (function(){e=this._apply("expr");this._apply("sc");return e}).call(this)}),(function(){return (function(){this._applyWithArgs("token",";");return ["get","undefined"]}).call(this)}))},
+"srcElem":function(){var $elf=this,_fromIdx=this.input.idx,n,f;return this._or((function(){return (function(){this._applyWithArgs("token","function");n=this._applyWithArgs("token","name");f=this._apply("funcRest");return ["var",n,f]}).call(this)}),(function(){return this._apply("stmt")}))},
+"srcElems":function(){var $elf=this,_fromIdx=this.input.idx,ss;return (function(){ss=this._many((function(){return this._apply("srcElem")}));return ["begin"].concat(ss)}).call(this)},
+"topLevel":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._apply("srcElems");this._apply("spaces");this._apply("end");return r}).call(this)}});(BSJSParser["hexDigits"]="0123456789abcdef");(BSJSParser["keywords"]=({}));(keywords=["break","case","catch","continue","default","delete","do","else","finally","for","function","if","in","instanceof","new","return","switch","this","throw","try","typeof","var","void","while","with","ometa"]);for(var idx=(0);(idx < keywords["length"]);idx++){(BSJSParser["keywords"][keywords[idx]]=true)}(BSJSParser["_isKeyword"]=(function (k){return (this["keywords"].hasOwnProperty(k))}));BSSemActionParser=objectThatDelegatesTo(BSJSParser,{
+"curlySemAction":function(){var $elf=this,_fromIdx=this.input.idx,r,s,ss,r,s;return this._or((function(){return (function(){this._applyWithArgs("token","{");r=this._apply("expr");this._apply("sc");this._applyWithArgs("token","}");this._apply("spaces");return r}).call(this)}),(function(){return (function(){this._applyWithArgs("token","{");ss=this._many((function(){return (function(){s=this._apply("srcElem");this._lookahead((function(){return this._apply("srcElem")}));return s}).call(this)}));s=this._or((function(){return (function(){r=this._apply("expr");this._apply("sc");return ["return",r]}).call(this)}),(function(){return this._apply("srcElem")}));ss.push(s);this._applyWithArgs("token","}");this._apply("spaces");return ["send","call",["func",[],["begin"].concat(ss)],["this"]]}).call(this)}))},
+"semAction":function(){var $elf=this,_fromIdx=this.input.idx,r;return this._or((function(){return this._apply("curlySemAction")}),(function(){return (function(){r=this._apply("primExpr");this._apply("spaces");return r}).call(this)}))}});BSJSTranslator=objectThatDelegatesTo(OMeta,{
+"trans":function(){var $elf=this,_fromIdx=this.input.idx,t,ans;return (function(){this._form((function(){return (function(){t=this._apply("anything");return ans=this._applyWithArgs("apply",t)}).call(this)}));return ans}).call(this)},
+"curlyTrans":function(){var $elf=this,_fromIdx=this.input.idx,r,rs,r;return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","begin");return r=this._apply("curlyTrans")}).call(this)}));return r}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","begin");return rs=this._many((function(){return this._apply("trans")}))}).call(this)}));return (("{" + rs.join(";")) + "}")}).call(this)}),(function(){return (function(){r=this._apply("trans");return (("{" + r) + "}")}).call(this)}))},
+"this":function(){var $elf=this,_fromIdx=this.input.idx;return "this"},
+"break":function(){var $elf=this,_fromIdx=this.input.idx;return "break"},
+"continue":function(){var $elf=this,_fromIdx=this.input.idx;return "continue"},
+"number":function(){var $elf=this,_fromIdx=this.input.idx,n;return (function(){n=this._apply("anything");return (("(" + n) + ")")}).call(this)},
+"string":function(){var $elf=this,_fromIdx=this.input.idx,s;return (function(){s=this._apply("anything");return s.toProgramString()}).call(this)},
+"arr":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return (("[" + xs.join(",")) + "]")}).call(this)},
+"unop":function(){var $elf=this,_fromIdx=this.input.idx,op,x;return (function(){op=this._apply("anything");x=this._apply("trans");return (((("(" + op) + " ") + x) + ")")}).call(this)},
+"getp":function(){var $elf=this,_fromIdx=this.input.idx,fd,x;return (function(){fd=this._apply("trans");x=this._apply("trans");return (((x + "[") + fd) + "]")}).call(this)},
+"get":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("anything");return x}).call(this)},
+"set":function(){var $elf=this,_fromIdx=this.input.idx,lhs,rhs;return (function(){lhs=this._apply("trans");rhs=this._apply("trans");return (((("(" + lhs) + "=") + rhs) + ")")}).call(this)},
+"mset":function(){var $elf=this,_fromIdx=this.input.idx,lhs,op,rhs;return (function(){lhs=this._apply("trans");op=this._apply("anything");rhs=this._apply("trans");return ((((("(" + lhs) + op) + "=") + rhs) + ")")}).call(this)},
+"binop":function(){var $elf=this,_fromIdx=this.input.idx,op,x,y;return (function(){op=this._apply("anything");x=this._apply("trans");y=this._apply("trans");return (((((("(" + x) + " ") + op) + " ") + y) + ")")}).call(this)},
+"preop":function(){var $elf=this,_fromIdx=this.input.idx,op,x;return (function(){op=this._apply("anything");x=this._apply("trans");return (op + x)}).call(this)},
+"postop":function(){var $elf=this,_fromIdx=this.input.idx,op,x;return (function(){op=this._apply("anything");x=this._apply("trans");return (x + op)}).call(this)},
+"return":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ("return " + x)}).call(this)},
+"with":function(){var $elf=this,_fromIdx=this.input.idx,x,s;return (function(){x=this._apply("trans");s=this._apply("curlyTrans");return ((("with(" + x) + ")") + s)}).call(this)},
+"if":function(){var $elf=this,_fromIdx=this.input.idx,cond,t,e;return (function(){cond=this._apply("trans");t=this._apply("curlyTrans");e=this._apply("curlyTrans");return ((((("if(" + cond) + ")") + t) + "else") + e)}).call(this)},
+"condExpr":function(){var $elf=this,_fromIdx=this.input.idx,cond,t,e;return (function(){cond=this._apply("trans");t=this._apply("trans");e=this._apply("trans");return (((((("(" + cond) + "?") + t) + ":") + e) + ")")}).call(this)},
+"while":function(){var $elf=this,_fromIdx=this.input.idx,cond,body;return (function(){cond=this._apply("trans");body=this._apply("curlyTrans");return ((("while(" + cond) + ")") + body)}).call(this)},
+"doWhile":function(){var $elf=this,_fromIdx=this.input.idx,body,cond;return (function(){body=this._apply("curlyTrans");cond=this._apply("trans");return (((("do" + body) + "while(") + cond) + ")")}).call(this)},
+"for":function(){var $elf=this,_fromIdx=this.input.idx,init,cond,upd,body;return (function(){init=this._apply("trans");cond=this._apply("trans");upd=this._apply("trans");body=this._apply("curlyTrans");return ((((((("for(" + init) + ";") + cond) + ";") + upd) + ")") + body)}).call(this)},
+"forIn":function(){var $elf=this,_fromIdx=this.input.idx,x,arr,body;return (function(){x=this._apply("trans");arr=this._apply("trans");body=this._apply("curlyTrans");return ((((("for(" + x) + " in ") + arr) + ")") + body)}).call(this)},
+"begin":function(){var $elf=this,_fromIdx=this.input.idx,x,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");return x}).call(this)}),(function(){return (function(){xs=this._many((function(){return (function(){x=this._apply("trans");return this._or((function(){return (function(){this._or((function(){return this._pred((x[(x["length"] - (1))] == "}"))}),(function(){return this._apply("end")}));return x}).call(this)}),(function(){return (function(){this._apply("empty");return (x + ";")}).call(this)}))}).call(this)}));return (("{" + xs.join("")) + "}")}).call(this)}))},
+"func":function(){var $elf=this,_fromIdx=this.input.idx,args,body;return (function(){args=this._apply("anything");body=this._apply("curlyTrans");return (((("(function (" + args.join(",")) + ")") + body) + ")")}).call(this)},
+"call":function(){var $elf=this,_fromIdx=this.input.idx,fn,args;return (function(){fn=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return (((fn + "(") + args.join(",")) + ")")}).call(this)},
+"send":function(){var $elf=this,_fromIdx=this.input.idx,msg,recv,args;return (function(){msg=this._apply("anything");recv=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return (((((recv + ".") + msg) + "(") + args.join(",")) + ")")}).call(this)},
+"new":function(){var $elf=this,_fromIdx=this.input.idx,cls,args;return (function(){cls=this._apply("anything");args=this._many((function(){return this._apply("trans")}));return (((("new " + cls) + "(") + args.join(",")) + ")")}).call(this)},
+"var":function(){var $elf=this,_fromIdx=this.input.idx,name,val;return (function(){name=this._apply("anything");val=this._apply("trans");return ((("var " + name) + "=") + val)}).call(this)},
+"throw":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ("throw " + x)}).call(this)},
+"try":function(){var $elf=this,_fromIdx=this.input.idx,x,name,c,f;return (function(){x=this._apply("curlyTrans");name=this._apply("anything");c=this._apply("curlyTrans");f=this._apply("curlyTrans");return ((((((("try " + x) + "catch(") + name) + ")") + c) + "finally") + f)}).call(this)},
+"json":function(){var $elf=this,_fromIdx=this.input.idx,props;return (function(){props=this._many((function(){return this._apply("trans")}));return (("({" + props.join(",")) + "})")}).call(this)},
+"binding":function(){var $elf=this,_fromIdx=this.input.idx,name,val;return (function(){name=this._apply("anything");val=this._apply("trans");return ((name.toProgramString() + ": ") + val)}).call(this)},
+"switch":function(){var $elf=this,_fromIdx=this.input.idx,x,cases;return (function(){x=this._apply("trans");cases=this._many((function(){return this._apply("trans")}));return (((("switch(" + x) + "){") + cases.join(";")) + "}")}).call(this)},
+"case":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return (function(){x=this._apply("trans");y=this._apply("trans");return ((("case " + x) + ": ") + y)}).call(this)},
+"default":function(){var $elf=this,_fromIdx=this.input.idx,y;return (function(){y=this._apply("trans");return ("default: " + y)}).call(this)}})}
Index: node_modules/ometa/bs-ometa-compiler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-ometa-compiler.js	(date 1323192249000)
+++ node_modules/ometa/bs-ometa-compiler.js	(date 1323192249000)
@@ -0,0 +1,62 @@
+var StringBuffer = StringBuffer || require('./lib').StringBuffer;
+{BSOMetaParser=objectThatDelegatesTo(Parser,{
+"fromTo":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return (function(){x=this._apply("anything");y=this._apply("anything");this._applyWithArgs("seq",x);this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("seq",y)}));return this._apply("char")}).call(this)}));return this._applyWithArgs("seq",y)}).call(this)},
+"space":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return Parser._superApplyWithArgs(this,'space')}),(function(){return this._applyWithArgs("fromTo","//","\n")}),(function(){return this._applyWithArgs("fromTo","/*","*/")}))},
+"nameFirst":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return (function(){switch(this._apply('anything')){case "_":return "_";case "$":return "$";default: throw fail}}).call(this)}),(function(){return this._apply("letter")}))},
+"nameRest":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("nameFirst")}),(function(){return this._apply("digit")}))},
+"tsName":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._applyWithArgs("firstAndRest","nameFirst","nameRest");return xs.join("")}).call(this)},
+"name":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("spaces");return this._apply("tsName")}).call(this)},
+"eChar":function(){var $elf=this,_fromIdx=this.input.idx,c;return this._or((function(){return (function(){switch(this._apply('anything')){case "\\":return (function(){c=this._apply("char");return unescape(("\\" + c))}).call(this);default: throw fail}}).call(this)}),(function(){return this._apply("char")}))},
+"tsString":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){this._applyWithArgs("exactly","\'");xs=this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\'")}));return this._apply("eChar")}).call(this)}));this._applyWithArgs("exactly","\'");return xs.join("")}).call(this)},
+"characters":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){this._applyWithArgs("exactly","`");this._applyWithArgs("exactly","`");xs=this._many((function(){return (function(){this._not((function(){return (function(){this._applyWithArgs("exactly","\'");return this._applyWithArgs("exactly","\'")}).call(this)}));return this._apply("eChar")}).call(this)}));this._applyWithArgs("exactly","\'");this._applyWithArgs("exactly","\'");return ["App","seq",xs.join("").toProgramString()]}).call(this)},
+"sCharacters":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){this._applyWithArgs("exactly","\"");xs=this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\"")}));return this._apply("eChar")}).call(this)}));this._applyWithArgs("exactly","\"");return ["App","token",xs.join("").toProgramString()]}).call(this)},
+"string":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._or((function(){return (function(){(function(){switch(this._apply('anything')){case "#":return "#";case "`":return "`";default: throw fail}}).call(this);return this._apply("tsName")}).call(this)}),(function(){return this._apply("tsString")}));return ["App","exactly",xs.toProgramString()]}).call(this)},
+"number":function(){var $elf=this,_fromIdx=this.input.idx,sign,ds;return (function(){sign=this._or((function(){return (function(){switch(this._apply('anything')){case "-":return "-";default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return ""}).call(this)}));ds=this._many1((function(){return this._apply("digit")}));return ["App","exactly",(sign + ds.join(""))]}).call(this)},
+"keyword":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._apply("anything");this._applyWithArgs("token",xs);this._not((function(){return this._apply("letterOrDigit")}));return xs}).call(this)},
+"args":function(){var $elf=this,_fromIdx=this.input.idx,xs;return this._or((function(){return (function(){switch(this._apply('anything')){case "(":return (function(){xs=this._applyWithArgs("listOf","hostExpr",",");this._applyWithArgs("token",")");return xs}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return []}).call(this)}))},
+"application":function(){var $elf=this,_fromIdx=this.input.idx,rule,as,grm,rule,as,rule,as;return this._or((function(){return (function(){this._applyWithArgs("token","^");rule=this._apply("name");as=this._apply("args");return ["App","super",(("\'" + rule) + "\'")].concat(as)}).call(this)}),(function(){return (function(){grm=this._apply("name");this._applyWithArgs("token",".");rule=this._apply("name");as=this._apply("args");return ["App","foreign",grm,(("\'" + rule) + "\'")].concat(as)}).call(this)}),(function(){return (function(){rule=this._apply("name");as=this._apply("args");return ["App",rule].concat(as)}).call(this)}))},
+"hostExpr":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._applyWithArgs("foreign",BSSemActionParser,'expr');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
+"curlyHostExpr":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._applyWithArgs("foreign",BSSemActionParser,'curlySemAction');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
+"primHostExpr":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._applyWithArgs("foreign",BSSemActionParser,'semAction');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
+"atomicHostExpr":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("curlyHostExpr")}),(function(){return this._apply("primHostExpr")}))},
+"semAction":function(){var $elf=this,_fromIdx=this.input.idx,x,x;return this._or((function(){return (function(){x=this._apply("curlyHostExpr");return ["Act",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!");x=this._apply("atomicHostExpr");return ["Act",x]}).call(this)}))},
+"arrSemAction":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){this._applyWithArgs("token","->");x=this._apply("atomicHostExpr");return ["Act",x]}).call(this)},
+"semPred":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){this._applyWithArgs("token","?");x=this._apply("atomicHostExpr");return ["Pred",x]}).call(this)},
+"expr":function(){var $elf=this,_fromIdx=this.input.idx,x,xs,x,xs;return this._or((function(){return (function(){x=this._applyWithArgs("expr5",true);xs=this._many1((function(){return (function(){this._applyWithArgs("token","|");return this._applyWithArgs("expr5",true)}).call(this)}));return ["Or",x].concat(xs)}).call(this)}),(function(){return (function(){x=this._applyWithArgs("expr5",true);xs=this._many1((function(){return (function(){this._applyWithArgs("token","||");return this._applyWithArgs("expr5",true)}).call(this)}));return ["XOr",x].concat(xs)}).call(this)}),(function(){return this._applyWithArgs("expr5",false)}))},
+"expr5":function(){var $elf=this,_fromIdx=this.input.idx,ne,x,xs;return (function(){ne=this._apply("anything");return this._or((function(){return (function(){x=this._apply("interleavePart");xs=this._many1((function(){return (function(){this._applyWithArgs("token","&&");return this._apply("interleavePart")}).call(this)}));return ["Interleave",x].concat(xs)}).call(this)}),(function(){return this._applyWithArgs("expr4",ne)}))}).call(this)},
+"interleavePart":function(){var $elf=this,_fromIdx=this.input.idx,part,part;return this._or((function(){return (function(){this._applyWithArgs("token","(");part=this._applyWithArgs("expr4",true);this._applyWithArgs("token",")");return ["1",part]}).call(this)}),(function(){return (function(){part=this._applyWithArgs("expr4",true);return this._applyWithArgs("modedIPart",part)}).call(this)}))},
+"modedIPart":function(){var $elf=this,_fromIdx=this.input.idx,part,part,part,part;return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");return this._form((function(){return (function(){this._applyWithArgs("exactly","Many");return part=this._apply("anything")}).call(this)}))}).call(this)}));return ["*",part]}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");return this._form((function(){return (function(){this._applyWithArgs("exactly","Many1");return part=this._apply("anything")}).call(this)}))}).call(this)}));return ["+",part]}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");return this._form((function(){return (function(){this._applyWithArgs("exactly","Opt");return part=this._apply("anything")}).call(this)}))}).call(this)}));return ["?",part]}).call(this)}),(function(){return (function(){part=this._apply("anything");return ["1",part]}).call(this)}))},
+"expr4":function(){var $elf=this,_fromIdx=this.input.idx,ne,xs,act,xs,xs;return (function(){ne=this._apply("anything");return this._or((function(){return (function(){xs=this._many((function(){return this._apply("expr3")}));act=this._apply("arrSemAction");return ["And"].concat(xs).concat([act])}).call(this)}),(function(){return (function(){this._pred(ne);xs=this._many1((function(){return this._apply("expr3")}));return ["And"].concat(xs)}).call(this)}),(function(){return (function(){this._pred((ne == false));xs=this._many((function(){return this._apply("expr3")}));return ["And"].concat(xs)}).call(this)}))}).call(this)},
+"optIter":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("anything");return this._or((function(){return (function(){switch(this._apply('anything')){case "*":return ["Many",x];case "+":return ["Many1",x];case "?":return ["Opt",x];default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return x}).call(this)}))}).call(this)},
+"optBind":function(){var $elf=this,_fromIdx=this.input.idx,x,n;return (function(){x=this._apply("anything");return this._or((function(){return (function(){switch(this._apply('anything')){case ":":return (function(){n=this._apply("name");return (function (){this["locals"].push(n);return ["Set",n,x]}).call(this)}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return x}).call(this)}))}).call(this)},
+"expr3":function(){var $elf=this,_fromIdx=this.input.idx,n,x,e;return this._or((function(){return (function(){this._applyWithArgs("token",":");n=this._apply("name");return (function (){this["locals"].push(n);return ["Set",n,["App","anything"]]}).call(this)}).call(this)}),(function(){return (function(){e=this._or((function(){return (function(){x=this._apply("expr2");return this._applyWithArgs("optIter",x)}).call(this)}),(function(){return this._apply("semAction")}));return this._applyWithArgs("optBind",e)}).call(this)}),(function(){return this._apply("semPred")}))},
+"expr2":function(){var $elf=this,_fromIdx=this.input.idx,x,x;return this._or((function(){return (function(){this._applyWithArgs("token","~");x=this._apply("expr2");return ["Not",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","&");x=this._apply("expr1");return ["Lookahead",x]}).call(this)}),(function(){return this._apply("expr1")}))},
+"expr1":function(){var $elf=this,_fromIdx=this.input.idx,x,x,x,x,x;return this._or((function(){return this._apply("application")}),(function(){return (function(){x=this._or((function(){return this._applyWithArgs("keyword","undefined")}),(function(){return this._applyWithArgs("keyword","nil")}),(function(){return this._applyWithArgs("keyword","true")}),(function(){return this._applyWithArgs("keyword","false")}));return ["App","exactly",x]}).call(this)}),(function(){return (function(){this._apply("spaces");return this._or((function(){return this._apply("characters")}),(function(){return this._apply("sCharacters")}),(function(){return this._apply("string")}),(function(){return this._apply("number")}))}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");x=this._apply("expr");this._applyWithArgs("token","]");return ["Form",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<");x=this._apply("expr");this._applyWithArgs("token",">");return ["ConsBy",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","@<");x=this._apply("expr");this._applyWithArgs("token",">");return ["IdxConsBy",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","(");x=this._apply("expr");this._applyWithArgs("token",")");return x}).call(this)}))},
+"ruleName":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("name")}),(function(){return (function(){this._apply("spaces");return this._apply("tsString")}).call(this)}))},
+"rule":function(){var $elf=this,_fromIdx=this.input.idx,n,x,xs;return (function(){this._lookahead((function(){return n=this._apply("ruleName")}));(this["locals"]=["$elf=this","_fromIdx=this.input.idx"]);x=this._applyWithArgs("rulePart",n);xs=this._many((function(){return (function(){this._applyWithArgs("token",",");return this._applyWithArgs("rulePart",n)}).call(this)}));return ["Rule",n,this["locals"],["Or",x].concat(xs)]}).call(this)},
+"rulePart":function(){var $elf=this,_fromIdx=this.input.idx,rn,n,b1,b2;return (function(){rn=this._apply("anything");n=this._apply("ruleName");this._pred((n == rn));b1=this._apply("expr4");return this._or((function(){return (function(){this._applyWithArgs("token","=");b2=this._apply("expr");return ["And",b1,b2]}).call(this)}),(function(){return (function(){this._apply("empty");return b1}).call(this)}))}).call(this)},
+"grammar":function(){var $elf=this,_fromIdx=this.input.idx,n,sn,rs;return (function(){this._applyWithArgs("keyword","ometa");n=this._apply("name");sn=this._or((function(){return (function(){this._applyWithArgs("token","<:");return this._apply("name")}).call(this)}),(function(){return (function(){this._apply("empty");return "OMeta"}).call(this)}));this._applyWithArgs("token","{");rs=this._applyWithArgs("listOf","rule",",");this._applyWithArgs("token","}");return this._applyWithArgs("foreign",BSOMetaOptimizer,'optimizeGrammar',["Grammar",n,sn].concat(rs))}).call(this)}});BSOMetaTranslator=objectThatDelegatesTo(OMeta,{
+"App":function(){var $elf=this,_fromIdx=this.input.idx,args,rule,args,rule;return this._or((function(){return (function(){switch(this._apply('anything')){case "super":return (function(){args=this._many1((function(){return this._apply("anything")}));return [this["sName"],"._superApplyWithArgs(this,",args.join(","),")"].join("")}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){rule=this._apply("anything");args=this._many1((function(){return this._apply("anything")}));return ["this._applyWithArgs(\"",rule,"\",",args.join(","),")"].join("")}).call(this)}),(function(){return (function(){rule=this._apply("anything");return ["this._apply(\"",rule,"\")"].join("")}).call(this)}))},
+"Act":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return expr}).call(this)},
+"Pred":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return ["this._pred(",expr,")"].join("")}).call(this)},
+"Or":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("transFn")}));return ["this._or(",xs.join(","),")"].join("")}).call(this)},
+"XOr":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("transFn")}));xs.unshift(((this["name"] + ".") + this["rName"]).toProgramString());return ["this._xor(",xs.join(","),")"].join("")}).call(this)},
+"And":function(){var $elf=this,_fromIdx=this.input.idx,xs,y;return this._or((function(){return (function(){xs=this._many((function(){return this._applyWithArgs("notLast","trans")}));y=this._apply("trans");xs.push(("return " + y));return ["(function(){",xs.join(";"),"}).call(this)"].join("")}).call(this)}),(function(){return "undefined"}))},
+"Opt":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._opt(",x,")"].join("")}).call(this)},
+"Many":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._many(",x,")"].join("")}).call(this)},
+"Many1":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._many1(",x,")"].join("")}).call(this)},
+"Set":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._apply("anything");v=this._apply("trans");return [n,"=",v].join("")}).call(this)},
+"Not":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._not(",x,")"].join("")}).call(this)},
+"Lookahead":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._lookahead(",x,")"].join("")}).call(this)},
+"Form":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._form(",x,")"].join("")}).call(this)},
+"ConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._consumedBy(",x,")"].join("")}).call(this)},
+"IdxConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._idxConsumedBy(",x,")"].join("")}).call(this)},
+"JumpTable":function(){var $elf=this,_fromIdx=this.input.idx,cases;return (function(){cases=this._many((function(){return this._apply("jtCase")}));return this.jumpTableCode(cases)}).call(this)},
+"Interleave":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("intPart")}));return ["this._interleave(",xs.join(","),")"].join("")}).call(this)},
+"Rule":function(){var $elf=this,_fromIdx=this.input.idx,name,ls,body;return (function(){name=this._apply("anything");(this["rName"]=name);ls=this._apply("locals");body=this._apply("trans");return ["\n\"",name,"\":function(){",ls,"return ",body,"}"].join("")}).call(this)},
+"Grammar":function(){var $elf=this,_fromIdx=this.input.idx,name,sName,rules;return (function(){name=this._apply("anything");sName=this._apply("anything");(this["name"]=name);(this["sName"]=sName);rules=this._many((function(){return this._apply("trans")}));return [name,"=objectThatDelegatesTo(",sName,",{",rules.join(","),"})"].join("")}).call(this)},
+"intPart":function(){var $elf=this,_fromIdx=this.input.idx,mode,part;return (function(){this._form((function(){return (function(){mode=this._apply("anything");return part=this._apply("transFn")}).call(this)}));return ((mode.toProgramString() + ",") + part)}).call(this)},
+"jtCase":function(){var $elf=this,_fromIdx=this.input.idx,x,e;return (function(){this._form((function(){return (function(){x=this._apply("anything");return e=this._apply("trans")}).call(this)}));return [x.toProgramString(),e]}).call(this)},
+"locals":function(){var $elf=this,_fromIdx=this.input.idx,vs;return this._or((function(){return (function(){this._form((function(){return vs=this._many1((function(){return this._apply("string")}))}));return ["var ",vs.join(","),";"].join("")}).call(this)}),(function(){return (function(){this._form((function(){return undefined}));return ""}).call(this)}))},
+"trans":function(){var $elf=this,_fromIdx=this.input.idx,t,ans;return (function(){this._form((function(){return (function(){t=this._apply("anything");return ans=this._applyWithArgs("apply",t)}).call(this)}));return ans}).call(this)},
+"transFn":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["(function(){return ",x,"})"].join("")}).call(this)}});(BSOMetaTranslator["jumpTableCode"]=(function (cases){var buf=new StringBuffer();buf.nextPutAll("(function(){switch(this._apply(\'anything\')){");for(var i=(0);(i < cases["length"]);(i+=(1))){buf.nextPutAll((((("case " + cases[i][(0)]) + ":return ") + cases[i][(1)]) + ";"))};buf.nextPutAll("default: throw fail}}).call(this)");return buf.contents()}))}
Index: node_modules/ometa/bs-js-compiler.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-js-compiler.txt	(date 1323192249000)
+++ node_modules/ometa/bs-js-compiler.txt	(date 1323192249000)
@@ -0,0 +1,211 @@
+ometa BSJSParser <: Parser {
+  fromTo :x :y = seq(x) (~seq(y) char)* seq(y), 
+  space        = ^space | fromTo('//', '\n') | fromTo('/*', '*/'),
+  nameFirst    = letter | '$' | '_',
+  nameRest     = nameFirst | digit,
+  iName        = firstAndRest(#nameFirst, #nameRest):r                               -> r.join(''),
+  isKeyword :x = ?BSJSParser._isKeyword(x),
+  name         = iName:n ~isKeyword(n)                                               -> [#name, n=='self' ? '$elf' : n],
+  keyword      = iName:k isKeyword(k)                                                -> [k, k],
+  hexDigit     = char:x {this.hexDigits.indexOf(x.toLowerCase())}:v ?(v >= 0)        -> v,
+  hexLit       = hexLit:n hexDigit:d                                                 -> (n * 16 + d)
+               | hexDigit,
+  number       = ``0x'' hexLit:n                                                     -> [#number, n]
+               | digit+:ws ('.' digit+ | empty -> []):fs                             -> [#number, parseFloat(ws.join('') + '.' +
+                                                                                                             fs.join(''))],
+  escapeChar   = '\\' char:c                                                         -> unescape('\\' + c),
+  str          = seq('"""')  (escapeChar | ~seq('"""') char)*:cs seq('"""')          -> [#string, cs.join('')]
+               | '\'' (escapeChar | ~'\'' char)*:cs '\''                             -> [#string, cs.join('')]
+               | '"'  (escapeChar | ~'"'  char)*:cs '"'                              -> [#string, cs.join('')]
+               | ('#' | '`') iName:n                                                 -> [#string, n],
+  special      = ( '('   | ')'    | '{'    | '}'     | '['    | ']'     | ','    
+                 | ';'   | '?'    | ':'    | ``!=='' | ``!='' | ``==='' | ``==''
+                 | ``='' | ``>='' | '>'    | ``<=''  | '<'    | ``++''  | ``+=''
+                 | '+'   | ``--'' | ``-='' | '-'     | ``*='' | '*'     | ``/=''
+                 | '/'   | ``%='' | '%'    | ``&&='' | ``&&'' | ``||='' | ``||''
+                 | '.'   | '!'                                                   ):s -> [s, s],
+  tok          = spaces (name | keyword | number | str | special),
+  toks         = token*:ts spaces end                                                -> ts,
+  token :tt    = tok:t ?(t[0] == tt)                                                 -> t[1],
+  spacesNoNl   = (~'\n' space)*,
+
+  expr         = orExpr:e ( "?"   expr:t   ":" expr:f                                -> [#condExpr, e, t, f]
+                          | "="   expr:rhs                                           -> [#set,  e, rhs]
+                          | "+="  expr:rhs                                           -> [#mset, e, "+",  rhs]
+                          | "-="  expr:rhs                                           -> [#mset, e, "-",  rhs]
+                          | "*="  expr:rhs                                           -> [#mset, e, "*",  rhs]
+                          | "/="  expr:rhs                                           -> [#mset, e, "/",  rhs]
+                          | "%="  expr:rhs                                           -> [#mset, e, "%",  rhs]
+                          | "&&=" expr:rhs                                           -> [#mset, e, "&&", rhs]
+                          | "||=" expr:rhs                                           -> [#mset, e, "||", rhs]
+                          | empty                                                    -> e
+                          ),
+  orExpr       = orExpr:x "||" andExpr:y                                             -> [#binop, "||", x, y]
+               | andExpr,
+  andExpr      = andExpr:x "&&" eqExpr:y                                             -> [#binop, "&&", x, y]
+               | eqExpr,
+  eqExpr       = eqExpr:x ( "=="  relExpr:y                                          -> [#binop, "==",  x, y]
+                          | "!="  relExpr:y                                          -> [#binop, "!=",  x, y]
+                          | "===" relExpr:y                                          -> [#binop, "===", x, y]
+                          | "!==" relExpr:y                                          -> [#binop, "!==", x, y]
+                          )
+               | relExpr,
+  relExpr      = relExpr:x ( ">"          addExpr:y                                  -> [#binop, ">",          x, y]
+                           | ">="         addExpr:y                                  -> [#binop, ">=",         x, y]
+                           | "<"          addExpr:y                                  -> [#binop, "<",          x, y]
+                           | "<="         addExpr:y                                  -> [#binop, "<=",         x, y]
+                           | "instanceof" addExpr:y                                  -> [#binop, "instanceof", x, y]
+                           )
+               | addExpr,
+  addExpr      = addExpr:x "+" mulExpr:y                                             -> [#binop, "+",          x, y]
+               | addExpr:x "-" mulExpr:y                                             -> [#binop, "-",          x, y]
+               | mulExpr,
+  mulExpr      = mulExpr:x "*" unary:y                                               -> [#binop, "*",          x, y]
+               | mulExpr:x "/" unary:y                                               -> [#binop, "/",          x, y]
+               | mulExpr:x "%" unary:y                                               -> [#binop, "%",          x, y]
+               | unary,
+  unary        = "-"      postfix:p                                                  -> [#unop,  "-",        p]
+               | "+"      postfix:p                                                  -> [#unop,  "+",        p]
+               | "++"     postfix:p                                                  -> [#preop, "++",       p]
+               | "--"     postfix:p                                                  -> [#preop, "--",       p]
+               | "!"      unary:p                                                    -> [#unop,  "!",        p]
+               | "void"   unary:p                                                    -> [#unop,  "void",     p]
+               | "delete" unary:p                                                    -> [#unop,  "delete",   p]
+               | "typeof" unary:p                                                    -> [#unop,  "typeof",   p]
+               | postfix,
+  postfix      = primExpr:p ( spacesNoNl "++"                                        -> [#postop, "++", p]
+                            | spacesNoNl "--"                                        -> [#postop, "--", p]
+                            | empty                                                  -> p
+                            ),
+  primExpr     = primExpr:p ( "[" expr:i "]"                                         -> [#getp, i, p]
+                            | "." "name":m "(" listOf(#expr, ','):as ")"             -> [#send, m, p].concat(as)
+                            | "." "name":f                                           -> [#getp, [#string, f], p]
+                            | "(" listOf(#expr, ','):as ")"                          -> [#call, p].concat(as)
+                            )
+               | primExprHd,
+  primExprHd   = "(" expr:e ")"                                                      -> e
+               | "this"                                                              -> [#this]
+               | "name":n                                                            -> [#get, n]
+               | "number":n                                                          -> [#number, n]
+               | "string":s                                                          -> [#string, s]
+               | "function" funcRest
+               | "new" "name":n "(" listOf(#expr, ','):as ")"                        -> [#new, n].concat(as)
+               | "[" listOf(#expr, ','):es "]"                                       -> [#arr].concat(es)
+               | json,
+  json         = "{" listOf(#jsonBinding, ','):bs "}"                                -> [#json].concat(bs),
+  jsonBinding  = jsonPropName:n ":" expr:v                                           -> [#binding, n, v],
+  jsonPropName = "name" | "number" | "string",
+  formal       = spaces "name",
+  funcRest     = "(" listOf(#formal, ','):fs ")" "{" srcElems:body "}"               -> [#func, fs, body],
+  sc           = spacesNoNl ('\n' | &'}' | end)
+               | ";",
+  binding      = "name":n ( "=" expr
+                          | empty -> [#get, 'undefined'] ):v                         -> [#var, n, v],
+  block        = "{" srcElems:ss "}"                                                 -> ss,
+  stmt         = block
+               | "var" listOf(#binding, ','):bs sc                                   -> [#begin].concat(bs)
+               | "if" "(" expr:c ")" stmt:t ( "else" stmt
+                                            | empty -> [#get, 'undefined'] ):f       -> [#if, c, t, f]
+               | "while" "(" expr:c ")" stmt:s                                       -> [#while,   c, s]
+               | "do" stmt:s "while" "(" expr:c ")" sc                               -> [#doWhile, s, c]
+               | "for" "(" ( "var" binding
+                           | expr
+                           | empty -> [#get, 'undefined'] ):i
+                       ";" ( expr
+                           | empty -> [#get, 'true']      ):c
+                       ";" ( expr
+                           | empty -> [#get, 'undefined'] ):u
+                       ")" stmt:s                                                    -> [#for, i, c, u, s]
+               | "for" "(" ( "var" "name":n -> [#var, n, [#get, 'undefined']]
+                           | expr                                             ):v
+                      "in" expr:e
+                       ")" stmt:s                                                    -> [#forIn, v, e, s]
+               | "switch" "(" expr:e ")" "{"
+                   ( "case" expr:c ":" srcElems:cs -> [#case, c, cs]
+                   | "default"     ":" srcElems:cs -> [#default, cs] )*:cs
+                 "}"                                                                 -> [#switch, e].concat(cs)
+               | "break" sc                                                          -> [#break]
+               | "continue" sc                                                       -> [#continue]
+               | "throw" spacesNoNl expr:e sc                                        -> [#throw, e]
+               | "try" block:t "catch" "(" "name":e ")" block:c
+                             ( "finally" block
+                             | empty -> [#get, 'undefined'] ):f                      -> [#try, t, e, c, f]
+               | "return" ( expr
+                          | empty -> [#get, 'undefined'] ):e sc                      -> [#return, e]
+               | "with" "(" expr:x ")" stmt:s                                        -> [#with, x, s]
+               | expr:e sc                                                           -> e
+               | ";"                                                                 -> [#get, "undefined"],
+  srcElem      = "function" "name":n funcRest:f                                      -> [#var, n, f]
+               | stmt,
+  srcElems     = srcElem*:ss                                                         -> [#begin].concat(ss),
+
+  topLevel     = srcElems:r spaces end                                               -> r
+}
+BSJSParser.hexDigits = "0123456789abcdef"
+BSJSParser.keywords  = { }
+keywords = ["break", "case", "catch", "continue", "default", "delete", "do", "else", "finally", "for", "function", "if", "in",
+            "instanceof", "new", "return", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "ometa"]
+for (var idx = 0; idx < keywords.length; idx++)
+  BSJSParser.keywords[keywords[idx]] = true
+BSJSParser._isKeyword = function(k) { return this.keywords.hasOwnProperty(k) }
+
+
+ometa BSSemActionParser <: BSJSParser {
+  curlySemAction = "{" expr:r sc "}" spaces                                  -> r
+                 | "{" (srcElem:s &srcElem -> s)*:ss
+                       ( expr:r sc -> [#return, r] | srcElem):s {ss.push(s)}
+                   "}" spaces                                                -> [#send, #call,
+                                                                                        [#func, [], [#begin].concat(ss)],
+                                                                                        [#this]],
+  semAction      = curlySemAction
+                 | primExpr:r spaces                                         -> r
+}
+
+ometa BSJSTranslator {
+  trans      = [:t apply(t):ans]     -> ans,
+  curlyTrans = [#begin curlyTrans:r] -> r
+             | [#begin trans*:rs]    -> ('{' + rs.join(';') + '}')
+             | trans:r               -> ('{' + r + '}'),
+
+  this                                                  -> 'this',
+  break                                                 -> 'break',
+  continue                                              -> 'continue',
+  number   :n                                           -> ('(' + n + ')'),
+  string   :s                                           -> s.toProgramString(),
+  arr      trans*:xs                                    -> ('[' + xs.join(',') + ']'),
+  unop     :op trans:x                                  -> ('(' + op + ' ' + x + ')'),
+  getp     trans:fd trans:x                             -> (x + '[' + fd + ']'),
+  get      :x                                           -> x,
+  set      trans:lhs trans:rhs                          -> ('(' + lhs + '=' + rhs + ')'),
+  mset     trans:lhs :op trans:rhs                      -> ('(' + lhs + op + '=' + rhs + ')'),
+  binop    :op trans:x trans:y                          -> ('(' + x + ' ' + op + ' ' + y + ')'),
+  preop    :op trans:x                                  -> (op + x),
+  postop   :op trans:x                                  -> (x + op),
+  return   trans:x                                      -> ('return ' + x),
+  with     trans:x curlyTrans:s                         -> ('with(' + x + ')' + s),
+  if       trans:cond curlyTrans:t curlyTrans:e         -> ('if(' + cond + ')' + t + 'else' + e),
+  condExpr trans:cond trans:t trans:e                   -> ('(' + cond + '?' + t + ':' + e + ')'),
+  while    trans:cond curlyTrans:body                   -> ('while(' + cond + ')' + body),
+  doWhile  curlyTrans:body trans:cond                   -> ('do' + body + 'while(' + cond + ')'),
+  for      trans:init trans:cond trans:upd
+           curlyTrans:body                              -> ('for(' + init + ';' + cond + ';' + upd + ')' + body),
+  forIn    trans:x trans:arr curlyTrans:body            -> ('for(' + x + ' in ' + arr + ')' + body),
+  begin    trans:x end                                  -> x,
+  begin    (trans:x
+              ( (?(x[x.length - 1] == '}') | end) -> x
+              | empty                             -> (x  + ';')
+              )
+           )*:xs                                        -> ('{' + xs.join('') + '}'),
+  func     :args curlyTrans:body                        -> ('(function (' + args.join(',') + ')' + body + ')'),
+  call     trans:fn trans*:args                         -> (fn + '(' + args.join(',') + ')'),
+  send     :msg trans:recv trans*:args                  -> (recv + '.' + msg + '(' + args.join(',') + ')'),
+  new      :cls trans*:args                             -> ('new ' + cls + '(' + args.join(',') + ')'),
+  var      :name trans:val                              -> ('var ' + name + '=' + val),
+  throw    trans:x                                      -> ('throw ' + x),
+  try      curlyTrans:x :name curlyTrans:c curlyTrans:f -> ('try ' + x + 'catch(' + name + ')' + c + 'finally' + f),
+  json     trans*:props                                 -> ('({' + props.join(',') + '})'),
+  binding  :name trans:val                              -> (name.toProgramString() + ': ' + val),
+  switch   trans:x trans*:cases                         -> ('switch(' + x + '){' + cases.join(';') + '}'),
+  case     trans:x trans:y                              -> ('case ' + x + ': '+ y),
+  default          trans:y                              -> ('default: ' + y)
+}
Index: node_modules/ometa/bs-ometa-js-compiler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-ometa-js-compiler.js	(date 1323192249000)
+++ node_modules/ometa/bs-ometa-js-compiler.js	(date 1323192249000)
@@ -0,0 +1,3 @@
+{BSOMetaJSParser=objectThatDelegatesTo(BSJSParser,{
+"srcElem":function(){var $elf=this,_fromIdx=this.input.idx,r;return this._or((function(){return (function(){this._apply("spaces");r=this._applyWithArgs("foreign",BSOMetaParser,'grammar');this._apply("sc");return r}).call(this)}),(function(){return BSJSParser._superApplyWithArgs(this,'srcElem')}))}});BSOMetaJSTranslator=objectThatDelegatesTo(BSJSTranslator,{
+"Grammar":function(){var $elf=this,_fromIdx=this.input.idx;return this._applyWithArgs("foreign",BSOMetaTranslator,'Grammar')}})}
Index: node_modules/ometa/bs-ometa-compiler.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-ometa-compiler.txt	(date 1323192249000)
+++ node_modules/ometa/bs-ometa-compiler.txt	(date 1323192249000)
@@ -0,0 +1,124 @@
+ometa BSOMetaParser <: Parser {
+  fromTo :x :y   = seq(x) (~seq(y) char)* seq(y), 
+  space          = ^space | fromTo('//', '\n') | fromTo('/*', '*/'),
+  nameFirst      = '_' | '$' | letter,
+  nameRest       = nameFirst | digit,
+  tsName         = firstAndRest(#nameFirst, #nameRest):xs              -> xs.join(''),
+  name           = spaces tsName,
+  eChar          = '\\' char:c                                         -> unescape('\\' +c)
+                 | char,
+  tsString       = '\'' (~'\'' eChar)*:xs '\''                         -> xs.join(''),
+  characters     = '`' '`' (~('\'' '\'') eChar)*:xs '\'' '\''          -> [#App, #seq,     xs.join('').toProgramString()],
+  sCharacters    = '"'     (~'"'         eChar)*:xs '"'                -> [#App, #token,   xs.join('').toProgramString()],
+  string         = (('#' | '`') tsName | tsString):xs                  -> [#App, #exactly, xs.toProgramString()],
+  number         = ('-' | empty -> ''):sign digit+:ds                  -> [#App, #exactly, sign + ds.join('')],
+  keyword :xs    = token(xs) ~letterOrDigit                            -> xs,
+  args           = '(' listOf(#hostExpr, ','):xs ")"                   -> xs
+                 | empty                                               -> [],
+  application    = "^"          name:rule args:as                      -> [#App, "super",        "'" + rule + "'"].concat(as)
+                 | name:grm "." name:rule args:as                      -> [#App, "foreign", grm, "'" + rule + "'"].concat(as)
+                 |              name:rule args:as                      -> [#App, rule].concat(as),
+  hostExpr       = BSSemActionParser.expr:r                               BSJSTranslator.trans(r),
+  curlyHostExpr  = BSSemActionParser.curlySemAction:r                     BSJSTranslator.trans(r),
+  primHostExpr   = BSSemActionParser.semAction:r                          BSJSTranslator.trans(r),
+  atomicHostExpr = curlyHostExpr | primHostExpr,
+  semAction      = curlyHostExpr:x                                     -> [#Act, x]
+                 | "!"  atomicHostExpr:x                               -> [#Act, x],
+  arrSemAction   = "->" atomicHostExpr:x                               -> [#Act, x],
+  semPred        = "?"  atomicHostExpr:x                               -> [#Pred, x],
+  expr           = expr5(true):x ("|"  expr5(true))+:xs                -> [#Or,  x].concat(xs)
+                 | expr5(true):x ("||" expr5(true))+:xs                -> [#XOr, x].concat(xs)
+                 | expr5(false),
+  expr5 :ne      = interleavePart:x ("&&" interleavePart)+:xs          -> [#Interleave, x].concat(xs)
+                 | expr4(ne),
+  interleavePart = "(" expr4(true):part ")"                            -> ["1", part]
+                 | expr4(true):part modedIPart(part),
+  modedIPart     = [#And [#Many  :part]]                               -> ["*", part]
+                 | [#And [#Many1 :part]]                               -> ["+", part]
+                 | [#And [#Opt   :part]]                               -> ["?", part]
+                 | :part                                               -> ["1", part],
+  expr4 :ne      =                expr3*:xs arrSemAction:act           -> [#And].concat(xs).concat([act])
+                 | ?ne            expr3+:xs                            -> [#And].concat(xs)
+                 | ?(ne == false) expr3*:xs                            -> [#And].concat(xs),
+  optIter :x     = '*'                                                 -> [#Many,  x]
+                 | '+'                                                 -> [#Many1, x]
+                 | '?'                                                 -> [#Opt,   x]
+                 | empty                                               -> x,
+  optBind :x     = ':' name:n                                          -> { this.locals.push(n); [#Set, n, x] }
+                 | empty                                               -> x,
+  expr3          = ":" name:n                                          -> { this.locals.push(n); [#Set, n, [#App, #anything]] }
+                 | (expr2:x optIter(x) | semAction):e optBind(e)
+                 | semPred,
+  expr2          = "~" expr2:x                                         -> [#Not,       x]
+                 | "&" expr1:x                                         -> [#Lookahead, x]
+                 | expr1,
+  expr1          = application 
+                 | ( keyword('undefined') | keyword('nil')
+                   | keyword('true')      | keyword('false') ):x       -> [#App, #exactly, x]
+                 | spaces (characters | sCharacters | string | number)
+                 | "["  expr:x "]"                                     -> [#Form,      x]
+                 | "<"  expr:x ">"                                     -> [#ConsBy,    x]
+                 | "@<" expr:x ">"                                     -> [#IdxConsBy, x]
+                 | "("  expr:x ")"                                     -> x,
+  ruleName       = name
+                 | spaces tsString,
+  rule           = &(ruleName:n) !(this.locals = ['$elf=this', '_fromIdx=this.input.idx'])
+                     rulePart(n):x ("," rulePart(n))*:xs               -> [#Rule, n, this.locals, [#Or, x].concat(xs)],
+  rulePart :rn   = ruleName:n ?(n == rn) expr4:b1 ( "=" expr:b2        -> [#And, b1, b2]
+                                                  | empty              -> b1
+                                                  ),
+  grammar        = keyword('ometa') name:n
+                     ( "<:" name | empty -> 'OMeta' ):sn
+                     "{" listOf(#rule, ','):rs "}"                        BSOMetaOptimizer.optimizeGrammar(
+                                                                            [#Grammar, n, sn].concat(rs)
+                                                                          )
+}
+
+// By dispatching on the head of a list, the following idiom allows translators to avoid doing a linear search.
+// (Note that the "=" in a rule definition is optional, so you can give your rules an "ML feel".)
+ometa BSOMetaTranslator {
+  App        'super' anything+:args        -> [this.sName, '._superApplyWithArgs(this,', args.join(','), ')']      .join(''),
+  App        :rule   anything+:args        -> ['this._applyWithArgs("', rule, '",',      args.join(','), ')']      .join(''),
+  App        :rule                         -> ['this._apply("', rule, '")']                                        .join(''),
+  Act        :expr                         -> expr,
+  Pred       :expr                         -> ['this._pred(', expr, ')']                                           .join(''),
+  Or         transFn*:xs                   -> ['this._or(',  xs.join(','), ')']                                    .join(''),
+  XOr        transFn*:xs                       {xs.unshift((this.name + "." + this.rName).toProgramString())}
+                                           -> ['this._xor(', xs.join(','), ')']                                    .join(''),
+  And        notLast(#trans)*:xs trans:y
+             {xs.push('return ' + y)}      -> ['(function(){', xs.join(';'), '}).call(this)']                      .join(''),
+  And                                      -> 'undefined',
+  Opt        transFn:x                     -> ['this._opt(',           x, ')']                                     .join(''),
+  Many       transFn:x                     -> ['this._many(',          x, ')']                                     .join(''),
+  Many1      transFn:x                     -> ['this._many1(',         x, ')']                                     .join(''),
+  Set        :n trans:v                    -> [n, '=', v]                                                          .join(''),
+  Not        transFn:x                     -> ['this._not(',           x, ')']                                     .join(''),
+  Lookahead  transFn:x                     -> ['this._lookahead(',     x, ')']                                     .join(''),
+  Form       transFn:x                     -> ['this._form(',          x, ')']                                     .join(''),
+  ConsBy     transFn:x                     -> ['this._consumedBy(',    x, ')']                                     .join(''),
+  IdxConsBy  transFn:x                     -> ['this._idxConsumedBy(', x, ')']                                     .join(''),
+  JumpTable  jtCase*:cases                 -> this.jumpTableCode(cases),
+  Interleave intPart*:xs                   -> ['this._interleave(', xs.join(','), ')']                             .join(''),
+  
+  Rule       :name {this.rName = name}
+             locals:ls trans:body          -> ['\n"', name, '":function(){', ls, 'return ', body, '}']             .join(''),
+  Grammar    :name :sName
+             {this.name = name}
+             {this.sName = sName}
+             trans*:rules                  -> [name, '=objectThatDelegatesTo(', sName, ',{', rules.join(','), '})'].join(''),
+  intPart  = [:mode transFn:part]          -> (mode.toProgramString()  + "," + part),
+  jtCase   = [:x trans:e]                  -> [x.toProgramString(), e],
+  locals   = [string+:vs]                  -> ['var ', vs.join(','), ';']                                          .join('')
+           | []                            -> '',
+  trans    = [:t apply(t):ans]             -> ans,
+  transFn  = trans:x                       -> ['(function(){return ', x, '})']                                     .join('')
+}
+BSOMetaTranslator.jumpTableCode = function(cases) {
+  var buf = new StringBuffer()
+  buf.nextPutAll("(function(){switch(this._apply('anything')){")
+  for (var i = 0; i < cases.length; i += 1)
+    buf.nextPutAll("case " + cases[i][0] + ":return " + cases[i][1] + ";")
+  buf.nextPutAll("default: throw fail}}).call(this)")
+  return buf.contents()
+}
+
Index: node_modules/ometa/bs-ometa-optimizer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-ometa-optimizer.js	(date 1323192249000)
+++ node_modules/ometa/bs-ometa-optimizer.js	(date 1323192249000)
@@ -0,0 +1,37 @@
+{BSNullOptimization=objectThatDelegatesTo(OMeta,{
+"setHelped":function(){var $elf=this,_fromIdx=this.input.idx;return (this["_didSomething"]=true)},
+"helped":function(){var $elf=this,_fromIdx=this.input.idx;return this._pred(this["_didSomething"])},
+"trans":function(){var $elf=this,_fromIdx=this.input.idx,t,ans;return (function(){this._form((function(){return (function(){t=this._apply("anything");this._pred((this[t] != undefined));return ans=this._applyWithArgs("apply",t)}).call(this)}));return ans}).call(this)},
+"optimize":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");this._apply("helped");return x}).call(this)},
+"App":function(){var $elf=this,_fromIdx=this.input.idx,rule,args;return (function(){rule=this._apply("anything");args=this._many((function(){return this._apply("anything")}));return ["App",rule].concat(args)}).call(this)},
+"Act":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return ["Act",expr]}).call(this)},
+"Pred":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return ["Pred",expr]}).call(this)},
+"Or":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return ["Or"].concat(xs)}).call(this)},
+"XOr":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return ["XOr"].concat(xs)}).call(this)},
+"And":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return ["And"].concat(xs)}).call(this)},
+"Opt":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Opt",x]}).call(this)},
+"Many":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Many",x]}).call(this)},
+"Many1":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Many1",x]}).call(this)},
+"Set":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._apply("anything");v=this._apply("trans");return ["Set",n,v]}).call(this)},
+"Not":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Not",x]}).call(this)},
+"Lookahead":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Lookahead",x]}).call(this)},
+"Form":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Form",x]}).call(this)},
+"ConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["ConsBy",x]}).call(this)},
+"IdxConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["IdxConsBy",x]}).call(this)},
+"JumpTable":function(){var $elf=this,_fromIdx=this.input.idx,c,e,ces;return (function(){ces=this._many((function(){return (function(){this._form((function(){return (function(){c=this._apply("anything");return e=this._apply("trans")}).call(this)}));return [c,e]}).call(this)}));return ["JumpTable"].concat(ces)}).call(this)},
+"Interleave":function(){var $elf=this,_fromIdx=this.input.idx,m,p,xs;return (function(){xs=this._many((function(){return (function(){this._form((function(){return (function(){m=this._apply("anything");return p=this._apply("trans")}).call(this)}));return [m,p]}).call(this)}));return ["Interleave"].concat(xs)}).call(this)},
+"Rule":function(){var $elf=this,_fromIdx=this.input.idx,name,ls,body;return (function(){name=this._apply("anything");ls=this._apply("anything");body=this._apply("trans");return ["Rule",name,ls,body]}).call(this)}});(BSNullOptimization["initialize"]=(function (){(this["_didSomething"]=false)}));BSAssociativeOptimization=objectThatDelegatesTo(BSNullOptimization,{
+"And":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");this._apply("setHelped");return x}).call(this)}),(function(){return (function(){xs=this._applyWithArgs("transInside","And");return ["And"].concat(xs)}).call(this)}))},
+"Or":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");this._apply("setHelped");return x}).call(this)}),(function(){return (function(){xs=this._applyWithArgs("transInside","Or");return ["Or"].concat(xs)}).call(this)}))},
+"XOr":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");this._apply("setHelped");return x}).call(this)}),(function(){return (function(){xs=this._applyWithArgs("transInside","XOr");return ["XOr"].concat(xs)}).call(this)}))},
+"transInside":function(){var $elf=this,_fromIdx=this.input.idx,t,xs,ys,x,xs;return (function(){t=this._apply("anything");return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly",t);return xs=this._applyWithArgs("transInside",t)}).call(this)}));ys=this._applyWithArgs("transInside",t);this._apply("setHelped");return xs.concat(ys)}).call(this)}),(function(){return (function(){x=this._apply("trans");xs=this._applyWithArgs("transInside",t);return [x].concat(xs)}).call(this)}),(function(){return []}))}).call(this)}});BSSeqInliner=objectThatDelegatesTo(BSNullOptimization,{
+"App":function(){var $elf=this,_fromIdx=this.input.idx,s,cs,rule,args;return this._or((function(){return (function(){switch(this._apply('anything')){case "seq":return (function(){s=this._apply("anything");this._apply("end");cs=this._applyWithArgs("seqString",s);this._apply("setHelped");return ["And"].concat(cs).concat([["Act",s]])}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){rule=this._apply("anything");args=this._many((function(){return this._apply("anything")}));return ["App",rule].concat(args)}).call(this)}))},
+"inlineChar":function(){var $elf=this,_fromIdx=this.input.idx,c;return (function(){c=this._applyWithArgs("foreign",BSOMetaParser,'eChar');this._not((function(){return this._apply("end")}));return ["App","exactly",c.toProgramString()]}).call(this)},
+"seqString":function(){var $elf=this,_fromIdx=this.input.idx,s,cs,cs;return (function(){this._lookahead((function(){return (function(){s=this._apply("anything");return this._pred(((typeof s) === "string"))}).call(this)}));return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","\"");cs=this._many((function(){return this._apply("inlineChar")}));return this._applyWithArgs("exactly","\"")}).call(this)}));return cs}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","\'");cs=this._many((function(){return this._apply("inlineChar")}));return this._applyWithArgs("exactly","\'")}).call(this)}));return cs}).call(this)}))}).call(this)}});(JumpTable=(function (choiceOp,choice){(this["choiceOp"]=choiceOp);(this["choices"]=({}));this.add(choice)}));(JumpTable["prototype"]["add"]=(function (choice){{var c=choice[(0)];var t=choice[(1)]};if(this["choices"][c]){if((this["choices"][c][(0)] == this["choiceOp"])){this["choices"][c].push(t)}else{(this["choices"][c]=[this["choiceOp"],this["choices"][c],t])}}else{(this["choices"][c]=t)}}));(JumpTable["prototype"]["toTree"]=(function (){{var r=["JumpTable"];var choiceKeys=ownPropertyNames(this["choices"])};for(var i=(0);(i < choiceKeys["length"]);(i+=(1))){r.push([choiceKeys[i],this["choices"][choiceKeys[i]]])};return r}));BSJumpTableOptimization=objectThatDelegatesTo(BSNullOptimization,{
+"Or":function(){var $elf=this,_fromIdx=this.input.idx,cs;return (function(){cs=this._many((function(){return this._or((function(){return this._applyWithArgs("jtChoices","Or")}),(function(){return this._apply("trans")}))}));return ["Or"].concat(cs)}).call(this)},
+"XOr":function(){var $elf=this,_fromIdx=this.input.idx,cs;return (function(){cs=this._many((function(){return this._or((function(){return this._applyWithArgs("jtChoices","XOr")}),(function(){return this._apply("trans")}))}));return ["XOr"].concat(cs)}).call(this)},
+"quotedString":function(){var $elf=this,_fromIdx=this.input.idx,c,cs,c,cs;return (function(){this._lookahead((function(){return this._apply("string")}));this._form((function(){return (function(){switch(this._apply('anything')){case "\"":return (function(){cs=this._many((function(){return (function(){c=this._applyWithArgs("foreign",BSOMetaParser,'eChar');this._not((function(){return this._apply("end")}));return c}).call(this)}));return this._applyWithArgs("exactly","\"")}).call(this);case "\'":return (function(){cs=this._many((function(){return (function(){c=this._applyWithArgs("foreign",BSOMetaParser,'eChar');this._not((function(){return this._apply("end")}));return c}).call(this)}));return this._applyWithArgs("exactly","\'")}).call(this);default: throw fail}}).call(this)}));return cs.join("")}).call(this)},
+"jtChoice":function(){var $elf=this,_fromIdx=this.input.idx,x,rest,x;return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");this._form((function(){return (function(){this._applyWithArgs("exactly","App");this._applyWithArgs("exactly","exactly");return x=this._apply("quotedString")}).call(this)}));return rest=this._many((function(){return this._apply("anything")}))}).call(this)}));return [x,["And"].concat(rest)]}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","App");this._applyWithArgs("exactly","exactly");return x=this._apply("quotedString")}).call(this)}));return [x,["Act",x.toProgramString()]]}).call(this)}))},
+"jtChoices":function(){var $elf=this,_fromIdx=this.input.idx,op,c,jt,c;return (function(){op=this._apply("anything");c=this._apply("jtChoice");jt=new JumpTable(op,c);this._many((function(){return (function(){c=this._apply("jtChoice");return jt.add(c)}).call(this)}));this._apply("setHelped");return jt.toTree()}).call(this)}});BSOMetaOptimizer=objectThatDelegatesTo(OMeta,{
+"optimizeGrammar":function(){var $elf=this,_fromIdx=this.input.idx,n,sn,rs;return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","Grammar");n=this._apply("anything");sn=this._apply("anything");return rs=this._many((function(){return this._apply("optimizeRule")}))}).call(this)}));return ["Grammar",n,sn].concat(rs)}).call(this)},
+"optimizeRule":function(){var $elf=this,_fromIdx=this.input.idx,r,r,r,r;return (function(){r=this._apply("anything");this._or((function(){return r=this._applyWithArgs("foreign",BSSeqInliner,'optimize',r)}),(function(){return this._apply("empty")}));this._many((function(){return this._or((function(){return r=this._applyWithArgs("foreign",BSAssociativeOptimization,'optimize',r)}),(function(){return r=this._applyWithArgs("foreign",BSJumpTableOptimization,'optimize',r)}))}));return r}).call(this)}})}
Index: node_modules/scss/examples/tester.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/tester.js	(date 1323271705000)
+++ node_modules/scss/examples/tester.js	(date 1323271705000)
@@ -0,0 +1,15 @@
+var sys = require('sys')
+  , fs = require('fs')
+  , path = require('path')
+  , scss = require('../')
+  ;
+
+fs.readFile(path.join(__dirname, 'blog.scss'), function(err, scssFile) {
+  scss.parse(scssFile.toString(), function(err, css) {
+    if(err) {
+      sys.puts(sys.inspect(err));
+    } else {
+      sys.puts(css);
+    }
+  });
+});
Index: node_modules/scss/examples/input.scss
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/input.scss	(date 1323271705000)
+++ node_modules/scss/examples/input.scss	(date 1323271705000)
@@ -0,0 +1,1 @@
+$b : #234567; div { height:#d3e115; .error { background: $b; color:green; }} a:hover{color: $b; }
Index: node_modules/ometa/bs-ometa-js-compiler.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/bs-ometa-js-compiler.txt	(date 1323192249000)
+++ node_modules/ometa/bs-ometa-js-compiler.txt	(date 1323192249000)
@@ -0,0 +1,9 @@
+ometa BSOMetaJSParser <: BSJSParser {
+  srcElem = spaces BSOMetaParser.grammar:r sc -> r
+          | ^srcElem
+}
+
+ometa BSOMetaJSTranslator <: BSJSTranslator {
+  Grammar = BSOMetaTranslator.Grammar
+}
+
Index: node_modules/scss/specs/cssSelectorSpecs.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/specs/cssSelectorSpecs.js	(date 1323271705000)
+++ node_modules/scss/specs/cssSelectorSpecs.js	(date 1323271705000)
@@ -0,0 +1,257 @@
+var vows = require('vows'),
+    assert = require('assert'),
+    selectorGrammar = require(__dirname + '/grammarInvoker');
+
+var shouldParse = function() {
+  var selector,
+      context = {
+        topic: function() {
+          selector = this.context.name;
+          selectorGrammar.parse(selector, this.callback);
+        }
+      };
+
+  context['should parse selector'] = function(err, parsedSelector) {
+    if(err) {
+      assert.fail(err.inner.toString());
+    } else {
+      assert.equal(parsedSelector, selector);
+    }
+  };
+
+  return context;
+};
+
+var shouldParseTo = function(expectedSelector) {
+  var context = {
+        topic: function() {
+          var selector = this.context.name;
+          selectorGrammar.parse(selector, this.callback);
+        }
+      };
+
+  context['should parse selector'] = function(err, parsedSelector) {
+    if(err) {
+      assert.fail(err.inner.toString());
+    } else {
+      assert.equal(parsedSelector, expectedSelector);
+    }
+  };
+
+  return context;
+};
+
+vows.describe('Summarized Selectors').addBatch({
+  // Taken from http://www.w3.org/TR/css3-selectors/#selectors
+
+  '*': shouldParse(),
+  'E': shouldParse(),
+  'E[foo]': shouldParse(),
+  'E[foo="bar"]': shouldParse(),
+  'E[foo~="bar"]': shouldParse(),
+  'E[foo^="bar"]': shouldParse(),
+  'E[foo$="bar"]': shouldParse(),
+  'E[foo*="bar"]': shouldParse(),
+  'E[foo|="en"]': shouldParse(),
+  'E:root': shouldParse(),
+  'E:nth-child(n)': shouldParse(),
+  'E:nth-last-child(n)': shouldParse(),
+  'E:nth-of-type(n)': shouldParse(),
+  'E:nth-last-of-type(n)': shouldParse(),
+  'E:first-child': shouldParse(),
+  'E:last-child': shouldParse(),
+  'E:first-of-type': shouldParse(),
+  'E:last-of-type': shouldParse(),
+  'E:only-child': shouldParse(),
+  'E:only-of-type': shouldParse(),
+  'E:empty': shouldParse(),
+  'E:link': shouldParse(),
+  'E:visited': shouldParse(),
+  'E:active': shouldParse(),
+  'E:hover': shouldParse(),
+  'E:focus': shouldParse(),
+  'E:target': shouldParse(),
+  'E:lang(fr)': shouldParse(),
+  'E:enabled': shouldParse(),
+  'E:disabled': shouldParse(),
+  'E:checked': shouldParse(),
+  'E::first-line': shouldParse(),
+  'E::first-letter': shouldParse(),
+  'E::before': shouldParse(),
+  'E::after': shouldParse(),
+  'E.warning': shouldParse(),
+  'E#myid': shouldParse(),
+  'E:not(s)': shouldParse(),
+  'E F': shouldParse(),
+  'E > F': shouldParse(),
+  'E + F': shouldParse(),
+  'E ~ F': shouldParse()
+}).run();
+
+
+vows.describe('Lonely Selectors').addBatch({
+  // Taken from http://www.w3.org/TR/css3-selectors/#selectors,
+  // but without the element names
+
+  '[foo]': shouldParse(),
+  '[foo="bar"]': shouldParse(),
+  '[foo~="bar"]': shouldParse(),
+  '[foo^="bar"]': shouldParse(),
+  '[foo$="bar"]': shouldParse(),
+  '[foo*="bar"]': shouldParse(),
+  '[foo|="en"]': shouldParse(),
+  ':root': shouldParse(),
+  ':nth-child(n)': shouldParse(),
+  ':nth-last-child(n)': shouldParse(),
+  ':nth-of-type(n)': shouldParse(),
+  ':nth-last-of-type(n)': shouldParse(),
+  ':first-child': shouldParse(),
+  ':last-child': shouldParse(),
+  ':first-of-type': shouldParse(),
+  ':last-of-type': shouldParse(),
+  ':only-child': shouldParse(),
+  ':only-of-type': shouldParse(),
+  ':empty': shouldParse(),
+  ':link': shouldParse(),
+  ':visited': shouldParse(),
+  ':active': shouldParse(),
+  ':hover': shouldParse(),
+  ':focus': shouldParse(),
+  ':target': shouldParse(),
+  ':lang(fr)': shouldParse(),
+  ':enabled': shouldParse(),
+  ':disabled': shouldParse(),
+  ':checked': shouldParse(),
+  '::first-line': shouldParse(),
+  '::first-letter': shouldParse(),
+  '::before': shouldParse(),
+  '::after': shouldParse(),
+  '.warning': shouldParse(),
+  '#myid': shouldParse(),
+  ':not(s)': shouldParse()
+}).run();
+
+
+vows.describe('Attribute Selectors with Identifiers').addBatch({
+  '[foo~=bar]': shouldParse(),
+  '[foo^=bar]': shouldParse(),
+  '[foo$=bar]': shouldParse(),
+  '[foo*=bar]': shouldParse(),
+  '[foo|=en]': shouldParse()
+}).run();
+
+
+vows.describe('Nth Selectors').addBatch({
+  ':nth-child(-n)': shouldParse(),
+  ':nth-child(+n)': shouldParse(),
+
+  ':nth-child(even)': shouldParse(),
+  ':nth-child(odd)': shouldParse(),
+
+  ':nth-child(50)': shouldParse(),
+  ':nth-child(-50)': shouldParse(),
+  ':nth-child(+50)': shouldParse(),
+
+  ':nth-child(2n+3)': shouldParse(),
+  ':nth-child(2n-3)': shouldParse(),
+  ':nth-child(+2n-3)': shouldParse(),
+  ':nth-child(-2n+3)': shouldParse(),
+  ':nth-child(-2n+ 3)': shouldParse(),
+  ':nth-child(-2n+ 3)': shouldParse(),
+  ':nth-child(-2n+ 3)': shouldParse(),
+  ':nth-child( 2n + 3 )': shouldParseTo(':nth-child(2n + 3)')
+}).run();
+
+
+vows.describe('Negation Selectors').addBatch({
+  ':not(foo|bar)': shouldParse(),
+  ':not(*|bar)': shouldParse(),
+
+  ':not(foo|*)': shouldParse(),
+  ':not(*|*)': shouldParse(),
+
+  ':not(#blah)': shouldParse(),
+  ':not(.blah)': shouldParse(),
+
+  ':not([foo])': shouldParse(),
+  ':not([foo^="bar"])': shouldParse(),
+  ':not([baz|foo~="bar"])': shouldParse(),
+
+  ':not(:hover)': shouldParse(),
+  ':not(:nth-child(2n + 3))': shouldParse(),
+
+  // Not technically allowed, but what the heck
+  ':not(:not(#foo))': shouldParse(),
+  ':not(a#foo.bar)': shouldParse(),
+  ':not(#foo .bar > baz)': shouldParse(),
+  ':not(h1, h2, h3)': shouldParse()
+}).run();
+
+
+vows.describe('moz-any Selector').addBatch({
+  ':-moz-any(h1, h2, h3)': shouldParse(),
+  ':-moz-any(.foo)': shouldParse(),
+  ':-moz-any(foo bar, .baz > .bang)': shouldParse()
+}).run();
+
+
+vows.describe('Namespaced Selectors').addBatch({
+  'foo|E': shouldParse(),
+  '*|E': shouldParse(),
+  'foo|*': shouldParse(),
+  '*|*': shouldParse()
+}).run();
+
+
+
+vows.describe('Namespaced Attribute Selectors').addBatch({
+  '[foo|bar=baz]': shouldParse(),
+  '[*|bar=baz]': shouldParse(),
+  '[foo|bar|=baz]': shouldParse()
+}).run();
+
+
+vows.describe('Comma Selectors').addBatch({
+  'E, F': shouldParse(),
+  'E F, G H': shouldParse(),
+  'E > F, G > H': shouldParse()
+}).run();
+
+
+vows.describe('Selectors with Newlines').addBatch({
+  "E,\nF": shouldParse(),
+  "E\nF": shouldParse(),
+  "E, F\nG, H": shouldParse()
+}).run();
+
+
+vows.describe('Expression Fallback Selectors').addBatch({
+  '0%': shouldParse(),
+  '60%': shouldParse(),
+  '100%': shouldParse(),
+  '12px': shouldParse(),
+  '"foo"': shouldParse()
+}).run();
+
+
+vows.describe('Functional Pseudo Selectors').addBatch({
+  ':foo("bar")': shouldParse(),
+  ':foo(bar)': shouldParse(),
+  ':foo(12px)': shouldParse(),
+  ':foo(+)': shouldParse(),
+  ':foo(-)': shouldParse(),
+  ':foo(+"bar")': shouldParse(),
+  ':foo(-++--baz-"bar"12px)': shouldParse()
+}).run();
+
+
+vows.describe('Selector Hacks').addBatch({
+  '> E': shouldParse(),
+  '+ E': shouldParse(),
+  '~ E': shouldParse(),
+  '> > E': shouldParse(),
+  '>> E': shouldParseTo('> > E'),
+  'E*': shouldParse(),
+  'E*.foo': shouldParse(),
+  'E*:hover': shouldParse()
+}).run();
Index: node_modules/scss/specs/grammarInvoker.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/specs/grammarInvoker.js	(date 1323271705000)
+++ node_modules/scss/specs/grammarInvoker.js	(date 1323271705000)
@@ -0,0 +1,83 @@
+var sys = require('sys'),
+    fs = require('fs'),
+    ometa = require('ometa'),
+    creatingParser = false;
+
+var fixReadFile = function(rawFile) {
+  return rawFile.slice(1).replace(/\\n/g, '\n');
+};
+
+var createParser = function(parserInitializer) {
+  if(!creatingParser) {
+    creatingParser = true;
+    //fs.readFile(__dirname + '/../src/cssSelector.ometa', 'utf8', function(err, contents) {
+    fs.readFile(__dirname + '/../../ometa-js/newLineGrammar.ometa', 'utf8', function(err, contents) {
+      if(err) {
+        parserInitializer.setParser(err);
+      } else {
+        ometa.createParser(fixReadFile(contents), parserInitializer.setParser);
+      }
+      creatingParser = false;
+    });
+  }
+};
+
+var parserInitializer = (function() {
+  var createdParser,
+      parserErr,
+      queuedCallbacks = [],
+      that = {};
+
+  that.setParser = function(err, parser) {
+    parserErr = err;
+    createdParser = parser;
+    queuedCallbacks.forEach(function(callback) {
+      callback(parserErr, createdParser);
+    });
+    queuedCallbacks = [];
+  };
+
+  that.addCallback = function(callback) {
+    if(parserErr || createdParser) {
+      callback(parserErr, createdParser);
+    } else {
+      queuedCallbacks.push(callback);
+      createParser(that);
+    }
+  };
+
+  that.reset = function() {
+    createdParser = null;
+  };
+
+  return that;
+})();
+
+var parse = function(selector, callback) {
+  parserInitializer.addCallback(function(err, parser) {
+    if(err) {
+      callback(err);
+    } else {
+      parser.parse(selector, 'selectors_group', function(err, css) {
+        if(err) {
+          callback(err);
+        } else {
+          //callback(null, css.toString());
+          callback(null, css.join(''));
+        }
+      });
+    }
+  });
+};
+
+
+module.exports.parse = parse;
+module.exports.reset = parserInitializer.reset;
+var ssss = 'a,\nb';
+console.log(ssss);
+parse(ssss, function(err, shiznit) {
+  if(err) {
+    console.log(err);
+  }
+  console.log(shiznit);
+});
Index: node_modules/scss/examples/compiler_tester.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/compiler_tester.js	(date 1323271705000)
+++ node_modules/scss/examples/compiler_tester.js	(date 1323271705000)
@@ -0,0 +1,13 @@
+var sys = require('sys'),
+    fs = require('fs'),
+    compiler = require('../src/scssCompiler');
+
+fs.readFile(__dirname + '/blog.scss', function(err, scssFile) {
+  compiler.compile(scssFile.toString(), function(err, css) {
+    if(err) {
+      sys.puts(sys.inspect(err));
+    } else {
+      sys.puts(css);
+    }
+  });
+});
Index: node_modules/scss/examples/blog.scss
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/blog.scss	(date 1323271705000)
+++ node_modules/scss/examples/blog.scss	(date 1323271705000)
@@ -0,0 +1,36 @@
+$mainColor: green;
+
+@mixin a_mixin {
+  color: $mainColor;
+  div {
+    float: left;
+  }
+}
+
+@mixin child {
+  @include a_mixin;
+  background-color: $mainColor;
+  a {
+    text-decoration: none;
+  }
+}
+
+#main {
+  margin: 0 5.625em;
+  h5, h6 {
+    font-size: 1em;
+    line-height: 1.25em;
+  }
+  .post {
+    text-align: left;
+    ul {
+      list-style-position: inside;
+      list-style-type: circle;
+      margin: 0.625em;
+    }
+  }
+  .post-dash {
+    @include child;
+    color: red;
+  }
+}
Index: node_modules/ometa/.npmignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/.npmignore	(date 1323192249000)
+++ node_modules/ometa/.npmignore	(date 1323192249000)
@@ -0,0 +1,1 @@
+*.swp
Index: node_modules/scss/examples/grammarInvoker.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/examples/grammarInvoker.js	(date 1323271705000)
+++ node_modules/scss/examples/grammarInvoker.js	(date 1323271705000)
@@ -0,0 +1,43 @@
+var sys = require('sys'),
+    fs = require('fs'),
+    ometa = require('ometa'),
+    createdParser;
+
+var getParser = function(callback) {
+  if(!createdParser) {
+    fs.readFile(__dirname + '/../src/cssSelector.ometa', function(err, contents) {
+      if(err) {
+        callback(err);
+      } else {
+        ometa.createParser(contents.toString(), function(err, parser) {
+          if(err) {
+            callback(err);
+          } else {
+            createdParser = parser;
+            callback(null, createdParser);
+          }
+        });
+      }
+    });
+  } else {
+    callback(null, createdParser);
+  }
+};
+
+var parse = function(scssFile, callback) {
+  getParser(function(err, parser) {
+    if(err) {
+      callback(err);
+    } else {
+      parser.parse(scssFile, 'selectors_group', function(err, css) {
+        sys.puts(css.toString());
+      });
+    }
+  });
+};
+
+
+module.exports.parse = parse;
+parse(':not(h1, h2, h3)', function(err) {
+  sys.puts(sys.inspect(err, true, null));
+});
Index: node_modules/ometa/Worlds2.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/Worlds2.js	(date 1323192249000)
+++ node_modules/ometa/Worlds2.js	(date 1323192249000)
@@ -0,0 +1,112 @@
+/*
+  Copyright (c) 2008, 2010 Alessandro Warth <awarth@cs.ucla.edu>
+
+  Limitations:
+    * assignments into the properties of "arguments" (e.g., arguments[5] = 1234) don't modify their respective variables 
+    * for-in doesn't work when the loop variable is a property access (e.g., for (x.y in ys) ...)
+*/
+
+Array.prototype.each = function(f) {
+  for (var idx = 0; idx < this.length; idx++)
+    f(this[idx], idx)
+}
+
+ometa WJSParser <: BSJSParser {
+  isKeyword :x = ?(x == 'thisWorld')
+               | super('isKeyword', x),
+  primExprHd   = "thisWorld"            -> ['thisWorld']
+               | super('primExprHd'),
+  stmt         = "in" expr:w block:b    -> ['in', w, b]
+               | super('stmt')
+}
+
+makeFunction = function(fs, body) {
+  return '(function() { var staticScope = thisScope;'                                                            +
+                      ' var r = function() {'                                                                    +
+                        ' var oldScope = thisScope;'                                                             +
+                        ' thisScope = staticScope.makeChild();'                                                  +
+                        ' thisScope.set("arguments", arguments);'                                                +
+                        ' thisWorld.set(arguments, "length", arguments.length);'                                 +
+                        ' for (var i = 0; i < arguments.length; i++) thisWorld.set(arguments, i, arguments[i]);' +
+                        ' try { ' + fs + body + '}'                                                              +
+                        ' finally { thisScope = oldScope }};'                                                    +
+                      ' baseWorld.set(r, "prototype", {parent: Object.prototype});'                              +
+                      ' return r })()' }
+
+makeIn = function(w, body) {
+  return '{ try { worldStack.push(thisWorld); thisWorld = ' + w + '; ' + body + '} ' +
+           'finally { thisWorld = worldStack.pop() }'                                +
+           'undefined }'
+}
+
+makeForIn = function(v, e, s, decl) {
+  var p = tempnam(), ps = tempnam()
+  var r = 'for (var ' + p + ' in ' + ps + ' = thisWorld.props(' + e + ', {})) {' +
+            'if (!' + ps + '.hasOwnProperty(' + p + ')) continue; ' +
+            'thisScope.set("' + v + '", ' + p + '); ' + s +
+          '}'
+  if (decl)
+    r = 'thisScope.decl("' + v + '", undefined); ' + r
+  r = '{ var ' + ps + ' = undefined; ' + r + '}'
+  return r
+}
+
+ometa WJSTranslator <: BSJSTranslator {
+  initialize = { self.level = 0 },
+  fargs = [anything*:fs]                            -> { var ss = []
+                                                         fs.each(function(v, i) { ss.push('thisScope.decl("' + v +
+                                                                                          '", arguments[' + i + ']);') })
+                                                         ss.join('') },
+  thisWorld                                         -> 'thisWorld',
+  var  :n trans:v                                   -> ('thisScope.decl("' + n + '", ' + v + ')'),
+  get  :n                                           -> ('thisScope.get("' + n + '")'),
+  getp trans:p ['get' 'arguments']                  -> ('arguments[' + p + ']'),
+  getp trans:p trans:x                              -> ('thisWorld.get(' + x + ', ' + p + ')'),
+  set  ['get' :n]                           trans:v -> ('thisScope.set("' + n + '", ' + v + ')'),
+  set  ['getp' trans:p ['get' 'arguments']] trans:v -> 'UNSUPPORTED OPERATION',
+  set  ['getp' trans:p trans:x]             trans:v -> ('thisWorld.set(' + x + ', ' + p + ', ' + v + ')'),
+  mset ['get' :n]               :op trans:rhs       -> ('thisScope.set("' + n + '", thisScope.get("' + n + '")' + op + rhs + ')'),
+  mset ['getp' trans:p trans:x] :op trans:rhs       -> ('(function(r, p) { return thisWorld.set(r, p, thisWorld.get(r, p) ' +
+                                                           op + ' ' + rhs + ') })(' + x + ', ' + p + ')'),
+  preop  :op ['get' :n]                             -> ('thisScope.set("' + n + '", thisScope.get("' + n + '")' + op[0] + '1)'),
+  preop  :op ['getp' trans:p trans:x]               -> ('(function(r, p) { return thisWorld.set(r, p, thisWorld.get(r, p) ' +
+                                                           op[0] + ' 1) })(' + x + ', ' + p + ')'),
+  postop :op ['get' :n]                             -> ('(function(n) { var ans = thisScope.get(n); ' +
+                                                                       'thisScope.set(n, ans ' + op[0] + ' 1); ' +
+                                                                       'return ans })("' + n + '")'),
+  postop :op ['getp' trans:p trans:x]               -> ('(function(r, p) { var ans = thisWorld.get(r, p); ' +
+                                                                          'thisWorld.set(r, p, ans ' + op[0] + ' 1); ' +
+                                                                          'return ans })(' + x + ', ' + p + ')'),
+  binop 'instanceof' trans:x trans:y                -> ('instanceOf(' + x + ', ' + y + ')'),
+  binop :op          trans:x trans:y                -> ('(' + x + ' ' + op + ' ' + y + ')'),
+  call trans:f trans*:as                            -> ('(' + f + ')(' + as.join(',') + ')'),
+  send :m trans:r trans*:as                         -> ('send("' + m + '", ' + r + ', [' + as.join(',') + '])'),
+  new :x trans*:as                                  -> ('thisScope.get("' + x + '").worldsNew(' + as.join(',') + ')'),
+  func fargs:fs {self.level++} trans:body
+                {self.level--}                      -> makeFunction(fs, body),
+  in trans:w trans:b                                -> makeIn(w, b),
+  arr  trans*:xs                                    -> ('[' + xs.join(',') + '].toWJSArray()'),
+  json trans*:xs                                    -> ('({' + xs.join(',') + '}).toWJSObject()'),
+  try curlyTrans:x :name curlyTrans:c curlyTrans:f  -> { var e = tempnam()
+                                                         'try ' + x +
+                                                         'catch(' + e + ') {thisScope.decl("' + name + '", ' + e + '); ' + c + '}' +
+                                                         'finally' + f },
+  forIn ['get' :v      ] trans:e trans:s            -> makeForIn(v, e, s, false),
+  forIn ['var' :v :init] trans:e trans:s            -> makeForIn(v, e, s, true)
+}
+
+compileWJS = function(code) {
+  var tree = WJSParser.matchAll(code, "topLevel", undefined, function(m, i) { throw fail.delegated({errorPos: i}) })
+  //print("parsed: " + tree)
+  var code = WJSTranslator.match(tree, 'trans')
+  //print("compiled: " + code)
+  return code
+}
+
+thisScope.decl("eval", function(s) { return eval(compileWJS(s)) })
+
+oldPrint = print
+print = function(x) { oldPrint(x == undefined || x == null ? x : send("toString", x)) }
+
+translateCode = compileWJS
+
Index: node_modules/ometa/workspace.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/workspace.js	(date 1323192249000)
+++ node_modules/ometa/workspace.js	(date 1323192249000)
@@ -0,0 +1,223 @@
+/*
+  Copyright (c) 2007, 2008 Alessandro Warth <awarth@cs.ucla.edu>
+
+  Permission is hereby granted, free of charge, to any person
+  obtaining a copy of this software and associated documentation
+  files (the "Software"), to deal in the Software without
+  restriction, including without limitation the rights to use,
+  copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following
+  conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+  OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+// This code was adapted from Takashi Yamamiya's Javascript Workspace,
+// which you can visit at http://metatoys.org/propella/js/workspace.js
+
+// ---------------------------------------------------------------------------------------------------------------------------
+
+// INSTRUCTIONS: a client page must (1) include something along these lines:
+
+/*
+  <body onLoad="$('workspaceForm').onkeydown=onShortCutKey">
+    ...
+    <form id=workspaceForm>
+      <b>Source</b><br>
+      <textarea cols=132 rows=24 name=source>...</textarea><br>
+      <input type=button value="print it (ctrl+p)" onClick="printIt()">
+      <input type=button value="do it (ctrl+d)" onClick="doIt()">
+      <br><br>
+      <b>Translation</b>
+      <br>
+      <div id=translation>
+        <textarea cols=132 rows=4 name=translation>
+        </textArea>
+      </div>
+      <b>Transcript</b>
+      <br>
+      <div id=transcript>
+        <textarea cols=132 rows=4 name=transcript></textArea>
+      </div>
+    </form>
+    ...
+  </body>
+*/
+
+// and (2) define its own translateCode function
+
+function translateCode(s) {
+  //throw { errorPos: 0 }
+  return s
+}
+
+// ---------------------------------------------------------------------------------------------------------------------------
+
+/* event handler for short cut key */
+function onShortCutKey(evt) {
+  evt = evt ? evt : window.event;
+  if (!evt)
+    return undefined;
+  if (!(evt.altKey || evt.ctrlKey || evt.metaKey))
+    return true;
+  var charCode = evt.charCode ? evt.charCode : evt.keyCode
+  try {
+    var handledIt = true
+    switch (charCode) {
+      case 68: doIt();            break
+      case 80: printIt();         break
+      case 83: saveIt();          break
+      default: handledIt = false; return true
+    }
+  }
+  finally {
+    if (handledIt) {
+      if (evt.preventDefault) {
+        evt.preventDefault()
+        evt.stopPropagation()
+      }
+      else {
+        evt.returnValue  = false
+        evt.cancelBubble = true
+      }
+    }
+  }
+  return false
+}
+
+function printIt() {
+  var result       = evalSelection()
+  if (!result)
+    return
+  var editor       = result.source.editor,
+      end          = result.source.end,
+      head         = editor.value.substring(0, end),
+      tail         = editor.value.substring(end),
+      oldScrollTop = editor.scrollTop
+  editor.value     = head + result.result + tail;
+  editor.scrollTop = oldScrollTop
+  setCaretSelection(editor, end, head.length + result.result.length)
+}
+
+function doIt() {
+  var result = evalSelection()
+  if (result)
+    result.source.editor.focus()
+}
+
+function saveIt() { }
+
+/* Get selection of textarea */
+function getCaretSelection(field) {
+    field.focus();
+    var result = { start: 0, end: 0 };
+    // IE support based on http://groups.drupal.org/node/1210
+    if(typeof $('workspaceForm').source.selectionEnd == "undefined") {
+      var range     = document.selection.createRange(),
+          rangeCopy = range.duplicate()
+      rangeCopy.moveToElementText(field)
+      rangeCopy.setEndPoint( 'EndToEnd', range )
+      result.start = rangeCopy.text.length - range.text.length
+      result.end = result.start + range.text.length
+    }
+    else {
+      result.start = field.selectionStart
+      result.end   = field.selectionEnd
+    }
+    return result
+}
+
+/* Set selection of textarea */
+function setCaretSelection(field, start, end) {
+    field.focus()
+    // IE
+    if(typeof $('workspaceForm').source.selectionEnd == "undefined") {
+      var range = field.createTextRange()
+      range.expand("textedit")
+      var dStart = start - (field.value.substring(0, start).split("\n").length - 1),
+          dEnd   = end - field.value.length + field.value.substring(end + 1).split("\n").length - 1
+      range.moveStart("character", dStart)
+      range.moveEnd("character", dEnd)
+      range.select()
+    }
+    else {
+      field.selectionStart = start
+      field.selectionEnd   = end
+    }
+}
+
+/* Get expression from textarea */
+function getSource() {
+  var editor    = $('workspaceForm').source,
+      selection = getCaretSelection(editor),
+      start     = selection.start,
+      end       = selection.end,
+      text      = editor.value.substring(start, end)
+  if (start == end) {
+    var alltext = editor.value, index = 0
+    if (start > 0 && alltext.charAt(start) == "\n")
+      start--
+    while (start > 0 && alltext.charAt(start) != "\n")
+      start--
+    if (alltext.charAt(start) == "\n")
+      start++
+    while (end < alltext.length && alltext.charAt(end) != "\r" && alltext.charAt(end) != "\n")
+      end++
+    text = alltext.substring(start, end);
+    setCaretSelection(editor, start, end);
+  }
+  return {
+    editor: editor,
+    start:  start,
+    end:    end,
+    text:   text
+  }
+}
+
+function evalSelection() {
+  var source = getSource()
+  try { $('workspaceForm').translation.value = translateCode(source.text) }
+  catch (e) {
+    if (e.errorPos != undefined) {
+      var errorPos     = source.start + e.errorPos
+          errorMsg     = " Parse error ->",
+          oldScrollTop = $('workspaceForm').source.scrollTop
+      $('workspaceForm').source.value = $('workspaceForm').source.value.substring(0, errorPos) + errorMsg +
+                                        $('workspaceForm').source.value.substring(errorPos, $('workspaceForm').source.value.length)
+      $('workspaceForm').source.scrollTop = oldScrollTop
+      setCaretSelection($('workspaceForm').source, errorPos, errorPos + errorMsg.length)
+    }
+    return undefined
+  }
+  try {
+    return {
+      source: source,
+      result: " " + eval($('workspaceForm').translation.value)
+    }
+  } catch (e) {
+    alert("Oops!\n\n" + e)
+    throw e
+  }
+}
+
+Transcript = {
+  show:  function(x) {
+           $('workspaceForm').transcript.value     = $('workspaceForm').transcript.value + x + "\n"
+           $('workspaceForm').transcript.scrollTop = $('workspaceForm').transcript.scrollHeight
+          },
+  clear: function()  {
+           $('workspaceForm').transcript.value     = ""
+         }
+}
+
Index: node_modules/scss/src/compiler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/src/compiler.js	(date 1323271705000)
+++ node_modules/scss/src/compiler.js	(date 1323271705000)
@@ -0,0 +1,20 @@
+var scss = require('./index');
+
+var compiler = (function() {
+  return {
+    match: /\.css$/,
+    ext: '.scss',
+    compile: function(str, fn) {
+      scss.parse(str, function(err, css) {
+        if(err) {
+          fn(err);
+        } else {
+          fn(null, css);
+        }
+      });
+    }
+  };
+})();
+
+
+module.exports = compiler;
Index: node_modules/ometa/Worlds2_Library.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/Worlds2_Library.js	(date 1323192249000)
+++ node_modules/ometa/Worlds2_Library.js	(date 1323192249000)
@@ -0,0 +1,311 @@
+// Copyright (c) 2008, 2010 Alessandro Warth <awarth@cs.ucla.edu>
+
+DEBUG = false;
+
+// getTag: object -> unique id
+// tagToRef: unique id -> object
+
+// Note: this hashing scheme causes a huge memory leak (all b/c JS doesn't support weak references)
+
+(function() {
+  var numIdx = 0, tagToRef = {}
+  var _getTag = function(r) {
+    if (r === null || r === undefined)
+      return r
+    switch (typeof r) {
+      case "boolean": return r == true ? "Btrue" : "Bfalse"
+      case "string":  return "S" + r
+      case "number":  return "N" + r
+      default:        return r.hasOwnProperty("_id_") ? r._id_ : r._id_ = "R" + numIdx++
+    }
+  }
+  getTag = function(r) {
+    var tag = _getTag(r)
+    tagToRef[tag] = r
+    return tag
+  }
+  getRef = function(t) {
+    return tagToRef[t]
+  }
+})()
+
+// implementation of possible worlds
+
+worldProto = {}
+
+baseWorld = thisWorld = (function() {
+  var writes = {}
+  return {
+    parent: worldProto,
+    writes: writes,
+    hasOwn: function(r, p) {
+      var id = getTag(r)
+      return writes.hasOwnProperty(id) && writes[id].hasOwnProperty(p)
+    },
+    has: function(r, p) {
+      return this.hasOwn(r, p) ||
+             r !== Object.prototype && this.has(r === null || r === undefined ? Object.prototype : r.parent, p)
+    },
+    props: function(r, ps) {
+      var id = getTag(r)
+      if (writes.hasOwnProperty(id))
+        for (var p in writes[id])
+          if (writes[id].hasOwnProperty(p))
+            ps[p] = true
+      if (r !== Object.prototype)
+        this.props(r === null || r === undefined ? Object.prototype : r.parent, ps)
+      return ps
+    },
+    _get: function(r, p) {
+      var id = getTag(r)
+      if (DEBUG) console.log("? top-level world looking up " + id + "." + p)
+      if (writes.hasOwnProperty(id) && writes[id].hasOwnProperty(p))
+        return writes[id][p]
+      else if (r !== Object.prototype)
+        return thisWorld._get(r === null || r === undefined ? Object.prototype : r.parent, p)
+      else
+        return undefined
+    },
+    get: function(r, p) {
+      // the top-level world's commit operation is a no-op, so reads don't have to be recorded
+      if (typeof r === "string" && (typeof p === "number" || p === "length"))
+        return r[p]
+      else
+        return this._get(r, p)
+    },
+    set: function(r, p, v) {
+      if (typeof r === "string" && (typeof p === "number" || p === "length"))
+        throw "the indices and length of a string are immutable, and you tried to change them!"
+      var id = getTag(r)
+      if (DEBUG) console.log("! top-level world assigning to " + id + "." + p)
+      if (!writes.hasOwnProperty(id))
+        writes[id] = {}
+      writes[id][p] = v
+      return v
+    },
+    commit: function() { },
+    sprout: function() {
+      var parentWorld = this, writes = {}, reads = {}
+      return {
+        parent: worldProto,
+        writes: writes,
+        reads:  reads,
+        hasOwn: function(r, p) {
+          var id = getTag(r)
+          return writes.hasOwnProperty(id) && writes[id].hasOwnProperty(p) ||
+                 reads.hasOwnProperty(id)  && reads[id].hasOwnProperty(p)  ||
+                 parentWorld.hasOwn(r, p)
+        },
+        has: function(r, p) {
+          return this.hasOwn(r, p) ||
+                 r !== Object.prototype && this.has(r === null || r === undefined ? Object.prototype : r.parent, p)
+        },
+        props: function(r, ps) {
+          var id = getTag(r)
+          if (writes.hasOwnProperty(id))
+            for (var p in writes[id])
+              if (writes[id].hasOwnProperty(p))
+                ps[p] = true
+          if (reads.hasOwnProperty(id))
+            for (var p in reads[id])
+              if (reads[id].hasOwnProperty(p))
+                ps[p] = true
+          if (r !== Object.prototype)
+            this.props(r === null || r === undefined ? Object.prototype : r.parent, ps)
+          parentWorld.props(r, ps)
+          return ps
+        },
+        _get: function(r, p) {
+          var id = getTag(r)
+          if (DEBUG) console.log("? child world looking up " + id + "." + p)
+          if      (writes.hasOwnProperty(id) && writes[id].hasOwnProperty(p))
+            return writes[id][p]
+          else if (reads.hasOwnProperty(id)  && reads[id].hasOwnProperty(p))
+            return reads[id][p]
+          else
+            return parentWorld._get(r, p)
+        },
+        get: function(r, p) {
+          if (typeof r === "string" && (typeof p === "number" || p === "length"))
+            return r[p]
+          var id = getTag(r), ans = this._get(r, p)
+          if (!reads.hasOwnProperty(id)) {
+            reads[id] = {}
+            if (!reads[id].hasOwnProperty(p))
+              reads[id][p] = ans
+          }
+          return ans
+        },
+        set: function(r, p, v) {
+          if (typeof r === "string" && (typeof p === "number" || p === "length"))
+            throw "the indices and length of a string are immutable, and you tried to change them!"
+          var id = getTag(r)
+          if (DEBUG) console.log("! child world assigning to " + id + "." + p)
+          if (!writes.hasOwnProperty(id))
+            writes[id] = {}
+          writes[id][p] = v
+          return v
+        },
+        commit: function() {
+          // serializability check
+          for (var id in reads) {
+            if (!reads.hasOwnProperty(id))
+              continue
+            for (var p in reads[id]) {
+              if (!reads[id].hasOwnProperty(p))
+                continue
+              else if (reads[id][p] !== parentWorld._get(getRef(id), p))
+                throw "commit failed"
+            }
+          }
+          // propagation of side effects
+          for (var id in writes) {
+            if (!writes.hasOwnProperty(id))
+              continue
+            for (var p in writes[id]) {
+              if (!writes[id].hasOwnProperty(p))
+                continue
+              if (!parentWorld.writes.hasOwnProperty(id))
+                parentWorld.writes[id] = {}
+              if (DEBUG) console.log("committing " + id + "." + p)
+              parentWorld.writes[id][p] = writes[id][p]
+            }
+          }
+          writes = {}
+          reads  = {}
+        },
+        sprout: parentWorld.sprout
+      }
+    }
+  }
+})()
+worldStack = [thisWorld]
+
+// Lexical scopes
+
+GlobalScope = function() { }
+GlobalScope.prototype = {
+  parent:    Object.prototype,
+  hasOwn:    function(n)    { return thisWorld.hasOwn(this, n)  },
+  has:       function(n)    { return thisWorld.has(this, n)     },
+  get:       function(n)    { return thisWorld.get(this, n)     },
+  set:       function(n, v) { return thisWorld.set(this, n, v)  },
+  decl:      function(n, v) { return baseWorld.set(this, n, v)  },
+  makeChild: function()     { return new ActivationRecord(this) }
+}
+
+ActivationRecord = function(parent) { this.parent = parent }
+ActivationRecord.prototype = new GlobalScope()
+ActivationRecord.prototype.get = function(n)    { return thisWorld.has(this, n) ?
+                                                           thisWorld.get(this, n) :
+                                                           this.parent.get(n)          }
+ActivationRecord.prototype.set = function(n, v) { return thisWorld.has(this, n) ?
+                                                           thisWorld.set(this, n, v) :
+                                                           this.parent.set(n, v)       }
+
+thisScope = new GlobalScope()
+
+// Sends
+
+send = function(sel, recv, args) {
+  //alert("doing a send, sel=" + sel + ", recv=" + recv + ", args=" + args)
+  return thisWorld.get(recv, sel).apply(recv, args)
+}
+
+// New
+
+Function.prototype.worldsNew = function() {
+  var r = {parent: thisWorld.get(this, "prototype")}
+  this.apply(r, arguments)
+  return r
+}
+
+// instanceof
+
+instanceOf = function(x, C) {
+  var p = x.parent, Cp = thisWorld.get(C, "prototype")
+  while (p != undefined) {
+    if (p == Cp)
+      return true
+    p = p.parent
+  }
+  return false
+}
+
+// Some globals, etc.
+
+wObject  = function() { }
+thisScope.decl("Object",  wObject)
+thisWorld.set(wObject, "prototype", Object.prototype)
+thisWorld.set(Object.prototype, "hasOwn", function(p) { return thisWorld.has(this, p) })
+thisWorld.set(Object.prototype, "toString", function() { return "" + this })
+
+thisWorld.set(worldProto, "sprout",   function() { return this.sprout()                   })
+thisWorld.set(worldProto, "commit",   function() { return this.commit()                   })
+thisWorld.set(worldProto, "toString", function() { return "[World " + this.getTag() + "]" })
+
+wWorld    = function() { }; thisScope.decl("World",    wWorld);    thisWorld.set(wWorld,    "prototype", worldProto)
+wBoolean  = function() { }; thisScope.decl("Boolean",  wBoolean);  thisWorld.set(wBoolean,  "prototype", {parent: Object.prototype})
+wNumber   = function() { }; thisScope.decl("Number",   wNumber);   thisWorld.set(wNumber,   "prototype", {parent: Object.prototype})
+wString   = function() { }; thisScope.decl("String",   wString);   thisWorld.set(wString,   "prototype", {parent: Object.prototype})
+wArray    = function() { }; thisScope.decl("Array",    wArray);    thisWorld.set(wArray,    "prototype", {parent: Object.prototype})
+wFunction = function() { }; thisScope.decl("Function", wFunction); thisWorld.set(wFunction, "prototype", {parent: Object.prototype})
+
+Boolean.prototype.parent   = thisWorld.get(wBoolean,   "prototype")
+Number.prototype.parent    = thisWorld.get(wNumber,    "prototype")
+String.prototype.parent    = thisWorld.get(wString,    "prototype")
+Function.prototype.parent  = thisWorld.get(wFunction,  "prototype")
+// Don't need to do this for Array because Worlds/JS arrays are not JS arrays
+
+thisWorld.set(wString, "fromCharCode", function(x) { return String.fromCharCode(x) })
+thisWorld.set(String.prototype.parent, "charCodeAt", function(x) { return this.charCodeAt(x) })
+
+thisWorld.set(Function.prototype.parent, "apply", function(recv, args) {
+  var jsArgs
+  if (args && thisWorld.get(args, "length") > 0) {
+    jsArgs = []
+    for (var idx = 0; idx < thisWorld.get(args, "length"); idx++)
+      jsArgs.push(thisWorld.get(args, idx))
+  }
+  return this.apply(recv, jsArgs)
+})
+thisWorld.set(Function.prototype.parent, "call", function(recv) {
+  var jsArgs = []
+  for (var idx = 1; idx < arguments.length; idx++)
+    jsArgs.push(arguments[idx])
+  return this.apply(recv, jsArgs)
+})
+
+thisScope.decl("null",      null)
+thisScope.decl("undefined", undefined)
+thisScope.decl("true",      true)
+thisScope.decl("false",     false)
+
+thisScope.decl("jsEval",  function(s) { return eval(thisWorld.get(s, "toString").call(s))    })
+thisScope.decl("print",   function(s) { print(thisWorld.get(s, "toString").call(s))          })
+thisScope.decl("alert",   function(s) { alert(thisWorld.get(s, "toString").call(s))          })
+thisScope.decl("prompt",  function(s) { return prompt(thisWorld.get(s, "toString").call(s))  })
+thisScope.decl("confirm", function(s) { return confirm(thisWorld.get(s, "toString").call(s)) })
+
+thisScope.decl("parseInt",   function(s) { return parseInt(s)   })
+thisScope.decl("parseFloat", function(s) { return parseFloat(s) })
+
+WorldsConsole = {}
+thisScope.decl("console", WorldsConsole)
+thisWorld.set(WorldsConsole, "log", function(s) { Transcript.show(thisWorld.get(s, "toString").apply(s)) })
+
+Array.prototype.toWJSArray = function() {
+  var r = wArray.worldsNew()
+  for (var idx = 0; idx < this.length; idx++)
+    thisWorld.set(r, idx, this[idx])
+  thisWorld.set(r, "length", this.length)
+  return r
+}
+Object.prototype.toWJSObject = function() {
+  var r = wObject.worldsNew()
+  for (var p in this)
+    if (this.hasOwnProperty(p))
+      thisWorld.set(r, p, this[p])
+  return r
+}
+
Index: node_modules/scss/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/package.json	(date 1607534369788)
+++ node_modules/scss/package.json	(date 1607534369788)
@@ -0,0 +1,44 @@
+{
+  "_from": "scss",
+  "_id": "scss@0.2.4",
+  "_inBundle": false,
+  "_integrity": "sha1-BA2QPtN8XU+krTOuH9OJrBKk4GU=",
+  "_location": "/scss",
+  "_phantomChildren": {},
+  "_requested": {
+    "type": "tag",
+    "registry": true,
+    "raw": "scss",
+    "name": "scss",
+    "escapedName": "scss",
+    "rawSpec": "",
+    "saveSpec": null,
+    "fetchSpec": "latest"
+  },
+  "_requiredBy": [
+    "#USER",
+    "/"
+  ],
+  "_resolved": "https://registry.npmjs.org/scss/-/scss-0.2.4.tgz",
+  "_shasum": "040d903ed37c5d4fa4ad33ae1fd389ac12a4e065",
+  "_spec": "scss",
+  "_where": "S:\\Kool 2020-2021\\alhorythm",
+  "bundleDependencies": false,
+  "contributors": [
+    {
+      "name": "Brian Mavity",
+      "email": "brian@brianmavity.com"
+    }
+  ],
+  "dependencies": {
+    "ometa": "0.2.2"
+  },
+  "deprecated": false,
+  "description": "JavaScript Implementation of SCSS (Sassy CSS)",
+  "engines": {
+    "node": ">= 0.2.0"
+  },
+  "main": "./src/index.js",
+  "name": "scss",
+  "version": "0.2.4"
+}
Index: node_modules/scss/src/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/src/index.js	(date 1323271705000)
+++ node_modules/scss/src/index.js	(date 1323271705000)
@@ -0,0 +1,55 @@
+var sys = require('sys')
+  , fs = require('fs')
+  , path = require('path')
+  , ometa = require('ometa')
+  , rule = 'scssFile'
+  , createdParser
+  ;
+
+var fixReadFile = function(rawFile) {
+  return rawFile.slice(1).replace(/\\n/g, '\n');
+};
+
+var getParser = function(callback) {
+  if(!createdParser) {
+    fs.readFile(path.join(__dirname, '/CssSelector.ometa'), 'utf8', function(err, cssSelectorContents) {
+      var selectorFile = fixReadFile(cssSelectorContents); 
+      ometa.createParser(selectorFile, function(err, cssSelectorParser) {
+        fs.readFile(path.join(__dirname, '/scss.ometa'), 'utf8', function(err, contents) {
+          var contentFile = fixReadFile(contents); 
+          if(err) {
+            callback(err);
+          } else {
+            ometa.createParser(contentFile, function(err, parser) {
+              if(err) {
+                callback(err);
+              } else {
+                createdParser = parser;
+                callback(null, createdParser);
+              }
+            });
+          }
+        });
+      });
+    });
+  } else {
+    callback(null, createdParser);
+  }
+};
+
+var parse = function(scssFile, callback) {
+  getParser(function(err, parser) {
+    if(err) {
+      callback(err);
+    } else {
+      parser.parse(scssFile, rule, function(err, css) {
+        require(__dirname + '/prettyPrint').render(css, function(inner, printed) {
+          callback(err, printed);
+        });
+      });
+    }
+  });
+};
+
+
+module.exports.parse = parse;
Index: node_modules/scss/src/cssSelector.ometa
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/src/cssSelector.ometa	(date 1323271705000)
+++ node_modules/scss/src/cssSelector.ometa	(date 1323271705000)
@@ -0,0 +1,162 @@
+ometa CssSelector <: Parser {
+  crChar = '\r',
+  ffChar = '\f',
+  nlChar = '\n',
+  tabChar = '\t',
+  lineEnding = crChar | ffChar | nlChar,
+  tabOrLineEnding = tabChar | lineEnding,
+
+
+  ident = '-' nmstart:s nmchar*:cs -> { '-' + s + cs.join('') } 
+        | nmstart:s nmchar*:cs -> { s + cs.join('') },
+  name = nmchar+:n -> { n.join('') },
+  nmstart = ('_' | letter | nonascii | escape):n -> { n },
+  nonascii = '',
+  unicode = '',
+  escape = unicode | '',
+  nmchar = '_' | '-' | letterOrDigit | nonascii | escape,
+  num = digit+: d -> d.join('')
+      | digit* '.' digit+,
+  string = (string1 | string2):s -> { s },
+  //string1 = '\"' (~(lineEnding | '\"') | '\\' nl | nonascii | escape)*:s '\"' -> { '\"' + s.join('') + '\"' },
+  string1 = '"' letter*:s '"' -> { '"' + s.join('') + '"' },
+  string2 = '\'' (~(lineEnding | '\'') | '\\' nl | nonascii | escape)*:s '\'' -> { '\'' + s.join('') + '\'' },
+  //invalid = invalid1 | invalid2,
+  //invalid1 = '\"' (~(lineEnding | '\"') | '\\' nl | nonascii | escape)*,
+  //invalid2 = '\'' (~(lineEnding | '\'') | '\\' nl | nonascii | escape)*,
+  nl = crChar nlChar
+     | lineEnding,
+  D = 'd' | 'D',
+  E = 'e' | 'E',
+  N = 'n' | 'N',
+  O = 'o' | 'O',
+  T = 't' | 'T',
+  V = 'v' | 'V',
+
+
+  S = ' ' -> { ' ' }
+    | '\n' -> { '\n' },
+  INCLUDES = '~' '=' -> { '~=' },
+  DASHMATCH = '|' '=' -> { '|=' },
+  PREFIXMATCH = '^' '=' -> { '^=' },
+  SUFFIXMATCH = '$' '=' -> { '$=' },
+  SUBSTRINGMATCH = '*' '=' -> { '*=' },
+  IDENT = ident,
+  STRING = string:s -> { s },
+  FUNCTION = ident:i '(' -> { i + '(' },
+  NUMBER = num:n -> { n },
+  HASH = '#' name:n -> { '#' + n },
+  PLUS = S+ '+' -> { ' +' }
+       | '+' -> { '+' },
+  // First line of next selector is a Css Hack
+  GREATER = '>' '>' -> { '> >' }
+          | S+ '>' -> { ' >' }
+          | '>' -> { '>' },
+  COMMA = S+ ',' -> { ' ,' }
+        | ',' -> { ',' },
+  TILDE = S+ '~' -> { ' ~' }
+        | '~' -> { '~' },
+  NOT = ':' N O T '(' -> { ':not(' },
+  ATKEYWORD = '@' ident,
+  INVALID = invalid,
+  PERCENTAGE = num:n '%' -> { n + '%' },
+  DIMENSION = num:n ident:i -> { n + i },
+  CDO = '<' '!' '-' '-',
+  CDC = '-' '-' '>',
+
+
+  selectors_group = selector:pre comma_separated_selector* -> { self.addSelector(pre); self },
+  comma_separated_selector = COMMA:com S*:spacing selector:sel -> { self.addCommaSeparatedSelector(com + spacing.join(''), sel) },
+  selector = simple_selector_sequence:sim (combined_sequence)*:additional -> { sim + additional.join('') }
+           // Css Hack
+           | combined_sequence*:comb -> { comb.join('') },
+  combinator = PLUS:p S+ -> { p + ' ' }
+             | PLUS:p -> { p }
+             | GREATER:g S+ -> { g + ' ' }
+             | GREATER:g -> { g }
+             | TILDE:t S+ -> { t + ' ' }
+             | TILDE:t -> { t }
+             | S+:spacing -> { spacing.join('') },
+  combined_sequence = combinator+:comb simple_selector_sequence:sel -> { comb.join('') + sel },
+  non_namespaced_selector = (HASH | class | attrib | negation | pseudo):sel -> { sel },
+  simple_selector_sequence = namespace_prefix:pre '*' non_namespaced_selector*:post -> { pre + '*' + post.join('') }
+                           | namespace_prefix:pre element_name:ele non_namespaced_selector*:post -> { pre + ele + post.join('') }
+                           | '*' non_namespaced_selector*:post -> { '*' + post.join('') }
+                           | element_name:ele non_namespaced_selector*:post -> { ele + post.join('') }
+                           | non_namespaced_selector+:sels -> { sels.join('') }
+                           // Css Hack
+                           | expression:ex -> { ex },
+  namespace_prefix = ('*' | IDENT):pre '|' -> { pre + '|' }
+                   | '|' -> { '|' },
+  // First line of the next selector is a Css Hack
+  element_name = IDENT:i '*' -> { i + '*' }
+               | IDENT:i -> { i },
+  class = '.' IDENT:i -> { '.' + i },
+
+  attrib = '[' S* possible_namespaced_attrib:att ']' -> { '[' + att + ']' },
+  possible_namespaced_attrib = namespace_prefix:pre ident_with_possible_postfix:post -> { pre + post }
+                             | ident_with_possible_postfix:post -> { post },
+  ident_with_possible_postfix = IDENT:left S* attrib_match:match S* (IDENT | STRING):right S* -> { left + match + right }
+                              | IDENT:i S* -> { i },
+  attrib_match = (PREFIXMATCH | SUFFIXMATCH | SUBSTRINGMATCH | equals_match | INCLUDES | DASHMATCH):m -> { m },
+  equals_match = '=' -> { '=' },
+  pseudo = ':' ':' (functional_pseudo | IDENT):i -> { '::' + i }
+         | ':' (functional_pseudo | IDENT):i -> { ':' + i },
+  functional_pseudo = FUNCTION:f S* full_expression:e ')' -> { f + e + ')' }
+                    // Css Hack for :-moz-any(...)
+                    | FUNCTION:f S* selectors_group:sel ')' -> { f + sel.toString() + ')' },
+
+  expression_content = (PLUS | '-' | PERCENTAGE | DIMENSION | NUMBER | STRING | IDENT):e -> { e },
+  expression = expression_content:ec S+ expression:e -> { ec + ' ' + e }
+             | expression_content:ec expression:e -> { ec + e }
+             | expression_content:ec S* -> { ec },
+  full_expression = (expression)+:ea -> { ea.join('') },
+  negation = NOT:n S* negation_arg:na S* ')' -> { n + na + ')' },
+
+  //negation_arg = (type_selector | universal | HASH | class | attrib | pseudo):na -> { na }
+  //Technically not allowed, but here for scss compatibility
+  negation_arg = selectors_group:sg -> { sg.toString() }
+}
+
+CssSelector.initialize = function() {
+  var hasBeenStringified = false,
+      self = this;
+
+  this.selector;
+  this.selectors = [];
+  this.commaSeparatedSelectors = [];
+
+  var resetFields = function() {
+    self.selector = null;
+    self.selectors = [];
+    self.commaSeparatedSelectors = [];
+    hasBeenStrigified = false;
+  };
+
+  this.addSelector = function(sel) {
+    if(hasBeenStringified) {
+      resetFields();
+    }
+    this.selector = sel;
+  };
+
+  this.addCommaSeparatedSelector = function(commaAndSpacing, selector) {
+    if(hasBeenStringified) {
+      resetFields();
+    }
+    this.selectors.push(selector);
+    this.commaSeparatedSelectors.push({
+      commaAndSpacing: commaAndSpacing,
+      selector: selector
+    });
+  };
+
+  this.toString = function() {
+    hasBeenStringified = true;
+    return this.selector + this.commaSeparatedSelectors.map(function(csSel) {
+      return csSel.commaAndSpacing + csSel.selector;
+    }).join('');
+  };
+};
+
+CssSelector
Index: node_modules/scss/src/scss.ometa
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/src/scss.ometa	(date 1323271705000)
+++ node_modules/scss/src/scss.ometa	(date 1323271705000)
@@ -0,0 +1,92 @@
+ometa Scss <: Parser {
+  selector = foreign(CssSelector, 'selectors_group'):sel -> { self.addSelector(sel) },
+  
+  propertyValue = '$' letterOrDigit+:val -> ('$' + val.join(''))
+                | ('#' | '.' | ',' | '-' | space | letterOrDigit)+:val -> val.join(''),
+  property = spaces ('-' | letter)+:prop ":" spaces propertyValue:val ";" -> { self.addProperty({ name: prop.join(''), val: val }); },
+
+  blockBody = "{" (mixinInclude | property | scssBlock)* "}" -> { self.endBlock(); },
+  scssBlock = spaces selector blockBody,
+
+  scssVariable = "$" letter+:name ":" spaces propertyValue:val ";" -> { self.addVariable({ name: name.join(''), val: val }); },
+
+  mixinName = spaces ('-' | '_' | letterOrDigit)+:name -> name.join(''),
+  mixinInclude = "@include" mixinName:name ";" -> { self.addInclude(name); },
+  mixinDeclaration = "@mixin" mixinName:name -> { self.addMixin(name); },
+  scssMixin = mixinDeclaration blockBody,
+
+  scssFile = (scssVariable | scssMixin | scssBlock)* -> { self.getFile(); }
+}
+
+Scss.initialize = function() {
+  var blocks = [],
+      mixins = {},
+      variables = {},
+      file,
+      currentBlock;
+  
+  var createBlock = function() {
+    var parentBlock = currentBlock;
+    return {
+      blocks: [],
+      includes: [],
+      properties: [],
+      end: function() {
+        currentBlock = parentBlock;
+      }
+    };
+  };
+
+  this.addMixin = function(mixinName) {
+    var block = createBlock();
+    mixins[mixinName] = block;
+    currentBlock = block;
+  };
+
+  this.addProperty = function(prop) {
+    currentBlock.properties.push(prop);
+  };
+
+  this.addInclude = function(include) {
+    currentBlock.includes.push(include);
+  };
+
+  this.addSelector = function(sel) {
+    var block;
+    if(sel.selector) {
+      block = createBlock();
+      block.selector = sel.selector;
+      block.selectors = sel.selectors;
+      currentBlock.blocks.push(block);
+      currentBlock = block;
+    }
+  };
+
+  this.endBlock = function() {
+    currentBlock.end();
+  };
+
+  this.addVariable = function(variable) {
+    variables[variable.name] = variable.val;
+  };
+
+  this.getFile = function() {
+    return file;
+  };
+
+  file = {
+    blocks: [],
+    end: function() {
+      currentBlock = file;
+    },
+    getMixin: function(mixinName) {
+      return mixins[mixinName];
+    },
+    getValue: function(variableName) {
+      return variables[variableName];
+    }
+  };
+  currentBlock = file;
+};
+
+Scss
Index: node_modules/scss/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/README.md	(date 1323271705000)
+++ node_modules/scss/README.md	(date 1323271705000)
@@ -0,0 +1,77 @@
+# scss-js
+## A JavaScript implementation of SCSS (Sassy CSS)
+
+## API
+
+### Connect Compiler
+
+    var sys = require('sys'),
+        fs = require('fs'),
+        compiler = require('../src/scssCompiler');
+    
+    fs.readFile(__dirname + '/blog.scss', function(err, scssFile) {
+      compiler.compile(scssFile.toString(), function(err, css) {
+        if(err) {
+          sys.puts(sys.inspect(err));
+        } else {
+          sys.puts(css);
+        }
+      });
+    });
+
+The compile function takes a string and returns another string with the file's css.
+
+## Where Does the Project Stand?
+
+### What's Usable?
+  * CSS Selectors
+  * Nested Rules
+  * Variables
+  * Fixed Mixins
+
+### What Needs Work?
+  * CSS Selectors
+  * Variable and Mixin names
+
+### What's Unimplemented?
+  * Parameterized Mixins
+  * Functions
+
+## Next Release (0.2.0)
+
+Full CSS Selector implementation
+
+
+## Special Thanks
+
+I would like to give special thanks to [Hampton Catlin](http://hamptoncatlin.com),
+[Nathan Weizenbaum](http://nex-3.com), and [Chris Eppstein](http://acts-as-architect.blogspot.com)
+for starting and continuing the haml and sass project. I'd also like to thank the rest of the people
+that have contributed to [Sass](http://sass-lang.com/) and I hope I can catch up to your
+awesomeness.
+
+## Modified MIT License
+
+Copyright (c) 2010 Brian Mavity 
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+Except as contained in this notice, the name(s) of the above copyright
+holders shall not be used in advertising or otherwise to promote the sale,
+use or other dealings in this Software without prior written authorization.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
Index: node_modules/scss/src/prettyPrint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/scss/src/prettyPrint.js	(date 1323271705000)
+++ node_modules/scss/src/prettyPrint.js	(date 1323271705000)
@@ -0,0 +1,87 @@
+function renderProperty(fileObj, propertyObj) {
+  var getPropertyValue = function(val) {
+    if(val.indexOf('$') == 0) {
+      return fileObj.getValue(val.replace('$', ''));
+    }
+    return val;
+  };
+
+  return propertyObj.name + ': ' + getPropertyValue(propertyObj.val) + ';';
+};
+
+function renderBlock(fileObj, blockObj, scope) {
+  var selector = blockObj.selector,
+      scopeIndent = (scope && scope.indent) || '',
+      currentIndent = scopeIndent + '  ',
+      paddedScopeSelector = (scope && scope.selector) ? scope.selector + ' ' : '',
+      currentSelector = paddedScopeSelector + selector,
+      selectors = blockObj.selectors,
+      properties = blockObj.properties,
+      blocks = blockObj.blocks,
+      includes = blockObj.includes,
+      css = scopeIndent + currentSelector;
+  
+  var expandIncludes = function(includeNames) {
+    includeNames.forEach(function(includeName) {
+      var mixin = fileObj.getMixin(includeName);
+      //Why doesn't .concat() work?
+      //properties.concat(mixin.properties);
+      //blocks.concat(mixin.blocks);
+      mixin.properties.forEach(function(property) {
+        properties.push(property);
+      });
+      mixin.blocks.forEach(function(block) {
+        blocks.push(block);
+      });
+      expandIncludes(mixin.includes);
+    });
+  };
+  expandIncludes(includes);
+
+  selectors.forEach(function(sel) {
+    css += ',\n' + scopeIndent + paddedScopeSelector + sel;
+  });
+
+  css += ' {\n';
+
+  properties.forEach(function(property) {
+    css += currentIndent + renderProperty(fileObj, property) + '\n';
+  });
+
+  css += scopeIndent + '}\n';
+
+  blocks.forEach(function(block) {
+    css += renderBlock(fileObj, block, {
+      indent: currentIndent,
+      selector: currentSelector
+    });
+  });
+
+  return css;
+};
+
+function renderFile(fileObj) {
+  var blocks = fileObj.blocks,
+      css = '';
+
+  blocks.forEach(function(block) {
+    css += renderBlock(fileObj, block);
+    css += '\n';
+  });
+
+  return css;
+};
+
+function render(cssObj, callback) {
+  var css;
+  try {
+    css = renderFile(cssObj);
+    callback(null, css)
+  }
+  catch(ex) {
+    callback(ex);
+  }
+};
+
+
+module.exports.render = render;
Index: node_modules/ometa/Things_You_Should_Know.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/Things_You_Should_Know.txt	(date 1323192249000)
+++ node_modules/ometa/Things_You_Should_Know.txt	(date 1323192249000)
@@ -0,0 +1,149 @@
+OMeta/JS is a new version of OMeta, a language for pattern-directed metaprogramming first described in
+
+  Alessandro Warth and Ian Piumarta, "OMeta: An Object-Oriented Language for Pattern-Matching," in Proceedings of the Dynamic
+  Languages Symposium, 2007. (Available at http://www.cs.ucla.edu/~awarth/papers/dls07.pdf)
+
+This page contains the information necessary for someone who has read the OMeta paper to be able to use OMeta/JS.
+
+
+Pattern Syntax
+--------------
+
++------------------------------------------------------------------------+
+| "kind of thing"      OMeta                    OMeta/JS                 |
++------------------------------------------------------------------------+
+| boolean              true                     true                     |
+| number               123                      123                      |
+| character            'x'                      'x'                      |   (see note #1)
+| string               "foo"                   'foo'                     |
+|                                              `foo                      |
+|                                               #foo                     |
+| atom                 foo                      N/A                      |
+| rule application     <expr>                   expr                     |
+|                      <r x y>                  r(x, y)                  |   (see note #3)
+|                      <super stmt>             ^stmt                    |   (see note #4)
+| list                 ("hello" 42 answer ())   ['hello' 42 `answer []]  |
+| negation             ~'x'                     ~'x'                     |
+| look-ahead           ~~'x'                    ~~'x'                    |
+|                                               &'x'                     |
+| semantic predicate   ?(> x y)                 ?(x > y)                 |  (see note #2)
+| semantic action      => (+ x y)               -> (x + y)               |
+|                      !(+ x y)                 !(x + y)                 |
+| binding              <expr>:x                 expr:x                   |  (in OMeta/JS, spaces are not allowed before the colon)
+|                                               :x                       |  (this is shorthand for "anything:x")
++------------------------------------------------------------------------+
+
+
+Note #1: There is no such thing as a character in JavaScript. Even though the language lets you access each "character" of a string via indexing, e.g, "foo"[0], the answer is not a character, but rather a string of length 1.
+
+
+Note #2: In the version of OMeta described in the paper, semantic actions and predicates were written in COLA (kind of a mix between Scheme and Smalltalk). In OMeta/JS, they are written in JavaScript. More specifically, they are either primary expressions, e.g.,
+
+  123
+  x
+  foo.bar()
+  new Person()
+  (x + y)      // note that you need parentheses around "x + y" in order to make it into a primary expression
+
+or something I made up called "statement expressions", which have the form
+
+  "{" <statement>* <expr> "}"
+
+For example,
+
+  { x += 2; y = "foo"; f(x) }
+
+The value of a statement expression is equal to that of its last expression.
+
+
+Note #3: The arguments you pass to a rule don't have to be statement expressions - they can be any JavaScript expression.
+
+Note #4: In OMeta/JS, "super" is just like any other rule (not a special form), so you have to quote the rule name that you pass in as an argument, e.g., both ^r(1, 2) and super("r", 1, 2) are valid super-sends.
+
+
+A "Handy" New Shorthand
+-----------------------
+
+In OMeta/JS, the pattern
+
+  "foo"
+
+does not match the string 'foo'; it is instead shorthand for
+
+  token('foo')
+
+The Parser grammar provides a definition for token that skips any number of spaces, then tries to match the sequence of characters that was passed to it as an argument. I have used this in many of the example projects, and have found it to be very useful.
+
+Still, there are times when this is not what you want. But that's not a problem, because you can define it to do whatever you want (see the JavaScript Compiler project for an example).
+
+
+Rules
+-----
+
+Here is a parameterized rule taken from the paper, in the original OMeta syntax:
+
+  cRange x y ::= <char>:c ?(>= c x)
+                          ?(<= c y) => c;
+
+And here is the same rule rule, in the new OMeta/JS syntax:
+
+  cRange :x :y = char:c ?(c >= x)
+                        ?(c <= y) -> c
+
+
+A couple of (purely syntactic) differences:
+
+(1) rule declarations now use "=" instead of "::=", and
+(2) they are no longer terminated with a ";"
+
+
+A more significant difference has to do with the rule's arguments; note that in the OMeta/JS version, they are preceded by a ':'. This is actually shorthand for
+
+  cRange anything:x anything:y = ...
+
+This change has to do with an improvement in the parameter-passing mechanism, which now allows a rule's parameters to be pattern-matched against. (See the paper's "Future Work" section for more details.)
+
+The "=" is actually optional in rule declarations... this, combined with some new syntax that allows a rule to have multiple definitions that are tried in lexicographic order, allows programmers to write rules that have an "ML flavor":
+
+  ometa M {
+    fact 0                         -> 1,
+    fact :n ?(n > 0) fact(n - 1):m -> (n * m)
+  }
+  M.match(5, "fact")
+
+
+Grammar Syntax
+--------------
+
+The only change here has to do with rule declarations, which now must be separated by commas:
+
+  ometa M {
+    x = y z,
+    y = "foo" "bar",
+    z = "baz"
+  }
+
+
+Using Grammars "from the outside"
+----------------------------------
+
+The public interface provided by an OMeta/JS grammar object to the rest of the world consists of two methods:
+
+  match(object, ruleName)
+
+and
+
+  matchAll(arrayOrStringObject, ruleName)
+
+
+Here's an example that hopefully explains the difference between the two. The key to understanding it is that a string is just a list of characters.
+
+  ometa M <: Parser {
+    theCharacters  = "the" "cat" "sat" "on" "the" "mat",
+    theWholeString = [theCharacters] 
+  }
+
+  input = "the cat sat on the mat"
+  M.matchAll(input, "theCharacters")
+  M.match(input, "theWholeString")
+
Index: .idea/alhorythm.iml
===================================================================
--- .idea/alhorythm.iml	(date 1607504959834)
+++ .idea/alhorythm.iml	(date 1607504959834)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="WEB_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: node_modules/ometa/w2shell
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/w2shell	(date 1323192249000)
+++ node_modules/ometa/w2shell	(date 1323192249000)
@@ -0,0 +1,2 @@
+./v8 Worlds2_Library.js ometa-rhino.js Worlds2.js arrays.wjs $@ --shell
+
Index: node_modules/ometa/v8-shell.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/v8-shell.cc	(date 1323192249000)
+++ node_modules/ometa/v8-shell.cc	(date 1323192249000)
@@ -0,0 +1,320 @@
+// Support for translateCode added by Alex Warth <alex@vpri.org>
+
+// Copyright 2009 the V8 project authors. All rights reserved.
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+//       copyright notice, this list of conditions and the following
+//       disclaimer in the documentation and/or other materials provided
+//       with the distribution.
+//     * Neither the name of Google Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <v8.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+v8::Handle<v8::Context> context;
+
+void RunShell(v8::Handle<v8::Context> context);
+bool ExecuteString(v8::Handle<v8::String> source,
+                   v8::Handle<v8::Value> name,
+                   bool print_result,
+                   bool report_exceptions);
+v8::Handle<v8::Value> Print(const v8::Arguments& args);
+v8::Handle<v8::Value> Read(const v8::Arguments& args);
+v8::Handle<v8::Value> Load(const v8::Arguments& args);
+v8::Handle<v8::Value> Quit(const v8::Arguments& args);
+v8::Handle<v8::Value> Version(const v8::Arguments& args);
+v8::Handle<v8::String> ReadFile(const char* name);
+void ReportException(v8::TryCatch* handler);
+
+
+int RunMain(int argc, char* argv[]) {
+  v8::V8::SetFlagsFromCommandLine(&argc, argv, true);
+  v8::HandleScope handle_scope;
+  // Create a template for the global object.
+  v8::Handle<v8::ObjectTemplate> global = v8::ObjectTemplate::New();
+  // Bind the global 'print' function to the C++ Print callback.
+  global->Set(v8::String::New("print"), v8::FunctionTemplate::New(Print));
+  // Bind the global 'read' function to the C++ Read callback.
+  global->Set(v8::String::New("read"), v8::FunctionTemplate::New(Read));
+  // Bind the global 'load' function to the C++ Load callback.
+  global->Set(v8::String::New("load"), v8::FunctionTemplate::New(Load));
+  // Bind the 'quit' function
+  global->Set(v8::String::New("quit"), v8::FunctionTemplate::New(Quit));
+  // Bind the 'version' function
+  global->Set(v8::String::New("version"), v8::FunctionTemplate::New(Version));
+  // Create a new execution environment containing the built-in
+  // functions
+  context = v8::Context::New(NULL, global);
+  // Enter the newly created execution environment.
+  v8::Context::Scope context_scope(context);
+  bool run_shell = (argc == 1);
+  for (int i = 1; i < argc; i++) {
+    const char* str = argv[i];
+    if (strcmp(str, "--shell") == 0) {
+      run_shell = true;
+    } else if (strcmp(str, "-f") == 0) {
+      // Ignore any -f flags for compatibility with the other stand-
+      // alone JavaScript engines.
+      continue;
+    } else if (strncmp(str, "--", 2) == 0) {
+      printf("Warning: unknown flag %s.\nTry --help for options\n", str);
+    } else if (strcmp(str, "-e") == 0 && i + 1 < argc) {
+      // Execute argument given to -e option directly
+      v8::HandleScope handle_scope;
+      v8::Handle<v8::String> file_name = v8::String::New("unnamed");
+      v8::Handle<v8::String> source = v8::String::New(argv[i + 1]);
+      if (!ExecuteString(source, file_name, false, true))
+        return 1;
+      i++;
+    } else {
+      // Use all other arguments as names of files to load and run.
+      v8::HandleScope handle_scope;
+      v8::Handle<v8::String> file_name = v8::String::New(str);
+      v8::Handle<v8::String> source = ReadFile(str);
+      if (source.IsEmpty()) {
+        printf("Error reading '%s'\n", str);
+        return 1;
+      }
+      if (!ExecuteString(source, file_name, false, true))
+        return 1;
+    }
+  }
+  if (run_shell) RunShell(context);
+  return 0;
+}
+
+
+int main(int argc, char* argv[]) {
+  int result = RunMain(argc, argv);
+  v8::V8::Dispose();
+  return result;
+}
+
+
+// Extracts a C string from a V8 Utf8Value.
+const char* ToCString(const v8::String::Utf8Value& value) {
+  return *value ? *value : "<string conversion failed>";
+}
+
+
+// The callback that is invoked by v8 whenever the JavaScript 'print'
+// function is called.  Prints its arguments on stdout separated by
+// spaces and ending with a newline.
+v8::Handle<v8::Value> Print(const v8::Arguments& args) {
+  bool first = true;
+  for (int i = 0; i < args.Length(); i++) {
+    v8::HandleScope handle_scope;
+    if (first) {
+      first = false;
+    } else {
+      printf(" ");
+    }
+    v8::String::Utf8Value str(args[i]);
+    const char* cstr = ToCString(str);
+    printf("%s", cstr);
+  }
+  printf("\n");
+  fflush(stdout);
+  return v8::Undefined();
+}
+
+
+// The callback that is invoked by v8 whenever the JavaScript 'read'
+// function is called.  This function loads the content of the file named in
+// the argument into a JavaScript string.
+v8::Handle<v8::Value> Read(const v8::Arguments& args) {
+  if (args.Length() != 1) {
+    return v8::ThrowException(v8::String::New("Bad parameters"));
+  }
+  v8::String::Utf8Value file(args[0]);
+  if (*file == NULL) {
+    return v8::ThrowException(v8::String::New("Error loading file"));
+  }
+  v8::Handle<v8::String> source = ReadFile(*file);
+  if (source.IsEmpty()) {
+    return v8::ThrowException(v8::String::New("Error loading file"));
+  }
+  return source;
+}
+
+
+// The callback that is invoked by v8 whenever the JavaScript 'load'
+// function is called.  Loads, compiles and executes its argument
+// JavaScript file.
+v8::Handle<v8::Value> Load(const v8::Arguments& args) {
+  for (int i = 0; i < args.Length(); i++) {
+    v8::HandleScope handle_scope;
+    v8::String::Utf8Value file(args[i]);
+    if (*file == NULL) {
+      return v8::ThrowException(v8::String::New("Error loading file"));
+    }
+    v8::Handle<v8::String> source = ReadFile(*file);
+    if (source.IsEmpty()) {
+      return v8::ThrowException(v8::String::New("Error loading file"));
+    }
+    if (!ExecuteString(source, v8::String::New(*file), false, false)) {
+      return v8::ThrowException(v8::String::New("Error executing file"));
+    }
+  }
+  return v8::Undefined();
+}
+
+
+// The callback that is invoked by v8 whenever the JavaScript 'quit'
+// function is called.  Quits.
+v8::Handle<v8::Value> Quit(const v8::Arguments& args) {
+  // If not arguments are given args[0] will yield undefined which
+  // converts to the integer value 0.
+  int exit_code = args[0]->Int32Value();
+  exit(exit_code);
+  return v8::Undefined();
+}
+
+
+v8::Handle<v8::Value> Version(const v8::Arguments& args) {
+  return v8::String::New(v8::V8::GetVersion());
+}
+
+
+// Reads a file into a v8 string.
+v8::Handle<v8::String> ReadFile(const char* name) {
+  FILE* file = fopen(name, "rb");
+  if (file == NULL) return v8::Handle<v8::String>();
+
+  fseek(file, 0, SEEK_END);
+  int size = ftell(file);
+  rewind(file);
+
+  char* chars = new char[size + 1];
+  chars[size] = '\0';
+  for (int i = 0; i < size;) {
+    int read = fread(&chars[i], 1, size - i, file);
+    i += read;
+  }
+  fclose(file);
+  v8::Handle<v8::String> result = v8::String::New(chars, size);
+  delete[] chars;
+  return result;
+}
+
+
+// The read-eval-execute loop of the shell.
+void RunShell(v8::Handle<v8::Context> context) {
+  printf("V8 version %s\n", v8::V8::GetVersion());
+  static const int kBufferSize = 256;
+  while (true) {
+    char buffer[kBufferSize];
+    printf("> ");
+    char* str = fgets(buffer, kBufferSize, stdin);
+    if (str == NULL) break;
+    v8::HandleScope handle_scope;
+    ExecuteString(v8::String::New(str),
+                  v8::String::New("(shell)"),
+                  true,
+                  true);
+  }
+  printf("\n");
+}
+
+
+bool iExecuteString(v8::Handle<v8::String> source,
+                    v8::Handle<v8::Value> name,
+                    v8::Handle<v8::Value> &result,
+                    bool report_exceptions) {
+  v8::HandleScope handle_scope;
+  v8::TryCatch try_catch;
+  v8::Handle<v8::Script> script = v8::Script::Compile(source, name);
+  if (script.IsEmpty()) {
+    // Print errors that happened during compilation.
+    if (report_exceptions)
+      ReportException(&try_catch);
+    return false;
+  } else {
+    result = script->Run();
+    if (result.IsEmpty()) {
+      // Print errors that happened during execution.
+      if (report_exceptions)
+        ReportException(&try_catch);
+      return false;
+    } else {
+      return true;
+    }
+  }
+}
+
+
+// Executes a string within the current v8 context.
+bool ExecuteString(v8::Handle<v8::String> source,
+                   v8::Handle<v8::Value> name,
+                   bool print_result,
+                   bool report_exceptions) {
+  v8::Handle<v8::Value> result;
+  context->Global()->Set(v8::String::New("__xy7z"), source);
+  bool ok = true;
+  ok = iExecuteString(v8::String::New("if ((function() { return this.translateCode })()) __xy7z = translateCode(__xy7z)"),
+                      name, result, false);
+  if (ok)
+    ok = iExecuteString(v8::String::New("__xy7z = eval(__xy7z)"), name, result, report_exceptions);
+  else {
+    iExecuteString(v8::String::New("translateCode = undefined"), name, result, report_exceptions);
+    printf("error: translateCode failed and has been set to undefined in order to make the shell operational again\n");
+  }
+  if (ok && print_result && !result->IsUndefined())
+    iExecuteString(v8::String::New("print(__xy7z)"), name, result, report_exceptions);
+  return ok;
+}
+
+
+void ReportException(v8::TryCatch* try_catch) {
+  v8::HandleScope handle_scope;
+  v8::String::Utf8Value exception(try_catch->Exception());
+  const char* exception_string = ToCString(exception);
+  v8::Handle<v8::Message> message = try_catch->Message();
+  if (message.IsEmpty()) {
+    // V8 didn't provide any extra information about this error; just
+    // print the exception.
+    printf("%s\n", exception_string);
+  } else {
+    // Print (filename):(line number): (message).
+    v8::String::Utf8Value filename(message->GetScriptResourceName());
+    const char* filename_string = ToCString(filename);
+    int linenum = message->GetLineNumber();
+    printf("%s:%i: %s\n", filename_string, linenum, exception_string);
+    // Print line of source code.
+    v8::String::Utf8Value sourceline(message->GetSourceLine());
+    const char* sourceline_string = ToCString(sourceline);
+    printf("%s\n", sourceline_string);
+    // Print wavy underline (GetUnderline is deprecated).
+    int start = message->GetStartColumn();
+    for (int i = 0; i < start; i++) {
+      printf(" ");
+    }
+    int end = message->GetEndColumn();
+    for (int i = start; i < end; i++) {
+      printf("^");
+    }
+    printf("\n");
+  }
+}
Index: node_modules/ometa/wiki.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/wiki.js	(date 1323192249000)
+++ node_modules/ometa/wiki.js	(date 1323192249000)
@@ -0,0 +1,73 @@
+function readFile(name) {
+  var r
+  new Ajax.Request("projects/" + name + ".txt", {
+    method:       "get",
+    asynchronous: false,
+    onSuccess:    function(transport) { r = transport.responseText },
+    onFailure:    function(transport) { r = "" },
+    onException:  function(x)         { console.log(x) }
+  })
+  return r
+}
+
+function writeFile(name, text) {
+  var ok = true
+  new Ajax.Request("projects/" + name + ".txt", {
+    method:       "put",
+    asynchronous: false,
+    postBody:     text,
+    onFailure:    function() { ok = false }
+  })
+  if (!ok)
+    throw "unable to write file '" + name + "'"
+}
+
+function projectIsDirty() { return $('workspaceForm').source.value != $('workspaceForm').source.origValue }
+dirtyAreYouSureMessage = "The changes you have made to this project will be lost unless you press 'cancel' " +
+                         "and save your work. Proceed?"
+
+window.onbeforeunload = function() { if (projectIsDirty()) return dirtyAreYouSureMessage }
+
+function loadProject() {
+  if (arguments.length > 0) {
+    if (arguments[0] == "" || "#" + arguments[0] == document.location.hash)
+      return
+    document.location.hash = hashChangedHandler.oldHash = "#" + arguments[0]
+  }
+  if (projectIsDirty() && !confirm(dirtyAreYouSureMessage))
+    return
+  var projName = document.location.hash.substring(1),
+      projData = readFile(projName)
+  $('workspaceForm').source.value     = projData
+  $('workspaceForm').source.origValue = projData
+  $('title').innerHTML = "<font color=#000088>" + projName.replace(/_/g, " ") + "</font>" + titleRest
+}
+
+function saveProject() {
+  try {
+    var projName = document.location.hash.substring(1),
+        projData = $('workspaceForm').source.value
+    // the following is an ugly hack to fix a bug in prototype.js
+    if (projData == "")
+      projData = " "
+    writeFile(projName, projData)
+    $('workspaceForm').source.origValue = projData
+    alert("Project '" + projName + "' saved")
+  }
+  catch (e) {
+    alert("Error: " + e + "\n" +
+          "Please save your work locally (by cutting and pasting),\n" +
+          "and let Alex know about this problem.")
+    throw e
+  }
+}
+
+hashChangedHandler = function() {
+  if (document.location.hash == hashChangedHandler.oldHash)
+    return
+  hashChangedHandler.oldHash = document.location.hash
+  loadProject()
+}
+hashChangedHandler.oldHash    = document.location.hash
+hashChangedHandler.intervalId = setInterval(hashChangedHandler, 1000)
+
Index: node_modules/ometa/standalone.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- node_modules/ometa/standalone.html	(date 1323192249000)
+++ node_modules/ometa/standalone.html	(date 1323192249000)
@@ -0,0 +1,154 @@
+<html>
+  <head>
+    <script src="lib.js"></script>
+    <script src="ometa-base.js"></script>
+    <script src="parser.js"></script>
+    <script src="bs-js-compiler.js"></script>
+    <script src="bs-ometa-compiler.js"></script>
+    <script src="bs-ometa-optimizer.js"></script>
+    <script src="bs-ometa-js-compiler.js"></script>
+    <script src="ometa-script-tag.js"></script>
+
+    <script type="text/x-ometa-js">
+ometa CssSelector <: Parser {
+  crChar = '\r',
+  ffChar = '\f',
+  nlChar = '\n',
+  tabChar = '\t',
+  lineEnding = crChar | ffChar | nlChar,
+  tabOrLineEnding = tabChar | lineEnding,
+
+
+  ident = '-' nmstart:s nmchar*:cs -> { '-' + s + cs.join('') } 
+        | nmstart:s nmchar*:cs -> { s + cs.join('') },
+  name = nmchar+:n -> { n.join('') },
+  nmstart = ('_' | letter | nonascii | escape):n -> { n },
+  nonascii = '',
+  unicode = '',
+  escape = unicode | '',
+  nmchar = '_' | '-' | letterOrDigit | nonascii | escape,
+  num = digit+: d -> d.join('')
+      | digit* '.' digit+,
+  string = (string1 | string2):s -> { s },
+  //string1 = '\"' (~(lineEnding | '\"') | '\\' nl | nonascii | escape)*:s '\"' -> { '\"' + s.join('') + '\"' },
+  string1 = '"' letter*:s '"' -> { '"' + s.join('') + '"' },
+  string2 = '\'' (~(lineEnding | '\'') | '\\' nl | nonascii | escape)*:s '\'' -> { '\'' + s.join('') + '\'' },
+  //invalid = invalid1 | invalid2,
+  //invalid1 = '\"' (~(lineEnding | '\"') | '\\' nl | nonascii | escape)*,
+  //invalid2 = '\'' (~(lineEnding | '\'') | '\\' nl | nonascii | escape)*,
+  nl = crChar nlChar
+     | lineEnding,
+  D = 'd' | 'D',
+  E = 'e' | 'E',
+  N = 'n' | 'N',
+  O = 'o' | 'O',
+  T = 't' | 'T',
+  V = 'v' | 'V',
+
+
+  S = ' ' -> { ' ' }
+    | '\n' -> { '\n' },
+  INCLUDES = '~' '=' -> { '~=' },
+  DASHMATCH = '|' '=' -> { '|=' },
+  PREFIXMATCH = '^' '=' -> { '^=' },
+  SUFFIXMATCH = '$' '=' -> { '$=' },
+  SUBSTRINGMATCH = '*' '=' -> { '*=' },
+  IDENT = ident,
+  STRING = string:s -> { s },
+  FUNCTION = ident:i '(' -> { i + '(' },
+  NUMBER = num:n -> { n },
+  HASH = '#' name:n -> { '#' + n },
+  PLUS = S+ '+' -> { ' +' }
+       | '+' -> { '+' },
+  // First line of next selector is a Css Hack
+  GREATER = '>' '>' -> { '> >' }
+          | S+ '>' -> { ' >' }
+          | '>' -> { '>' },
+  COMMA = S+ ',' -> { ' ,' }
+        | ',' -> { ',' },
+  TILDE = S+ '~' -> { ' ~' }
+        | '~' -> { '~' },
+  NOT = ':' N O T '(' -> { ':not(' },
+  ATKEYWORD = '@' ident,
+  INVALID = invalid,
+  PERCENTAGE = num:n '%' -> { n + '%' },
+  DIMENSION = num:n ident:i -> { n + i },
+  CDO = '<' '!' '-' '-',
+  CDC = '-' '-' '>',
+
+
+  selectors_group = selector:pre comma_separated_selector*:post -> { self.add(pre + post.join('')); self },
+  comma_separated_selector = COMMA:com S*:spacing selector:sel -> { com + spacing.join('') + sel },
+  selector = simple_selector_sequence:sim (combined_sequence)*:additional -> { sim + additional.join('') }
+           // Css Hack
+           | combined_sequence*:comb -> { comb.join('') },
+  combinator = PLUS:p S+ -> { p + ' ' }
+             | PLUS:p -> { p }
+             | GREATER:g S+ -> { g + ' ' }
+             | GREATER:g -> { g }
+             | TILDE:t S+ -> { t + ' ' }
+             | TILDE:t -> { t }
+             | S+:spacing -> { spacing.join('') },
+  combined_sequence = combinator:comb simple_selector_sequence:sel -> { comb + sel }
+                    | combinator+:comb simple_selector_sequence:sel -> { comb.join('') + sel },
+  non_namespaced_selector = (HASH | class | attrib | negation | pseudo):sel -> { sel },
+  simple_selector_sequence = namespace_prefix:pre '*' non_namespaced_selector*:post -> { pre + '*' + post.join('') }
+                           | namespace_prefix:pre element_name:ele non_namespaced_selector*:post -> { pre + ele + post.join('') }
+                           | '*' non_namespaced_selector*:post -> { '*' + post.join('') }
+                           | element_name:ele non_namespaced_selector*:post -> { ele + post.join('') }
+                           | non_namespaced_selector+:sels -> { sels.join('') }
+                           // Css Hack
+                           | expression:ex -> { ex },
+  namespace_prefix = ('*' | IDENT):pre '|' -> { pre + '|' }
+                   | '|' -> { '|' },
+  // First line of the next selector is a Css Hack
+  element_name = IDENT:i '*' -> { i + '*' }
+               | IDENT:i -> { i },
+  class = '.' IDENT:i -> { '.' + i },
+
+  attrib = '[' S* possible_namespaced_attrib:att ']' -> { '[' + att + ']' },
+  possible_namespaced_attrib = namespace_prefix:pre ident_with_possible_postfix:post -> { pre + post }
+                             | ident_with_possible_postfix:post -> { post },
+  ident_with_possible_postfix = IDENT:left S* attrib_match:match S* (IDENT | STRING):right S* -> { left + match + right }
+                              | IDENT:i S* -> { i },
+  attrib_match = (PREFIXMATCH | SUFFIXMATCH | SUBSTRINGMATCH | equals_match | INCLUDES | DASHMATCH):m -> { m },
+  equals_match = '=' -> { '=' },
+  pseudo = ':' ':' (functional_pseudo | IDENT):i -> { '::' + i }
+         | ':' (functional_pseudo | IDENT):i -> { ':' + i },
+  functional_pseudo = FUNCTION:f S* full_expression:e ')' -> { f + e + ')' }
+                    // Css Hack for :-moz-any(...)
+                    | FUNCTION:f S* selectors_group:sel ')' -> { f + sel + ')' },
+
+  expression_content = (PLUS | '-' | PERCENTAGE | DIMENSION | NUMBER | STRING | IDENT):e -> { e },
+  expression = expression_content:ec S+ expression:e -> { ec + ' ' + e }
+             | expression_content:ec expression:e -> { ec + e }
+             | expression_content:ec S* -> { ec },
+  full_expression = (expression)+:ea -> { ea.join('') },
+  negation = NOT:n S* negation_arg:na S* ')' -> { n + na + ')' },
+
+  //negation_arg = (type_selector | universal | HASH | class | attrib | pseudo):na -> { na }
+  //Technically not allowed, but here for scss compatibility
+  negation_arg = (selectors_group):na -> { na }
+}
+
+CssSelector.initialize = function() {
+  var s;
+  
+  this.toString = function() {
+    return s;
+  };
+
+  this.add = function(st) {
+    s = st;
+  };
+};
+
+      console.log(CssSelector.matchAll("E,\nF", "selectors_group").toString());
+      console.log(CssSelector.matchAll("E\nF", "selectors_group").toString());
+      console.log(CssSelector.matchAll("E, F\nG, H", "selectors_group").toString());
+    </script>
+
+  <body>
+    hello world
+  </body>
+</html>
